;(function (t) {
  const e = (t["en"] = t["en"] || {})
  e.dictionary = Object.assign(e.dictionary || {}, {
    "%0 of %1": "%0 of %1",
    Aquamarine: "Aquamarine",
    Black: "Black",
    Blue: "Blue",
    "Dim grey": "Dim grey",
    "Dropdown toolbar": "Dropdown toolbar",
    "Edit block": "Edit block",
    "Editor block content toolbar": "Editor block content toolbar",
    "Editor contextual toolbar": "Editor contextual toolbar",
    "Editor editing area: %0": "Editor editing area: %0",
    "Editor toolbar": "Editor toolbar",
    Green: "Green",
    Grey: "Grey",
    HEX: "HEX",
    "Insert paragraph after block": "Insert paragraph after block",
    "Insert paragraph before block": "Insert paragraph before block",
    "Light blue": "Light blue",
    "Light green": "Light green",
    "Light grey": "Light grey",
    Next: "Next",
    Orange: "Orange",
    "Press Enter to type after or press Shift + Enter to type before the widget":
      "Press Enter to type after or press Shift + Enter to type before the widget",
    Previous: "Previous",
    Purple: "Purple",
    Red: "Red",
    Redo: "Redo",
    "Rich Text Editor": "Rich Text Editor",
    "Select all": "Select all",
    "Show more items": "Show more items",
    Turquoise: "Turquoise",
    Undo: "Undo",
    White: "White",
    "Widget toolbar": "Widget toolbar",
    Yellow: "Yellow",
  })
})(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {}))
/*!
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */
;(function t(e, n) {
  if (typeof exports === "object" && typeof module === "object") module.exports = n()
  else if (typeof define === "function" && define.amd) define([], n)
  else if (typeof exports === "object") exports["ClassicEditor"] = n()
  else e["ClassicEditor"] = n()
})(self, () =>
  (() => {
    var t = {
      168: (t, e, n) => {
        const o = n(874)
        const r = {}
        for (const t of Object.keys(o)) {
          r[o[t]] = t
        }
        const i = {
          rgb: { channels: 3, labels: "rgb" },
          hsl: { channels: 3, labels: "hsl" },
          hsv: { channels: 3, labels: "hsv" },
          hwb: { channels: 3, labels: "hwb" },
          cmyk: { channels: 4, labels: "cmyk" },
          xyz: { channels: 3, labels: "xyz" },
          lab: { channels: 3, labels: "lab" },
          lch: { channels: 3, labels: "lch" },
          hex: { channels: 1, labels: ["hex"] },
          keyword: { channels: 1, labels: ["keyword"] },
          ansi16: { channels: 1, labels: ["ansi16"] },
          ansi256: { channels: 1, labels: ["ansi256"] },
          hcg: { channels: 3, labels: ["h", "c", "g"] },
          apple: { channels: 3, labels: ["r16", "g16", "b16"] },
          gray: { channels: 1, labels: ["gray"] },
        }
        t.exports = i
        for (const t of Object.keys(i)) {
          if (!("channels" in i[t])) {
            throw new Error("missing channels property: " + t)
          }
          if (!("labels" in i[t])) {
            throw new Error("missing channel labels property: " + t)
          }
          if (i[t].labels.length !== i[t].channels) {
            throw new Error("channel and label counts mismatch: " + t)
          }
          const { channels: e, labels: n } = i[t]
          delete i[t].channels
          delete i[t].labels
          Object.defineProperty(i[t], "channels", { value: e })
          Object.defineProperty(i[t], "labels", { value: n })
        }
        i.rgb.hsl = function (t) {
          const e = t[0] / 255
          const n = t[1] / 255
          const o = t[2] / 255
          const r = Math.min(e, n, o)
          const i = Math.max(e, n, o)
          const s = i - r
          let a
          let c
          if (i === r) {
            a = 0
          } else if (e === i) {
            a = (n - o) / s
          } else if (n === i) {
            a = 2 + (o - e) / s
          } else if (o === i) {
            a = 4 + (e - n) / s
          }
          a = Math.min(a * 60, 360)
          if (a < 0) {
            a += 360
          }
          const l = (r + i) / 2
          if (i === r) {
            c = 0
          } else if (l <= 0.5) {
            c = s / (i + r)
          } else {
            c = s / (2 - i - r)
          }
          return [a, c * 100, l * 100]
        }
        i.rgb.hsv = function (t) {
          let e
          let n
          let o
          let r
          let i
          const s = t[0] / 255
          const a = t[1] / 255
          const c = t[2] / 255
          const l = Math.max(s, a, c)
          const d = l - Math.min(s, a, c)
          const h = function (t) {
            return (l - t) / 6 / d + 1 / 2
          }
          if (d === 0) {
            r = 0
            i = 0
          } else {
            i = d / l
            e = h(s)
            n = h(a)
            o = h(c)
            if (s === l) {
              r = o - n
            } else if (a === l) {
              r = 1 / 3 + e - o
            } else if (c === l) {
              r = 2 / 3 + n - e
            }
            if (r < 0) {
              r += 1
            } else if (r > 1) {
              r -= 1
            }
          }
          return [r * 360, i * 100, l * 100]
        }
        i.rgb.hwb = function (t) {
          const e = t[0]
          const n = t[1]
          let o = t[2]
          const r = i.rgb.hsl(t)[0]
          const s = (1 / 255) * Math.min(e, Math.min(n, o))
          o = 1 - (1 / 255) * Math.max(e, Math.max(n, o))
          return [r, s * 100, o * 100]
        }
        i.rgb.cmyk = function (t) {
          const e = t[0] / 255
          const n = t[1] / 255
          const o = t[2] / 255
          const r = Math.min(1 - e, 1 - n, 1 - o)
          const i = (1 - e - r) / (1 - r) || 0
          const s = (1 - n - r) / (1 - r) || 0
          const a = (1 - o - r) / (1 - r) || 0
          return [i * 100, s * 100, a * 100, r * 100]
        }
        function s(t, e) {
          return (t[0] - e[0]) ** 2 + (t[1] - e[1]) ** 2 + (t[2] - e[2]) ** 2
        }
        i.rgb.keyword = function (t) {
          const e = r[t]
          if (e) {
            return e
          }
          let n = Infinity
          let i
          for (const e of Object.keys(o)) {
            const r = o[e]
            const a = s(t, r)
            if (a < n) {
              n = a
              i = e
            }
          }
          return i
        }
        i.keyword.rgb = function (t) {
          return o[t]
        }
        i.rgb.xyz = function (t) {
          let e = t[0] / 255
          let n = t[1] / 255
          let o = t[2] / 255
          e = e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92
          n = n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92
          o = o > 0.04045 ? ((o + 0.055) / 1.055) ** 2.4 : o / 12.92
          const r = e * 0.4124 + n * 0.3576 + o * 0.1805
          const i = e * 0.2126 + n * 0.7152 + o * 0.0722
          const s = e * 0.0193 + n * 0.1192 + o * 0.9505
          return [r * 100, i * 100, s * 100]
        }
        i.rgb.lab = function (t) {
          const e = i.rgb.xyz(t)
          let n = e[0]
          let o = e[1]
          let r = e[2]
          n /= 95.047
          o /= 100
          r /= 108.883
          n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116
          o = o > 0.008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116
          r = r > 0.008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116
          const s = 116 * o - 16
          const a = 500 * (n - o)
          const c = 200 * (o - r)
          return [s, a, c]
        }
        i.hsl.rgb = function (t) {
          const e = t[0] / 360
          const n = t[1] / 100
          const o = t[2] / 100
          let r
          let i
          let s
          if (n === 0) {
            s = o * 255
            return [s, s, s]
          }
          if (o < 0.5) {
            r = o * (1 + n)
          } else {
            r = o + n - o * n
          }
          const a = 2 * o - r
          const c = [0, 0, 0]
          for (let t = 0; t < 3; t++) {
            i = e + (1 / 3) * -(t - 1)
            if (i < 0) {
              i++
            }
            if (i > 1) {
              i--
            }
            if (6 * i < 1) {
              s = a + (r - a) * 6 * i
            } else if (2 * i < 1) {
              s = r
            } else if (3 * i < 2) {
              s = a + (r - a) * (2 / 3 - i) * 6
            } else {
              s = a
            }
            c[t] = s * 255
          }
          return c
        }
        i.hsl.hsv = function (t) {
          const e = t[0]
          let n = t[1] / 100
          let o = t[2] / 100
          let r = n
          const i = Math.max(o, 0.01)
          o *= 2
          n *= o <= 1 ? o : 2 - o
          r *= i <= 1 ? i : 2 - i
          const s = (o + n) / 2
          const a = o === 0 ? (2 * r) / (i + r) : (2 * n) / (o + n)
          return [e, a * 100, s * 100]
        }
        i.hsv.rgb = function (t) {
          const e = t[0] / 60
          const n = t[1] / 100
          let o = t[2] / 100
          const r = Math.floor(e) % 6
          const i = e - Math.floor(e)
          const s = 255 * o * (1 - n)
          const a = 255 * o * (1 - n * i)
          const c = 255 * o * (1 - n * (1 - i))
          o *= 255
          switch (r) {
            case 0:
              return [o, c, s]
            case 1:
              return [a, o, s]
            case 2:
              return [s, o, c]
            case 3:
              return [s, a, o]
            case 4:
              return [c, s, o]
            case 5:
              return [o, s, a]
          }
        }
        i.hsv.hsl = function (t) {
          const e = t[0]
          const n = t[1] / 100
          const o = t[2] / 100
          const r = Math.max(o, 0.01)
          let i
          let s
          s = (2 - n) * o
          const a = (2 - n) * r
          i = n * r
          i /= a <= 1 ? a : 2 - a
          i = i || 0
          s /= 2
          return [e, i * 100, s * 100]
        }
        i.hwb.rgb = function (t) {
          const e = t[0] / 360
          let n = t[1] / 100
          let o = t[2] / 100
          const r = n + o
          let i
          if (r > 1) {
            n /= r
            o /= r
          }
          const s = Math.floor(6 * e)
          const a = 1 - o
          i = 6 * e - s
          if ((s & 1) !== 0) {
            i = 1 - i
          }
          const c = n + i * (a - n)
          let l
          let d
          let h
          switch (s) {
            default:
            case 6:
            case 0:
              l = a
              d = c
              h = n
              break
            case 1:
              l = c
              d = a
              h = n
              break
            case 2:
              l = n
              d = a
              h = c
              break
            case 3:
              l = n
              d = c
              h = a
              break
            case 4:
              l = c
              d = n
              h = a
              break
            case 5:
              l = a
              d = n
              h = c
              break
          }
          return [l * 255, d * 255, h * 255]
        }
        i.cmyk.rgb = function (t) {
          const e = t[0] / 100
          const n = t[1] / 100
          const o = t[2] / 100
          const r = t[3] / 100
          const i = 1 - Math.min(1, e * (1 - r) + r)
          const s = 1 - Math.min(1, n * (1 - r) + r)
          const a = 1 - Math.min(1, o * (1 - r) + r)
          return [i * 255, s * 255, a * 255]
        }
        i.xyz.rgb = function (t) {
          const e = t[0] / 100
          const n = t[1] / 100
          const o = t[2] / 100
          let r
          let i
          let s
          r = e * 3.2406 + n * -1.5372 + o * -0.4986
          i = e * -0.9689 + n * 1.8758 + o * 0.0415
          s = e * 0.0557 + n * -0.204 + o * 1.057
          r = r > 0.0031308 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92
          i = i > 0.0031308 ? 1.055 * i ** (1 / 2.4) - 0.055 : i * 12.92
          s = s > 0.0031308 ? 1.055 * s ** (1 / 2.4) - 0.055 : s * 12.92
          r = Math.min(Math.max(0, r), 1)
          i = Math.min(Math.max(0, i), 1)
          s = Math.min(Math.max(0, s), 1)
          return [r * 255, i * 255, s * 255]
        }
        i.xyz.lab = function (t) {
          let e = t[0]
          let n = t[1]
          let o = t[2]
          e /= 95.047
          n /= 100
          o /= 108.883
          e = e > 0.008856 ? e ** (1 / 3) : 7.787 * e + 16 / 116
          n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116
          o = o > 0.008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116
          const r = 116 * n - 16
          const i = 500 * (e - n)
          const s = 200 * (n - o)
          return [r, i, s]
        }
        i.lab.xyz = function (t) {
          const e = t[0]
          const n = t[1]
          const o = t[2]
          let r
          let i
          let s
          i = (e + 16) / 116
          r = n / 500 + i
          s = i - o / 200
          const a = i ** 3
          const c = r ** 3
          const l = s ** 3
          i = a > 0.008856 ? a : (i - 16 / 116) / 7.787
          r = c > 0.008856 ? c : (r - 16 / 116) / 7.787
          s = l > 0.008856 ? l : (s - 16 / 116) / 7.787
          r *= 95.047
          i *= 100
          s *= 108.883
          return [r, i, s]
        }
        i.lab.lch = function (t) {
          const e = t[0]
          const n = t[1]
          const o = t[2]
          let r
          const i = Math.atan2(o, n)
          r = (i * 360) / 2 / Math.PI
          if (r < 0) {
            r += 360
          }
          const s = Math.sqrt(n * n + o * o)
          return [e, s, r]
        }
        i.lch.lab = function (t) {
          const e = t[0]
          const n = t[1]
          const o = t[2]
          const r = (o / 360) * 2 * Math.PI
          const i = n * Math.cos(r)
          const s = n * Math.sin(r)
          return [e, i, s]
        }
        i.rgb.ansi16 = function (t, e = null) {
          const [n, o, r] = t
          let s = e === null ? i.rgb.hsv(t)[2] : e
          s = Math.round(s / 50)
          if (s === 0) {
            return 30
          }
          let a =
            30 + ((Math.round(r / 255) << 2) | (Math.round(o / 255) << 1) | Math.round(n / 255))
          if (s === 2) {
            a += 60
          }
          return a
        }
        i.hsv.ansi16 = function (t) {
          return i.rgb.ansi16(i.hsv.rgb(t), t[2])
        }
        i.rgb.ansi256 = function (t) {
          const e = t[0]
          const n = t[1]
          const o = t[2]
          if (e === n && n === o) {
            if (e < 8) {
              return 16
            }
            if (e > 248) {
              return 231
            }
            return Math.round(((e - 8) / 247) * 24) + 232
          }
          const r =
            16 +
            36 * Math.round((e / 255) * 5) +
            6 * Math.round((n / 255) * 5) +
            Math.round((o / 255) * 5)
          return r
        }
        i.ansi16.rgb = function (t) {
          let e = t % 10
          if (e === 0 || e === 7) {
            if (t > 50) {
              e += 3.5
            }
            e = (e / 10.5) * 255
            return [e, e, e]
          }
          const n = (~~(t > 50) + 1) * 0.5
          const o = (e & 1) * n * 255
          const r = ((e >> 1) & 1) * n * 255
          const i = ((e >> 2) & 1) * n * 255
          return [o, r, i]
        }
        i.ansi256.rgb = function (t) {
          if (t >= 232) {
            const e = (t - 232) * 10 + 8
            return [e, e, e]
          }
          t -= 16
          let e
          const n = (Math.floor(t / 36) / 5) * 255
          const o = (Math.floor((e = t % 36) / 6) / 5) * 255
          const r = ((e % 6) / 5) * 255
          return [n, o, r]
        }
        i.rgb.hex = function (t) {
          const e =
            ((Math.round(t[0]) & 255) << 16) +
            ((Math.round(t[1]) & 255) << 8) +
            (Math.round(t[2]) & 255)
          const n = e.toString(16).toUpperCase()
          return "000000".substring(n.length) + n
        }
        i.hex.rgb = function (t) {
          const e = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i)
          if (!e) {
            return [0, 0, 0]
          }
          let n = e[0]
          if (e[0].length === 3) {
            n = n
              .split("")
              .map((t) => t + t)
              .join("")
          }
          const o = parseInt(n, 16)
          const r = (o >> 16) & 255
          const i = (o >> 8) & 255
          const s = o & 255
          return [r, i, s]
        }
        i.rgb.hcg = function (t) {
          const e = t[0] / 255
          const n = t[1] / 255
          const o = t[2] / 255
          const r = Math.max(Math.max(e, n), o)
          const i = Math.min(Math.min(e, n), o)
          const s = r - i
          let a
          let c
          if (s < 1) {
            a = i / (1 - s)
          } else {
            a = 0
          }
          if (s <= 0) {
            c = 0
          } else if (r === e) {
            c = ((n - o) / s) % 6
          } else if (r === n) {
            c = 2 + (o - e) / s
          } else {
            c = 4 + (e - n) / s
          }
          c /= 6
          c %= 1
          return [c * 360, s * 100, a * 100]
        }
        i.hsl.hcg = function (t) {
          const e = t[1] / 100
          const n = t[2] / 100
          const o = n < 0.5 ? 2 * e * n : 2 * e * (1 - n)
          let r = 0
          if (o < 1) {
            r = (n - 0.5 * o) / (1 - o)
          }
          return [t[0], o * 100, r * 100]
        }
        i.hsv.hcg = function (t) {
          const e = t[1] / 100
          const n = t[2] / 100
          const o = e * n
          let r = 0
          if (o < 1) {
            r = (n - o) / (1 - o)
          }
          return [t[0], o * 100, r * 100]
        }
        i.hcg.rgb = function (t) {
          const e = t[0] / 360
          const n = t[1] / 100
          const o = t[2] / 100
          if (n === 0) {
            return [o * 255, o * 255, o * 255]
          }
          const r = [0, 0, 0]
          const i = (e % 1) * 6
          const s = i % 1
          const a = 1 - s
          let c = 0
          switch (Math.floor(i)) {
            case 0:
              r[0] = 1
              r[1] = s
              r[2] = 0
              break
            case 1:
              r[0] = a
              r[1] = 1
              r[2] = 0
              break
            case 2:
              r[0] = 0
              r[1] = 1
              r[2] = s
              break
            case 3:
              r[0] = 0
              r[1] = a
              r[2] = 1
              break
            case 4:
              r[0] = s
              r[1] = 0
              r[2] = 1
              break
            default:
              r[0] = 1
              r[1] = 0
              r[2] = a
          }
          c = (1 - n) * o
          return [(n * r[0] + c) * 255, (n * r[1] + c) * 255, (n * r[2] + c) * 255]
        }
        i.hcg.hsv = function (t) {
          const e = t[1] / 100
          const n = t[2] / 100
          const o = e + n * (1 - e)
          let r = 0
          if (o > 0) {
            r = e / o
          }
          return [t[0], r * 100, o * 100]
        }
        i.hcg.hsl = function (t) {
          const e = t[1] / 100
          const n = t[2] / 100
          const o = n * (1 - e) + 0.5 * e
          let r = 0
          if (o > 0 && o < 0.5) {
            r = e / (2 * o)
          } else if (o >= 0.5 && o < 1) {
            r = e / (2 * (1 - o))
          }
          return [t[0], r * 100, o * 100]
        }
        i.hcg.hwb = function (t) {
          const e = t[1] / 100
          const n = t[2] / 100
          const o = e + n * (1 - e)
          return [t[0], (o - e) * 100, (1 - o) * 100]
        }
        i.hwb.hcg = function (t) {
          const e = t[1] / 100
          const n = t[2] / 100
          const o = 1 - n
          const r = o - e
          let i = 0
          if (r < 1) {
            i = (o - r) / (1 - r)
          }
          return [t[0], r * 100, i * 100]
        }
        i.apple.rgb = function (t) {
          return [(t[0] / 65535) * 255, (t[1] / 65535) * 255, (t[2] / 65535) * 255]
        }
        i.rgb.apple = function (t) {
          return [(t[0] / 255) * 65535, (t[1] / 255) * 65535, (t[2] / 255) * 65535]
        }
        i.gray.rgb = function (t) {
          return [(t[0] / 100) * 255, (t[0] / 100) * 255, (t[0] / 100) * 255]
        }
        i.gray.hsl = function (t) {
          return [0, 0, t[0]]
        }
        i.gray.hsv = i.gray.hsl
        i.gray.hwb = function (t) {
          return [0, 100, t[0]]
        }
        i.gray.cmyk = function (t) {
          return [0, 0, 0, t[0]]
        }
        i.gray.lab = function (t) {
          return [t[0], 0, 0]
        }
        i.gray.hex = function (t) {
          const e = Math.round((t[0] / 100) * 255) & 255
          const n = (e << 16) + (e << 8) + e
          const o = n.toString(16).toUpperCase()
          return "000000".substring(o.length) + o
        }
        i.rgb.gray = function (t) {
          const e = (t[0] + t[1] + t[2]) / 3
          return [(e / 255) * 100]
        }
      },
      85: (t, e, n) => {
        const o = n(168)
        const r = n(111)
        const i = {}
        const s = Object.keys(o)
        function a(t) {
          const e = function (...e) {
            const n = e[0]
            if (n === undefined || n === null) {
              return n
            }
            if (n.length > 1) {
              e = n
            }
            return t(e)
          }
          if ("conversion" in t) {
            e.conversion = t.conversion
          }
          return e
        }
        function c(t) {
          const e = function (...e) {
            const n = e[0]
            if (n === undefined || n === null) {
              return n
            }
            if (n.length > 1) {
              e = n
            }
            const o = t(e)
            if (typeof o === "object") {
              for (let t = o.length, e = 0; e < t; e++) {
                o[e] = Math.round(o[e])
              }
            }
            return o
          }
          if ("conversion" in t) {
            e.conversion = t.conversion
          }
          return e
        }
        s.forEach((t) => {
          i[t] = {}
          Object.defineProperty(i[t], "channels", { value: o[t].channels })
          Object.defineProperty(i[t], "labels", { value: o[t].labels })
          const e = r(t)
          const n = Object.keys(e)
          n.forEach((n) => {
            const o = e[n]
            i[t][n] = c(o)
            i[t][n].raw = a(o)
          })
        })
        t.exports = i
      },
      111: (t, e, n) => {
        const o = n(168)
        function r() {
          const t = {}
          const e = Object.keys(o)
          for (let n = e.length, o = 0; o < n; o++) {
            t[e[o]] = { distance: -1, parent: null }
          }
          return t
        }
        function i(t) {
          const e = r()
          const n = [t]
          e[t].distance = 0
          while (n.length) {
            const t = n.pop()
            const r = Object.keys(o[t])
            for (let o = r.length, i = 0; i < o; i++) {
              const o = r[i]
              const s = e[o]
              if (s.distance === -1) {
                s.distance = e[t].distance + 1
                s.parent = t
                n.unshift(o)
              }
            }
          }
          return e
        }
        function s(t, e) {
          return function (n) {
            return e(t(n))
          }
        }
        function a(t, e) {
          const n = [e[t].parent, t]
          let r = o[e[t].parent][t]
          let i = e[t].parent
          while (e[i].parent) {
            n.unshift(e[i].parent)
            r = s(o[e[i].parent][i], r)
            i = e[i].parent
          }
          r.conversion = n
          return r
        }
        t.exports = function (t) {
          const e = i(t)
          const n = {}
          const o = Object.keys(e)
          for (let t = o.length, r = 0; r < t; r++) {
            const t = o[r]
            const i = e[t]
            if (i.parent === null) {
              continue
            }
            n[t] = a(t, e)
          }
          return n
        }
      },
      874: (t) => {
        "use strict"
        t.exports = {
          aliceblue: [240, 248, 255],
          antiquewhite: [250, 235, 215],
          aqua: [0, 255, 255],
          aquamarine: [127, 255, 212],
          azure: [240, 255, 255],
          beige: [245, 245, 220],
          bisque: [255, 228, 196],
          black: [0, 0, 0],
          blanchedalmond: [255, 235, 205],
          blue: [0, 0, 255],
          blueviolet: [138, 43, 226],
          brown: [165, 42, 42],
          burlywood: [222, 184, 135],
          cadetblue: [95, 158, 160],
          chartreuse: [127, 255, 0],
          chocolate: [210, 105, 30],
          coral: [255, 127, 80],
          cornflowerblue: [100, 149, 237],
          cornsilk: [255, 248, 220],
          crimson: [220, 20, 60],
          cyan: [0, 255, 255],
          darkblue: [0, 0, 139],
          darkcyan: [0, 139, 139],
          darkgoldenrod: [184, 134, 11],
          darkgray: [169, 169, 169],
          darkgreen: [0, 100, 0],
          darkgrey: [169, 169, 169],
          darkkhaki: [189, 183, 107],
          darkmagenta: [139, 0, 139],
          darkolivegreen: [85, 107, 47],
          darkorange: [255, 140, 0],
          darkorchid: [153, 50, 204],
          darkred: [139, 0, 0],
          darksalmon: [233, 150, 122],
          darkseagreen: [143, 188, 143],
          darkslateblue: [72, 61, 139],
          darkslategray: [47, 79, 79],
          darkslategrey: [47, 79, 79],
          darkturquoise: [0, 206, 209],
          darkviolet: [148, 0, 211],
          deeppink: [255, 20, 147],
          deepskyblue: [0, 191, 255],
          dimgray: [105, 105, 105],
          dimgrey: [105, 105, 105],
          dodgerblue: [30, 144, 255],
          firebrick: [178, 34, 34],
          floralwhite: [255, 250, 240],
          forestgreen: [34, 139, 34],
          fuchsia: [255, 0, 255],
          gainsboro: [220, 220, 220],
          ghostwhite: [248, 248, 255],
          gold: [255, 215, 0],
          goldenrod: [218, 165, 32],
          gray: [128, 128, 128],
          green: [0, 128, 0],
          greenyellow: [173, 255, 47],
          grey: [128, 128, 128],
          honeydew: [240, 255, 240],
          hotpink: [255, 105, 180],
          indianred: [205, 92, 92],
          indigo: [75, 0, 130],
          ivory: [255, 255, 240],
          khaki: [240, 230, 140],
          lavender: [230, 230, 250],
          lavenderblush: [255, 240, 245],
          lawngreen: [124, 252, 0],
          lemonchiffon: [255, 250, 205],
          lightblue: [173, 216, 230],
          lightcoral: [240, 128, 128],
          lightcyan: [224, 255, 255],
          lightgoldenrodyellow: [250, 250, 210],
          lightgray: [211, 211, 211],
          lightgreen: [144, 238, 144],
          lightgrey: [211, 211, 211],
          lightpink: [255, 182, 193],
          lightsalmon: [255, 160, 122],
          lightseagreen: [32, 178, 170],
          lightskyblue: [135, 206, 250],
          lightslategray: [119, 136, 153],
          lightslategrey: [119, 136, 153],
          lightsteelblue: [176, 196, 222],
          lightyellow: [255, 255, 224],
          lime: [0, 255, 0],
          limegreen: [50, 205, 50],
          linen: [250, 240, 230],
          magenta: [255, 0, 255],
          maroon: [128, 0, 0],
          mediumaquamarine: [102, 205, 170],
          mediumblue: [0, 0, 205],
          mediumorchid: [186, 85, 211],
          mediumpurple: [147, 112, 219],
          mediumseagreen: [60, 179, 113],
          mediumslateblue: [123, 104, 238],
          mediumspringgreen: [0, 250, 154],
          mediumturquoise: [72, 209, 204],
          mediumvioletred: [199, 21, 133],
          midnightblue: [25, 25, 112],
          mintcream: [245, 255, 250],
          mistyrose: [255, 228, 225],
          moccasin: [255, 228, 181],
          navajowhite: [255, 222, 173],
          navy: [0, 0, 128],
          oldlace: [253, 245, 230],
          olive: [128, 128, 0],
          olivedrab: [107, 142, 35],
          orange: [255, 165, 0],
          orangered: [255, 69, 0],
          orchid: [218, 112, 214],
          palegoldenrod: [238, 232, 170],
          palegreen: [152, 251, 152],
          paleturquoise: [175, 238, 238],
          palevioletred: [219, 112, 147],
          papayawhip: [255, 239, 213],
          peachpuff: [255, 218, 185],
          peru: [205, 133, 63],
          pink: [255, 192, 203],
          plum: [221, 160, 221],
          powderblue: [176, 224, 230],
          purple: [128, 0, 128],
          rebeccapurple: [102, 51, 153],
          red: [255, 0, 0],
          rosybrown: [188, 143, 143],
          royalblue: [65, 105, 225],
          saddlebrown: [139, 69, 19],
          salmon: [250, 128, 114],
          sandybrown: [244, 164, 96],
          seagreen: [46, 139, 87],
          seashell: [255, 245, 238],
          sienna: [160, 82, 45],
          silver: [192, 192, 192],
          skyblue: [135, 206, 235],
          slateblue: [106, 90, 205],
          slategray: [112, 128, 144],
          slategrey: [112, 128, 144],
          snow: [255, 250, 250],
          springgreen: [0, 255, 127],
          steelblue: [70, 130, 180],
          tan: [210, 180, 140],
          teal: [0, 128, 128],
          thistle: [216, 191, 216],
          tomato: [255, 99, 71],
          turquoise: [64, 224, 208],
          violet: [238, 130, 238],
          wheat: [245, 222, 179],
          white: [255, 255, 255],
          whitesmoke: [245, 245, 245],
          yellow: [255, 255, 0],
          yellowgreen: [154, 205, 50],
        }
      },
      390: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}.ck.ck-clipboard-drop-target-line{pointer-events:none;position:absolute}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}.ck.ck-clipboard-drop-target-line{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);height:0;margin-top:-1px}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-clipboard/theme/clipboard.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css",
            ],
            names: [],
            mappings:
              "AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CAIF,kCAEC,mBAAoB,CADpB,iBAED,CChCA,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CAOF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD,CAGD,kCAGC,gDAAiD,CADjD,sDAAuD,CADvD,QAAS,CAGT,eACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: inline;\n\t\tposition: relative;\n\t\tpointer-events: none;\n\n\t\t& span {\n\t\t\tposition: absolute;\n\t\t\twidth: 0;\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\t& > .ck-widget__selection-handle {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t& > .ck-widget__type-around {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n.ck.ck-clipboard-drop-target-line {\n\tposition: absolute;\n\tpointer-events: none;\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-clipboard-drop-target-dot-width: 12px;\n\t--ck-clipboard-drop-target-dot-height: 8px;\n\t--ck-clipboard-drop-target-color: var(--ck-color-focus-border)\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\t& span {\n\t\t\tbottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tbackground: var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-left: -1px;\n\n\t\t\t/* The triangle above the marker */\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: 50%;\n\t\t\t\ttop: calc(var(--ck-clipboard-drop-target-dot-height) * -.5);\n\n\t\t\t\ttransform: translateX(-50%);\n\t\t\t\tborder-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;\n\t\t\t\tborder-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget that it a drop target.\n\t */\n\t& .ck-widget.ck-clipboard-drop-target-range {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\tzoom: 0.6;\n\t\toutline: none !important;\n\t}\n}\n\n.ck.ck-clipboard-drop-target-line {\n\theight: 0;\n\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\tbackground: var(--ck-clipboard-drop-target-color);\n\tmargin-top: -1px;\n}\n',
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      638: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-editor-classic/theme/classiceditor.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,uICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,yMCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,yHCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor {\n\t/* All the elements within `.ck-editor` are positioned relatively to it.\n\t If any element needs to be positioned with respect to the <body>, etc.,\n\t it must land outside of the `.ck-editor` in DOM. */\n\tposition: relative;\n\n\t& .ck-editor__top .ck-sticky-panel .ck-toolbar {\n\t\t/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */\n\t\tz-index: var(--ck-z-modal);\n\t}\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n.ck.ck-editor__top {\n\t& .ck-sticky-panel {\n\t\t& .ck-toolbar {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\n\t\t\tborder-bottom-width: 0;\n\t\t}\n\n\t\t& .ck-sticky-panel__content_sticky .ck-toolbar {\n\t\t\tborder-bottom-width: 1px;\n\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Note: Use ck-editor__main to make sure these styles don\'t apply to other editor types */\n.ck.ck-editor__main > .ck-editor__editable {\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */\n\tbackground: var(--ck-color-base-background);\n\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&:not(.ck-focused) {\n\t\tborder-color: var(--ck-color-base-border);\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      894: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css",
            ],
            names: [],
            mappings:
              "AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n\tposition: relative;\n\n\t&::before {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tcontent: attr(data-placeholder);\n\n\t\t/* See ckeditor/ckeditor5#469. */\n\t\tpointer-events: none;\n\t}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n\n/*\n * Rules for the `ck-placeholder` are loaded before the rules for `ck-reset_all` in the base CKEditor 5 DLL build.\n * This fix overwrites the incorrectly set `position: static` from `ck-reset_all`.\n * See https://github.com/ckeditor/ckeditor5/issues/11418.\n */\n.ck.ck-reset_all .ck-placeholder {\n\tposition: relative;\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n\t&::before {\n\t\tcursor: text;\n\t\tcolor: var(--ck-color-engine-placeholder-text);\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      401: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}",
          "",
          {
            version: 3,
            sources: ["webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/renderer.css"],
            names: [],
            mappings: "AAMA,qDACC,YACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Elements marked by the Renderer as hidden should be invisible in the editor. */\n.ck.ck-editor__editable span[data-ck-unsafe-element] {\n\tdisplay: none;\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      499: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;justify-content:left;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
            ],
            names: [],
            mappings:
              "AAOA,6BAMC,kBAAmB,CADnB,mBAAoB,CAEpB,oBAAqB,CAHrB,iBAAkB,CCFlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDkBD,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEjBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-unselectable;\n\n\tposition: relative;\n\tdisplay: inline-flex;\n\talign-items: center;\n\tjustify-content: left;\n\n\t& .ck-button__label {\n\t\tdisplay: none;\n\t}\n\n\t&.ck-button_with-text {\n\t\t& .ck-button__label {\n\t\t\tdisplay: inline-block;\n\t\t}\n\t}\n\n\t/* Center the icon horizontally in a button without text. */\n\t&:not(.ck-button_with-text)  {\n\t\tjustify-content: center;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../mixins/_button.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-button-colors --ck-color-button-default;\n\t@mixin ck-rounded-corners;\n\n\twhite-space: nowrap;\n\tcursor: default;\n\tvertical-align: middle;\n\tpadding: var(--ck-spacing-tiny);\n\ttext-align: center;\n\n\t/* A very important piece of styling. Go to variable declaration to learn more. */\n\tmin-width: var(--ck-ui-component-min-height);\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Normalize the height of the line. Removing this will break consistent height\n\tamong text and text-less buttons (with icons). */\n\tline-height: 1;\n\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t/* Avoid flickering when the foucs border shows up. */\n\tborder: 1px solid transparent;\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\n\t-webkit-appearance: none;\n\n\t&:active,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t/* Allow icon coloring using the text "color" property. */\n\t& .ck-button__icon {\n\t\t& use,\n\t\t& use * {\n\t\t\tcolor: inherit;\n\t\t}\n\t}\n\n\t& .ck-button__label {\n\t\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\t\tfont-size: inherit;\n\t\tfont-weight: inherit;\n\t\tcolor: inherit;\n\t\tcursor: inherit;\n\n\t\t/* Must be consistent with .ck-icon\'s vertical align. Otherwise, buttons with and\n\t\twithout labels (but with icons) have different sizes in Chrome */\n\t\tvertical-align: middle;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\t}\n\n\t& .ck-button__keystroke {\n\t\tcolor: inherit;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t}\n\n\t\tfont-weight: bold;\n\t\topacity: .7;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t&.ck-disabled {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t/* The disabled button should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t\t& .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t& .ck-button__keystroke {\n\t\t\topacity: .3;\n\t\t}\n\t}\n\n\t&.ck-button_with-text {\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-button_with-keystroke {\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__label {\n\t\t\tflex-grow: 1;\n\t\t}\n\t}\n\n\t/* A style of the button which is currently on, e.g. its feature is active. */\n\t&.ck-on {\n\t\t@mixin ck-button-colors --ck-color-button-on;\n\n\t\tcolor: var(--ck-color-button-on-color);\n\t}\n\n\t&.ck-button-save {\n\t\tcolor: var(--ck-color-button-save);\n\t}\n\n\t&.ck-button-cancel {\n\t\tcolor: var(--ck-color-button-cancel);\n\t}\n}\n\n/* A style of the button which handles the primary action. */\n.ck.ck-button-action,\na.ck.ck-button-action {\n\t@mixin ck-button-colors --ck-color-button-action;\n\n\tcolor: var(--ck-color-button-action-text);\n}\n\n.ck.ck-button-bold,\na.ck.ck-button-bold {\n\tfont-weight: bold;\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n\tbackground: var($(prefix)-background);\n\n\t&:not(.ck-disabled) {\n\t\t&:hover {\n\t\t\tbackground: var($(prefix)-hover-background);\n\t\t}\n\n\t\t&:active {\n\t\t\tbackground: var($(prefix)-active-background);\n\t\t}\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t&.ck-disabled {\n\t\tbackground: var($(prefix)-disabled-background);\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      681: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
            ],
            names: [],
            mappings:
              "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__toggle {\n\t\tdisplay: block;\n\n\t\t& .ck-button__toggle__inner {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floating–point numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n\t/* 34px at 13px font-size */\n\t--ck-switch-button-toggle-width: 2.6153846154em;\n\t/* 14px at 13px font-size */\n\t--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);\n\t--ck-switch-button-translation: calc(\n\t\tvar(--ck-switch-button-toggle-width) -\n\t\tvar(--ck-switch-button-toggle-inner-size) -\n\t\t2px /* Border */\n\t);\n\t--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n}\n\n.ck.ck-button.ck-switchbutton {\n\t/* Unlike a regular button, the switch button text color and background should never change.\n\t * Changing toggle switch (background, outline) is enough to carry the information about the\n\t * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)\n\t */\n\t&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {\n\t\tcolor: inherit;\n\t\tbackground: transparent;\n\t}\n\n\t& .ck-button__label {\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-right: calc(2 * var(--ck-spacing-large));\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-left: calc(2 * var(--ck-spacing-large));\n\t\t}\n\t}\n\n\t& .ck-button__toggle {\n\t\t@mixin ck-rounded-corners;\n\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Make sure the toggle is always to the right as far as possible. */\n\t\t\tmargin-left: auto;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Make sure the toggle is always to the left as far as possible. */\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Apply some smooth transition to the box-shadow and border. */\n\t\t/* Gently animate the background color of the toggle switch */\n\t\ttransition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;\n\t\tborder: 1px solid transparent;\n\t\twidth: var(--ck-switch-button-toggle-width);\n\t\tbackground: var(--ck-color-switch-button-off-background);\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: calc(.5 * var(--ck-border-radius));\n\t\t\t}\n\n\t\t\twidth: var(--ck-switch-button-toggle-inner-size);\n\t\t\theight: var(--ck-switch-button-toggle-inner-size);\n\t\t\tbackground: var(--ck-color-switch-button-inner-background);\n\n\t\t\t/* Gently animate the inner part of the toggle switch */\n\t\t\ttransition: all 300ms ease;\n\t\t}\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-off-hover-background);\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\tbox-shadow: var(--ck-switch-button-inner-hover-shadow);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-button__toggle {\n\t\t@mixin ck-disabled;\n\t}\n\n\t/* Overriding default .ck-button:focus styles + an outline around the toogle */\n\t&:focus {\n\t\tborder-color: transparent;\n\t\toutline: none;\n\t\tbox-shadow: none;\n\n\t\t& .ck-button__toggle {\n\t\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);\n\t\t\toutline-offset: 1px;\n\t\t\toutline: var(--ck-focus-ring);\n\t\t}\n\t}\n\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-on {\n\t\t& .ck-button__toggle {\n\t\t\tbackground: var(--ck-color-switch-button-on-background);\n\n\t\t\t&:hover {\n\t\t\t\tbackground: var(--ck-color-switch-button-on-hover-background);\n\t\t\t}\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\t/*\n\t\t\t\t* Move the toggle switch to the right. It will be animated.\n\t\t\t\t*/\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\ttransform: translateX( var( --ck-switch-button-translation ) );\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      923: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css",
            ],
            names: [],
            mappings:
              "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n\tdisplay: grid;\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-grid-tile-size: 24px;\n\n\t/* Not using global colors here because these may change but some colors in a pallette\n\t * require special treatment. For instance, this ensures no matter what the UI text color is,\n\t * the check icon will look good on the black color tile. */\n\t--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);\n}\n\n.ck.ck-color-grid {\n\tgrid-gap: 5px;\n\tpadding: 8px;\n}\n\n.ck.ck-color-grid__tile {\n\twidth: var(--ck-color-grid-tile-size);\n\theight: var(--ck-color-grid-tile-size);\n\tmin-width: var(--ck-color-grid-tile-size);\n\tmin-height: var(--ck-color-grid-tile-size);\n\tpadding: 0;\n\ttransition: .2s ease box-shadow;\n\tborder: 0;\n\n\t&.ck-disabled {\n\t\tcursor: unset;\n\t\ttransition: unset;\n\t}\n\n\t&.ck-color-table__color-tile_bordered {\n\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\tdisplay: none;\n\t\tcolor: var(--ck-color-color-grid-check-icon);\n\t}\n\n\t&.ck-on {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);\n\n\t\t& .ck.ck-icon {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t&.ck-on,\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\t/* Disable the default .ck-button\'s border ring. */\n\t\tborder: 0;\n\t}\n\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t}\n}\n\n.ck.ck-color-grid__label {\n\tpadding: 0 var(--ck-spacing-standard);\n}\n',
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      191: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".color-picker-hex-input{width:max-content}.color-picker-hex-input .ck.ck-input{min-width:unset}.ck.ck-color-picker__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-color-picker__row .ck-color-picker__hash-view{padding-right:var(--ck-spacing-medium);padding-top:var(--ck-spacing-tiny)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorpicker/colorpicker.css",
            ],
            names: [],
            mappings:
              "AAKA,wBACC,iBAKD,CAHC,qCACC,eACD,CAGD,yBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAMD,CAJC,qDAEC,sCAAuC,CADvC,kCAED",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.color-picker-hex-input {\n\twidth: max-content;\n\n\t& .ck.ck-input {\n\t\tmin-width: unset;\n\t}\n}\n\n.ck.ck-color-picker__row {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\tjustify-content: space-between;\n\n\t& .ck-color-picker__hash-view {\n\t\tpadding-top: var(--ck-spacing-tiny);\n\t\tpadding-right: var(--ck-spacing-medium);\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      488: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eH8GD,CA5BA,qFG9EE,qCH0GF,CA5BA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-dropdown-max-width: 75vw;\n}\n\n.ck.ck-dropdown {\n\tdisplay: inline-block;\n\tposition: relative;\n\n\t& .ck-dropdown__arrow {\n\t\tpointer-events: none;\n\t\tz-index: var(--ck-z-default);\n\t}\n\n\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n\t& .ck-button.ck-dropdown__button {\n\t\twidth: 100%;\n\t}\n\n\t& .ck-dropdown__panel {\n\t\tdisplay: none;\n\t\tz-index: var(--ck-z-modal);\n\t\tmax-width: var(--ck-dropdown-max-width);\n\n\t\tposition: absolute;\n\n\t\t&.ck-dropdown__panel-visible {\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_n,\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_nme {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-dropdown__panel_se,\n\t\t&.ck-dropdown__panel_sw,\n\t\t&.ck-dropdown__panel_smw,\n\t\t&.ck-dropdown__panel_sme,\n\t\t&.ck-dropdown__panel_s {\n\t\t\t/*\n\t\t\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n\t\t\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\n\t\t\t */\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_se {\n\t\t\tleft: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\tright: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_s,\n\t\t&.ck-dropdown__panel_n {\n\t\t\t/* Positioning panels relative to the center of the button */\n\t\t\tleft: 50%;\n\t\t\ttransform: translateX(-50%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_smw {\n\t\t\t/* Positioning panels relative to the middle-west of the button */\n\t\t\tleft: 75%;\n\t\t\ttransform: translateX(-75%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nme,\n\t\t&.ck-dropdown__panel_sme {\n\t\t\t/* Positioning panels relative to the middle-east of the button */\n\t\t\tleft: 25%;\n\t\t\ttransform: translateX(-25%);\n\t\t}\n\t}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n\tz-index: calc( var(--ck-z-modal) + 1 );\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-dropdown {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-dropdown__arrow {\n\t\twidth: var(--ck-dropdown-arrow-size);\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-dropdown__arrow {\n\t\t\tright: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-dropdown__arrow {\n\t\t\tleft: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-dropdown__arrow {\n\t\t@mixin ck-disabled;\n\t}\n\n\t& .ck-button.ck-dropdown__button {\n\t\t@mixin ck-dir ltr {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-right: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t/* #23 */\n\t\t& .ck-button__label {\n\t\t\twidth: 7em;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t\t&.ck-disabled .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\n\t\t&.ck-on {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t&.ck-dropdown__button_label-width_auto .ck-button__label {\n\t\t\twidth: auto;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/8699 */\n\t\t&.ck-off:active,\n\t\t&.ck-on:active {\n\t\t\tbox-shadow: none;\n\t\t\t\n\t\t\t&:focus {\n\t\t\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-dropdown__panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tbackground: var(--ck-color-dropdown-panel-background);\n\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\tbottom: 0;\n\n\t/* Make sure the panel is at least as wide as the drop-down\'s button. */\n\tmin-width: 100%;\n\n\t/* Disabled corner border radius to be consistent with the .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-dropdown__panel_se {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_sw {\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_ne {\n\t\tborder-bottom-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_nw {\n\t\tborder-bottom-right-radius: 0;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      875: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n\t/* Disabled radius of top-left border to be consistent with .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t/* Make sure the button belonging to the first/last child of the list goes well with the\n\tborder radius of the entire panel. */\n\t& .ck-list__item {\n\t\t&:first-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\n\t\t&:last-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      66: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-splitbutton {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-splitbutton__action:focus {\n\t\tz-index: calc(var(--ck-z-default) + 1);\n\t}\n}\n\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-split-button-hover-background: hsl(0, 0%, 92%);\n\t--ck-color-split-button-hover-border: hsl(0, 0%, 70%);\n}\n\n.ck.ck-splitbutton {\n\t/*\n\t * Note: ck-rounded and ck-dir mixins don\'t go together (because they both use @nest).\n\t */\n\t&:hover > .ck-splitbutton__action,\n\t&.ck-splitbutton_open > .ck-splitbutton__action {\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the action button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the action button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\t}\n\n\t& > .ck-splitbutton__arrow {\n\t\t/* It\'s a text-less button and since the icon is positioned absolutely in such situation,\n\t\tit must get some arbitrary min-width. */\n\t\tmin-width: unset;\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the arrow button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the arrow button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t& svg {\n\t\t\twidth: var(--ck-dropdown-arrow-size);\n\t\t}\n\t}\n\n\t/* Make sure the divider stretches 100% height of the button\n\thttps://github.com/ckeditor/ckeditor5/issues/10936 */\n\t& > .ck-splitbutton__arrow:not(:focus) {\n\t\tborder-top-width: 0px;\n\t\tborder-bottom-width: 0px;\n\t}\n\n\t/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling\n\tas a whole. The background of both buttons should stand out and there should be a visual\n\tseparation between both buttons. */\n\t&.ck-splitbutton_open,\n\t&:hover {\n\t\t/* When the split button hovered as a whole, not as individual buttons. */\n\t\t& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {\n\t\t\tbackground: var(--ck-color-split-button-hover-background);\n\t\t}\n\n\t\t/* Splitbutton separator needs to be set with the ::after pseudoselector\n\t\tto display properly the borders on focus */\n\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\tcontent: \'\';\n\t\t\tposition: absolute;\n\t\t\twidth: 1px;\n\t\t\theight: 100%;\n\t\t\tbackground-color: var(--ck-color-split-button-hover-border);\n\t\t}\n\n\t\t/* Make sure the divider between the buttons looks fine when the button is focused */\n\t\t& > .ck-splitbutton__arrow:focus::after {\n\t\t\t--ck-color-split-button-hover-border: var(--ck-color-focus-border);\n\t\t}\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tleft: -1px;\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tright: -1px;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Don\'t round the bottom left and right corners of the buttons when "open"\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-splitbutton_open {\n\t\t@mixin ck-rounded-corners {\n\t\t\t& > .ck-splitbutton__action {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t}\n\n\t\t\t& > .ck-splitbutton__arrow {\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      75: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\n\t/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n\twidth: max-content;\n\tmax-width: var(--ck-toolbar-dropdown-max-width);\n\n\t& .ck-button {\n\t\t&:focus {\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n\tborder: 0;\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      547: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n\t@mixin ck-rounded-corners;\n\n\t&.ck-focused {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n\n.ck.ck-editor__editable_inline {\n\toverflow: auto;\n\tpadding: 0 var(--ck-spacing-standard);\n\tborder: 1px solid transparent;\n\n\t&[dir="ltr"] {\n\t\ttext-align: left;\n\t}\n\n\t&[dir="rtl"] {\n\t\ttext-align: right;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n\t& > *:first-child {\n\t\tmargin-top: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\n\t& > *:last-child {\n\t\t/*\n\t\t * This value should match with the default margins of the block elements (like .media or .image)\n\t\t * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).\n\t\t */\n\t\tmargin-bottom: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n\t&.ck-blurred ::selection {\n\t\tbackground: var(--ck-color-editable-blur-selection);\n\t}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n\t&::after {\n\t\tborder-bottom-color: var(--ck-color-base-foreground);\n\t}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n\t&::after {\n\t\tborder-top-color: var(--ck-color-base-foreground);\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      523: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-form__header .ck-form__header__label{font-weight:700}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/formheader/formheader.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css",
            ],
            names: [],
            mappings:
              "AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BACD,CCNA,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAQD,CAHC,4CACC,eACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\talign-items: center;\n\tjustify-content: space-between;\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\theight: var(--ck-form-header-height);\n\tline-height: var(--ck-form-header-height);\n\tborder-bottom: 1px solid var(--ck-color-base-border);\n\n\t& .ck-form__header__label {\n\t\tfont-weight: bold;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      174: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css",
            ],
            names: [],
            mappings:
              "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n\tvertical-align: middle;\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n\twidth: var(--ck-icon-size);\n\theight: var(--ck-icon-size);\n\n\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n\tfont-size: .8333350694em;\n\n\t/* Inherit cursor style (#5). */\n\tcursor: inherit;\n\n\t/* This will prevent blurry icons on Firefox. See #340. */\n\twill-change: transform;\n\n\t& * {\n\t\t/* Inherit cursor style (#5). */\n\t\tcursor: inherit;\n\t}\n\n\t/* Allows dynamic coloring of an icon by inheriting its color from the parent. */\n\t&.ck-icon_inherit-color {\n\t\tcolor: inherit;\n\n\t\t& * {\n\t\t\tcolor: inherit;\n\n\t\t\t&:not([fill]) {\n\t\t\t\t/* Needed by FF. */\n\t\t\t\tfill: currentColor;\n\t\t\t}\n\t\t}\n\t}\n}\n',
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      985: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-input-width: 18em;\n\n\t/* Backward compatibility. */\n\t--ck-input-text-width: var(--ck-input-width);\n}\n\n.ck.ck-input {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-input-background);\n\tborder: 1px solid var(--ck-color-input-border);\n\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n\tmin-width: var(--ck-input-width);\n\n\t/* This is important to stay of the same height as surrounding buttons */\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t&[readonly] {\n\t\tborder: 1px solid var(--ck-color-input-disabled-border);\n\t\tbackground: var(--ck-color-input-disabled-background);\n\t\tcolor: var(--ck-color-input-disabled-text);\n\n\t\t&:focus {\n\t\t\t/* The read-only input should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\tborder-color: var(--ck-color-input-error-border);\n\t\tanimation: ck-input-shake .3s ease both;\n\n\t\t&:focus {\n\t\t\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n\t\t}\n\t}\n}\n\n@keyframes ck-input-shake {\n\t20% {\n\t\ttransform: translateX(-2px);\n\t}\n\n\t40% {\n\t\ttransform: translateX(2px);\n\t}\n\n\t60% {\n\t\ttransform: translateX(-1px);\n\t}\n\n\t80% {\n\t\ttransform: translateX(1px);\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      751: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css",
            ],
            names: [],
            mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tdisplay: block;\n}\n\n.ck.ck-voice-label {\n\tdisplay: none;\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tfont-weight: bold;\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      957: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD8GD,CAzGA,2FCDE,qCD0GF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAiBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAP9C,mBAAoB,CAYpB,sBAAuB,CARvB,6DAA+D,CAH/D,oBAAqB,CAgBrB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,+HAYF,CAfA,oUAOE,wIAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\tdisplay: flex;\n\t\tposition: relative;\n\t}\n\n\t& .ck.ck-label {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t}\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);\n\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));\n\t--ck-color-labeled-field-label-background: var(--ck-color-base-background);\n}\n\n.ck.ck-labeled-field-view {\n\t@mixin ck-rounded-corners;\n\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\twidth: 100%;\n\n\t\t& > .ck.ck-label {\n\t\t\ttop: 0px;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tleft: 0px;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tright: 0px;\n\t\t\t}\n\n\t\t\tpointer-events: none;\n\t\t\ttransform-origin: 0 0;\n\n\t\t\t/* By default, display the label scaled down above the field. */\n\t\t\ttransform: translate(var(--ck-spacing-medium), -6px) scale(.75);\n\n\t\t\tbackground: var(--ck-color-labeled-field-label-background);\n\t\t\tpadding: 0 calc(.5 * var(--ck-font-size-tiny));\n\t\t\tline-height: initial;\n\t\t\tfont-weight: normal;\n\n\t\t\t/* Prevent overflow when the label is longer than the input */\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\n\t\t\tmax-width: 100%;\n\n\t\t\ttransition:\n\t\t\t\ttransform var(--ck-labeled-field-view-transition),\n\t\t\t\tpadding var(--ck-labeled-field-view-transition),\n\t\t\t\tbackground var(--ck-labeled-field-view-transition);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\t& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\n\t\t& .ck-input:not([readonly]) + .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t& .ck-labeled-field-view__status {\n\t\tfont-size: var(--ck-font-size-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\n\t\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\n\t\tThe status could be very long. */\n\t\twhite-space: normal;\n\n\t\t&.ck-labeled-field-view__status_error {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t/* Disabled fields and fields that have no focus should fade out. */\n\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\tcolor: var(--ck-color-input-disabled-text);\n\t}\n\n\t/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t@mixin ck-dir ltr {\n\t\t\ttransform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttransform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t/* Compensate for the default translate position. */\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));\n\n\t\tbackground: transparent;\n\t\tpadding: 0;\n\t}\n\n\t/*------ DropdownView integration ----------------------------------------------------------------------------------- */\n\n\t/* Make sure dropdown\' background color in any of dropdown\'s state does not collide with labeled field. */\n\t& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {\n\t\tbackground: transparent;\n\t}\n\n\t/* When the dropdown is "empty", the labeled field label replaces its label. */\n\t&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {\n\t\topacity: 0;\n\t}\n\n\t/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      162: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base));text-align:left;width:100%}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BAIC,eAAgB,CAHhB,gBAAiB,CAQjB,iIAEiE,CARjE,eAAgB,CADhB,UAwCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-direction: column;\n\n\t& .ck-list__item,\n\t& .ck-list__separator {\n\t\tdisplay: block;\n\t}\n\n\t/* Make sure that whatever child of the list item gets focus, it remains on the\n\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n\tadjacent list items. */\n\t& .ck-list__item > *:focus {\n\t\tposition: relative;\n\t\tz-index: var(--ck-z-default);\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-list {\n\t@mixin ck-rounded-corners;\n\n\tlist-style-type: none;\n\tbackground: var(--ck-color-list-background);\n}\n\n.ck.ck-list__item {\n\tcursor: default;\n\tmin-width: 12em;\n\n\t& .ck-button {\n\t\tmin-height: unset;\n\t\twidth: 100%;\n\t\ttext-align: left;\n\t\tborder-radius: 0;\n\n\t\t/* List items should have the same height. Use absolute units to make sure it is so\n\t\t   because e.g. different heading styles may have different height\n\t\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\tpadding:\n\t\t\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\n\t\t\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\n\t\t& .ck-button__label {\n\t\t\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\t\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-button-on-background);\n\t\t\tcolor: var(--ck-color-list-button-on-text);\n\n\t\t\t&:active {\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-on-background-focus);\n\t\t\t}\n\n\t\t\t&:focus:not(.ck-switchbutton):not(.ck-disabled) {\n\t\t\t\tborder-color: var(--ck-color-base-background);\n\t\t\t}\n\t\t}\n\n\t\t&:hover:not(.ck-disabled) {\n\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t}\n\t}\n\n\t/* It\'s unnecessary to change the background/text of a switch toggle; it has different ways\n\tof conveying its state (like the switcher) */\n\t& .ck-switchbutton {\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-background);\n\t\t\tcolor: inherit;\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t\t\tcolor: inherit;\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-list__separator {\n\theight: 1px;\n\twidth: 100%;\n\tbackground: var(--ck-color-base-border);\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      245: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Make sure the balloon arrow does not float over its children. */\n\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n\tdisplay: none;\n\tposition: absolute;\n\n\tz-index: var(--ck-z-modal);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tposition: absolute;\n\t\t}\n\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_visible {\n\t\tdisplay: block;\n\t}\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-border-width: 1px;\n\t--ck-balloon-arrow-offset: 2px;\n\t--ck-balloon-arrow-height: 10px;\n\t--ck-balloon-arrow-half-width: 8px;\n\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder-style: solid;\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\n\t\t\tmargin-top: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\n\t\t\tmargin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: var(--ck-color-panel-border) transparent transparent;\n\t\t\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n\t\t\tmargin-bottom: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\n\t\t\tmargin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_e"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-border);\n\t\t\tmargin-right: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-background);\n\t\t\tmargin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_w"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent var(--ck-color-panel-border) transparent transparent;\n\t\t\tmargin-left: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent var(--ck-color-panel-background) transparent transparent;\n\t\t\tmargin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_n {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_ne {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_s {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_se {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_smw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nmw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_e {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_w {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      757: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css",
            ],
            names: [],
            mappings:
              "AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n\tjustify-content: center;\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tbackground: var(--ck-color-toolbar-background);\n\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\n\tpadding: 0 var(--ck-spacing-small);\n\n\t/* Let's keep similar appearance to `ck-toolbar`. */\n\t& > * {\n\t\tmargin-right: var(--ck-spacing-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t/* Gives counter more breath than buttons. */\n\t& .ck-balloon-rotator__counter {\n\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t/* We need to use smaller margin because of previous button's right margin. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n.ck .ck-balloon-rotator__content {\n\n\t/* Disable default annotation shadow inside rotator with fake panels. */\n\t& .ck.ck-annotation-wrapper {\n\t\tbox-shadow: none;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      553: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n\tposition: absolute;\n\n\t/* Fake panels should be placed under main balloon content. */\n\tz-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n\tposition: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tz-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tz-index: 1;\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-fake-panel-offset-horizontal: 6px;\n\t--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\tborder-radius: var(--ck-border-radius);\n\n\twidth: 100%;\n\theight: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n\t--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      609: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\tz-index: var(--ck-z-modal); /* #315 */\n\t\tposition: fixed;\n\t\ttop: 0;\n\t}\n\n\t& .ck-sticky-panel__content_sticky_bottom-limit {\n\t\ttop: auto;\n\t\tposition: absolute;\n\t}\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\t@mixin ck-drop-shadow;\n\n\t\tborder-width: 0 1px 1px;\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      706: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/blocktoolbar.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css",
            ],
            names: [],
            mappings:
              "AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-block-toolbar-button {\n\tposition: absolute;\n\tz-index: var(--ck-z-default);\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-block-toolbar-button: var(--ck-color-text);\n\t--ck-block-toolbar-button-size: var(--ck-font-size-normal);\n}\n\n.ck.ck-block-toolbar-button {\n\tcolor: var(--ck-color-block-toolbar-button);\n\tfont-size: var(--ck-block-toolbar-size);\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      571: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck.ck-toolbar:focus{outline:none}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            ],
            names: [],
            mappings:
              "AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDwGD,CA3GA,qECOE,qCDoGF,CA3GA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAuGD,CApGC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAGD,qBACC,YACD,CAtGD,qCAyGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-flow: row nowrap;\n\talign-items: center;\n\n\t& > .ck-toolbar__items {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\talign-items: center;\n\t\tflex-grow: 1;\n\n\t}\n\n\t& .ck.ck-toolbar__separator {\n\t\tdisplay: inline-block;\n\n\t\t/*\n\t\t * A leading or trailing separator makes no sense (separates from nothing on one side).\n\t\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n\t\t * moved to another toolbar in the dropdown.\n\t\t */\n\t\t&:first-child,\n\t\t&:last-child {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\tflex-basis: 100%;\n\t}\n\n\t&.ck-toolbar_grouping > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t&.ck-toolbar_vertical > .ck-toolbar__items {\n\t\tflex-direction: column;\n\t}\n\n\t&.ck-toolbar_floating > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t& > .ck-dropdown__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-toolbar-background);\n\tpadding: 0 var(--ck-spacing-small);\n\tborder: 1px solid var(--ck-color-toolbar-border);\n\n\t& .ck.ck-toolbar__separator {\n\t\talign-self: stretch;\n\t\twidth: 1px;\n\t\tmin-width: 1px;\n\t\tbackground: var(--ck-color-toolbar-border);\n\n\t\t/*\n\t\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\n\t\t */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\theight: 0;\n\t}\n\n\t& > .ck-toolbar__items {\n\t\t& > *:not(.ck-toolbar__line-break) {\n\t\t\t/* (#11) Separate toolbar items. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\n\t\t/* Don\'t display a separator after an empty items container, for instance,\n\t\twhen all items were grouped */\n\t\t&:empty + .ck.ck-toolbar__separator {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t&.ck-toolbar_vertical {\n\t\t/* Items in a vertical toolbar span the entire width. */\n\t\tpadding: 0;\n\n\t\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\n\t\t& > .ck-toolbar__items > .ck {\n\t\t\t/* Items in a vertical toolbar should span the horizontal space. */\n\t\t\twidth: 100%;\n\n\t\t\t/* Items in a vertical toolbar should have no margin. */\n\t\t\tmargin: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\n\t\t\tborder-radius: 0;\n\t\t}\n\t}\n\n\t&.ck-toolbar_compact {\n\t\t/* No spacing around items. */\n\t\tpadding: 0;\n\n\t\t& > .ck-toolbar__items > * {\n\t\t\t/* Compact toolbar items have no spacing between them. */\n\t\t\tmargin: 0;\n\n\t\t\t/* "Middle" children should have no rounded corners. */\n\t\t\t&:not(:first-child):not(:last-child) {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/*\n\t\t * Dropdown button has asymmetric padding to fit the arrow.\n\t\t * This button has no arrow so let\'s revert that padding back to normal.\n\t\t */\n\t\t& > .ck.ck-button.ck-dropdown__button {\n\t\t\tpadding-left: var(--ck-spacing-tiny);\n\t\t}\n\t}\n\n\t/* A drop-down containing the nested toolbar with configured items. */\n\t& .ck-toolbar__nested-toolbar-dropdown {\n\t\t/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */\n\t\t& > .ck-dropdown__panel {\n\t\t\tmin-width: auto;\n\t\t}\n\n\t\t& > .ck-button > .ck-button__label {\n\t\t\tmax-width: 7em;\n\t\t\twidth: auto;\n\t\t}\n\t}\n\n\t&:focus {\n\t\toutline: none;\n\t}\n\n\t@nest .ck-toolbar-container & {\n\t\tborder: 0;\n\t}\n}\n\n/* stylelint-disable */\n\n/*\n * Styles for RTL toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="rtl"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="rtl"] {\n\t& > .ck-toolbar__items > .ck {\n\t\tmargin-right: 0;\n\t}\n\n\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\n\t\t/* (#11) Separate toolbar items. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-left: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n/*\n * Styles for LTR toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="ltr"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="ltr"] {\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-right: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n}\n\n/* stylelint-enable */\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      948: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css",
            ],
            names: [],
            mappings:
              "AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDPnC,mBAAoB,CAEpB,qCACD,CCMC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAbD,gCAgBC,eAMD,CAHC,uCACC,YACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t/* Keep tooltips transparent for any interactions. */\n\tpointer-events: none;\n\n\tz-index: calc( var(--ck-z-modal) + 100 );\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t--ck-balloon-border-width: 0px;\n\t--ck-balloon-arrow-offset: 0px;\n\t--ck-balloon-arrow-half-width: 4px;\n\t--ck-balloon-arrow-height: 4px;\n\t--ck-color-panel-background: var(--ck-color-tooltip-background);\n\n\tpadding: 0 var(--ck-spacing-medium);\n\n\t& .ck-tooltip__text {\n\t\tfont-size: .9em;\n\t\tline-height: 1.5;\n\t\tcolor: var(--ck-color-tooltip-text);\n\t}\n\n\t/* Reset balloon panel styles */\n\tbox-shadow: none;\n\n\t/* Hide the default shadow of the .ck-balloon-panel tip */\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n',
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      150: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-powered-by-line-height:10px;--ck-powered-by-padding-vertical:2px;--ck-powered-by-padding-horizontal:4px;--ck-powered-by-text-color:#4f4f4f;--ck-powered-by-border-radius:var(--ck-border-radius);--ck-powered-by-background:#fff;--ck-powered-by-border-color:var(--ck-color-focus-border)}.ck.ck-balloon-panel.ck-powered-by-balloon{--ck-border-radius:var(--ck-powered-by-border-radius);background:var(--ck-powered-by-background);box-shadow:none;min-height:unset;z-index:calc(var(--ck-z-modal) - 1)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by{line-height:var(--ck-powered-by-line-height)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by a{align-items:center;cursor:pointer;display:flex;filter:grayscale(80%);line-height:var(--ck-powered-by-line-height);opacity:.66;padding:var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-powered-by__label{color:var(--ck-powered-by-text-color);cursor:pointer;font-size:7.5px;font-weight:700;letter-spacing:-.2px;line-height:normal;margin-right:4px;padding-left:2px;text-transform:uppercase}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-icon{cursor:pointer;display:block}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by:hover a{filter:grayscale(0);opacity:1}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_inside]{border-color:transparent}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_border]{border:var(--ck-focus-ring);border-color:var(--ck-powered-by-border-color)}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_hidden.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_reset.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_zindex.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_transition.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_poweredby.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css",
            ],
            names: [],
            mappings:
              "AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,gCAAiC,CACjC,oCAAqC,CACrC,sCAAuC,CACvC,kCAA2C,CAC3C,qDAAsD,CACtD,+BAA4C,CAC5C,yDACD,CAEA,2CACC,qDAAsD,CAGtD,0CAA2C,CAD3C,eAAgB,CAEhB,gBAAiB,CACjB,mCAiDD,CA/CC,6DACC,4CAoCD,CAlCC,+DAGC,kBAAmB,CAFnB,cAAe,CACf,YAAa,CAGb,qBAAsB,CACtB,4CAA6C,CAF7C,WAAY,CAGZ,qFACD,CAEA,mFASC,qCAAsC,CAFtC,cAAe,CANf,eAAgB,CAIhB,eAAiB,CAHjB,oBAAqB,CAMrB,kBAAmB,CAFnB,gBAAiB,CAHjB,gBAAiB,CACjB,wBAOD,CAEA,sEAEC,cAAe,CADf,aAED,CAGC,qEACC,mBAAqB,CACrB,SACD,CAIF,mEACC,wBACD,CAEA,mEACC,2BAA4B,CAC5B,8CACD,CChED,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAwD,CCvGxD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJuGD,CIjGA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n\t/* Override selector specificity. Otherwise, all elements with some display\n\tstyle defined will override this one, which is not a desired result. */\n\tdisplay: none !important;\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\tbox-sizing: border-box;\n\twidth: auto;\n\theight: auto;\n\tposition: static;\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-z-default: 1;\n\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n\ttransition: none !important;\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-powered-by-line-height: 10px;\n\t--ck-powered-by-padding-vertical: 2px;\n\t--ck-powered-by-padding-horizontal: 4px;\n\t--ck-powered-by-text-color: hsl(0, 0%, 31%);\n\t--ck-powered-by-border-radius: var(--ck-border-radius);\n\t--ck-powered-by-background: hsl(0, 0%, 100%);\n\t--ck-powered-by-border-color: var(--ck-color-focus-border);\n}\n\n.ck.ck-balloon-panel.ck-powered-by-balloon {\n\t--ck-border-radius: var(--ck-powered-by-border-radius);\n\n\tbox-shadow: none;\n\tbackground: var(--ck-powered-by-background);\n\tmin-height: unset;\n\tz-index: calc( var(--ck-z-modal) - 1 );\n\n\t& .ck.ck-powered-by {\n\t\tline-height: var(--ck-powered-by-line-height);\n\n\t\t& a {\n\t\t\tcursor: pointer;\n\t\t\tdisplay: flex;\n\t\t\talign-items: center;\n\t\t\topacity: .66;\n\t\t\tfilter: grayscale(80%);\n\t\t\tline-height: var(--ck-powered-by-line-height);\n\t\t\tpadding: var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal);\n\t\t}\n\n\t\t& .ck-powered-by__label {\n\t\t\tfont-size: 7.5px;\n\t\t\tletter-spacing: -.2px;\n\t\t\tpadding-left: 2px;\n\t\t\ttext-transform: uppercase;\n\t\t\tfont-weight: bold;\n\t\t\tmargin-right: 4px;\n\t\t\tcursor: pointer;\n\t\t\tline-height: normal;\n\t\t\tcolor: var(--ck-powered-by-text-color);\n\n\t\t}\n\n\t\t& .ck-icon {\n\t\t\tdisplay: block;\n\t\t\tcursor: pointer;\n\t\t}\n\n\t\t&:hover {\n\t\t\t& a {\n\t\t\t\tfilter: grayscale(0%);\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[class*="position_inside"] {\n\t\tborder-color: transparent;\n\t}\n\n\t&[class*="position_border"] {\n\t\tborder: var(--ck-focus-ring);\n\t\tborder-color: var(--ck-powered-by-border-color);\n\t}\n}\n\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-base-foreground: \t\t\t\t\t\t\t\thsl(0, 0%, 98%);\n\t--ck-color-base-background: \t\t\t\t\t\t\t\thsl(0, 0%, 100%);\n\t--ck-color-base-border: \t\t\t\t\t\t\t\t\thsl(220, 6%, 81%);\n\t--ck-color-base-action: \t\t\t\t\t\t\t\t\thsl(104, 50.2%, 42.5%);\n\t--ck-color-base-focus: \t\t\t\t\t\t\t\t\t\thsl(209, 92%, 70%);\n\t--ck-color-base-text: \t\t\t\t\t\t\t\t\t\thsl(0, 0%, 20%);\n\t--ck-color-base-active: \t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\t--ck-color-base-active-focus:\t\t\t\t\t\t\t\thsl(218.2, 100%, 52.5%);\n\t--ck-color-base-error:\t\t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------ */\n\n\t--ck-color-focus-border-coordinates: \t\t\t\t\t\t218, 81.8%, 56.9%;\n\t--ck-color-focus-border: \t\t\t\t\t\t\t\t\thsl(var(--ck-color-focus-border-coordinates));\n\t--ck-color-focus-outer-shadow:\t\t\t\t\t\t\t\thsl(212.4, 89.3%, 89%);\n\t--ck-color-focus-disabled-shadow:\t\t\t\t\t\t\thsla(209, 90%, 72%,.3);\n\t--ck-color-focus-error-shadow:\t\t\t\t\t\t\t\thsla(9,100%,56%,.3);\n\t--ck-color-text: \t\t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-shadow-drop: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.15);\n\t--ck-color-shadow-drop-active:\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.2);\n\t--ck-color-shadow-inner: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Buttons ------------------------------------------------------------------------------- */\n\n\t--ck-color-button-default-background: \t\t\t\t\t\ttransparent;\n\t--ck-color-button-default-hover-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-active-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-disabled-background: \t\t\t\ttransparent;\n\n\t--ck-color-button-on-background: \t\t\t\t\t\t\thsl(212, 100%, 97.1%);\n\t--ck-color-button-on-hover-background: \t\t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-active-background: \t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-disabled-background: \t\t\t\t\thsl(211, 15%, 95%);\n\t--ck-color-button-on-color:\t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\n\n\t--ck-color-button-action-background: \t\t\t\t\t\tvar(--ck-color-base-action);\n\t--ck-color-button-action-hover-background: \t\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-active-background: \t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-disabled-background: \t\t\t\thsl(104, 44%, 58%);\n\t--ck-color-button-action-text: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t--ck-color-button-save: \t\t\t\t\t\t\t\t\thsl(120, 100%, 27%);\n\t--ck-color-button-cancel: \t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t--ck-color-switch-button-off-background:\t\t\t\t\thsl(0, 0%, 57.6%);\n\t--ck-color-switch-button-off-hover-background:\t\t\t\thsl(0, 0%, 49%);\n\t--ck-color-switch-button-on-background:\t\t\t\t\t\tvar(--ck-color-button-action-background);\n\t--ck-color-switch-button-on-hover-background:\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-switch-button-inner-background:\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-switch-button-inner-shadow:\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Dropdown ------------------------------------------------------------------------------ */\n\n\t--ck-color-dropdown-panel-background: \t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-dropdown-panel-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Input --------------------------------------------------------------------------------- */\n\n\t--ck-color-input-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-input-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-error-border:\t\t\t\t\t\t\t\tvar(--ck-color-base-error);\n\t--ck-color-input-text: \t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-input-disabled-background: \t\t\t\t\t\thsl(0, 0%, 95%);\n\t--ck-color-input-disabled-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-disabled-text: \t\t\t\t\t\t\thsl(0, 0%, 46%);\n\n\t/* -- List ---------------------------------------------------------------------------------- */\n\n\t--ck-color-list-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-list-button-hover-background: \t\t\t\t\tvar(--ck-color-button-default-hover-background);\n\t--ck-color-list-button-on-background: \t\t\t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-background-focus: \t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-text:\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Panel --------------------------------------------------------------------------------- */\n\n\t--ck-color-panel-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-panel-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Toolbar ------------------------------------------------------------------------------- */\n\n\t--ck-color-toolbar-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-toolbar-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Tooltip ------------------------------------------------------------------------------- */\n\n\t--ck-color-tooltip-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-tooltip-text: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Engine -------------------------------------------------------------------------------- */\n\n\t--ck-color-engine-placeholder-text: \t\t\t\t\t\thsl(0, 0%, 44%);\n\n\t/* -- Upload -------------------------------------------------------------------------------- */\n\n\t--ck-color-upload-bar-background:\t\t \t\t\t\t\thsl(209, 92%, 70%);\n\n\t/* -- Link -------------------------------------------------------------------------------- */\n\n\t--ck-color-link-default:\t\t\t\t\t\t\t\t\thsl(240, 100%, 47%);\n\t--ck-color-link-selected-background:\t\t\t\t\t\thsla(201, 100%, 56%, 0.1);\n\t--ck-color-link-fake-selection:\t\t\t\t\t\t\t\thsla(201, 100%, 56%, 0.3);\n\n\t/* -- Search result highlight ---------------------------------------------------------------- */\n\n\t--ck-color-highlight-background:\t\t\t\t\t\t\thsl(60, 100%, 50%)\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * An opacity value of disabled UI item.\n\t */\n\t--ck-disabled-opacity: .5;\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * The geometry of the of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n\t/**\n\t * A visual style of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when disabled).\n\t */\n\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when has errors).\n\t */\n\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n\t/**\n\t * A visual style of focused element's border or outline.\n\t */\n\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-font-size-base: 13px;\n\t--ck-line-height-base: 1.84615;\n\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n\t--ck-font-size-tiny: 0.7em;\n\t--ck-font-size-small: 0.75em;\n\t--ck-font-size-normal: 1em;\n\t--ck-font-size-big: 1.4em;\n\t--ck-font-size-large: 1.8em;\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* This is super-important. This is **manually** adjusted so a button without an icon\n\tis never smaller than a button with icon, additionally making sure that text-less buttons\n\tare perfect squares. The value is also shared by other components which should stay "in-line"\n\twith buttons. */\n\t--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* Do not include inheritable rules here. */\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: transparent;\n\ttext-decoration: none;\n\tvertical-align: middle;\n\ttransition: none;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n\tword-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* These are rule inherited by all children elements. */\n\tborder-collapse: collapse;\n\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n\tcolor: var(--ck-color-text);\n\ttext-align: left;\n\twhite-space: nowrap;\n\tcursor: auto;\n\tfloat: none;\n}\n\n.ck-reset_all {\n\t& .ck-rtl *:not(.ck-reset_all-excluded *) {\n\t\ttext-align: right;\n\t}\n\n\t& iframe:not(.ck-reset_all-excluded *) {\n\t\t/* For IE */\n\t\tvertical-align: inherit;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *) {\n\t\twhite-space: pre-wrap;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *),\n\t& input[type="text"]:not(.ck-reset_all-excluded *),\n\t& input[type="password"]:not(.ck-reset_all-excluded *) {\n\t\tcursor: text;\n\t}\n\n\t& textarea[disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="text"][disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {\n\t\tcursor: default;\n\t}\n\n\t& fieldset:not(.ck-reset_all-excluded *) {\n\t\tpadding: 10px;\n\t\tborder: 2px groove hsl(255, 7%, 88%);\n\t}\n\n\t& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {\n\t\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n\t\tpadding: 0;\n\t\tborder: 0\n\t}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n\ttext-align: right;\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n\t--ck-border-radius: 2px;\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * A visual style of element's inner shadow (i.e. input).\n\t */\n\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n\t/**\n\t * A visual style of element's drop shadow (i.e. panel).\n\t */\n\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n\t/**\n\t * A visual style of element's active shadow (i.e. comment or suggestion).\n\t */\n\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-spacing-unit: \t\t\t\t\t\t0.6em;\n\t--ck-spacing-large: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 1.5);\n\t--ck-spacing-standard: \t\t\t\t\tvar(--ck-spacing-unit);\n\t--ck-spacing-medium: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.8);\n\t--ck-spacing-small: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.5);\n\t--ck-spacing-tiny: \t\t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.3);\n\t--ck-spacing-extra-tiny: \t\t\t\tcalc(var(--ck-spacing-unit) * 0.16);\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      507: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widget.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            ],
            names: [],
            mappings:
              "AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-resizer: var(--ck-color-focus-border);\n\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n\n\t--ck-resizer-border-radius: var(--ck-border-radius);\n\t--ck-resizer-tooltip-offset: 10px;\n\t--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);\n}\n\n.ck .ck-widget {\n\t/* This is neccessary for type around UI to be positioned properly. */\n\tposition: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n\n\t& .ck-widget__selection-handle {\n\t\tposition: absolute;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the icon in not a subject to font-size or line-height to avoid\n\t\t\tunnecessary spacing around it. */\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n\n\t/* Show the selection handle when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n}\n\n.ck .ck-size-view {\n\tbackground: var(--ck-color-resizer-tooltip-background);\n\tcolor: var(--ck-color-resizer-tooltip-text);\n\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\n\tborder-radius: var(--ck-resizer-border-radius);\n\tfont-size: var(--ck-font-size-tiny);\n\tdisplay: block;\n\tpadding: 0 var(--ck-spacing-small);\n\theight: var(--ck-resizer-tooltip-height);\n\tline-height: var(--ck-resizer-tooltip-height);\n\n\t&.ck-orientation-top-left,\n\t&.ck-orientation-top-right,\n\t&.ck-orientation-bottom-right,\n\t&.ck-orientation-bottom-left,\n\t&.ck-orientation-above-center {\n\t\tposition: absolute;\n\t}\n\n\t&.ck-orientation-top-left {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-top-right {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-right {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-left {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t/* Class applied if the widget is too small to contain the size label */\n\t&.ck-orientation-above-center {\n\t\ttop: calc(var(--ck-resizer-tooltip-height) * -1);\n\t\tleft: 50%;\n\t\ttransform: translate(-50%);\n\t}\n}\n",
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n\t--ck-widget-outline-thickness: 3px;\n\t--ck-widget-handler-icon-size: 16px;\n\t--ck-widget-handler-animation-duration: 200ms;\n\t--ck-widget-handler-animation-curve: ease;\n\n\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n\toutline-width: var(--ck-widget-outline-thickness);\n\toutline-style: solid;\n\toutline-color: transparent;\n\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n\t}\n\n\t&:hover {\n\t\toutline-color: var(--ck-color-widget-hover-border);\n\t}\n}\n\n.ck .ck-editor__nested-editable {\n\tborder: 1px solid transparent;\n\n\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n\tThese styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n\t&.ck-editor__nested-editable_focused,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\t\tbackground-color: var(--ck-color-widget-editable-focus-background);\n\t}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t& .ck-widget__selection-handle {\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\n\t\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n\t\tbackground-color: transparent;\n\t\topacity: 0;\n\n\t\t/* Transition:\n\t\t   * background-color for the .ck-widget_selected state change,\n\t\t   * visibility for hiding the handler,\n\t\t   * opacity for the proper look of the icon when the handler disappears. */\n\t\ttransition:\n\t\t\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t/* Make only top corners round. */\n\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n\t\t/* Place the drag handler outside the widget wrapper. */\n\t\ttransform: translateY(-100%);\n\t\tleft: calc(0px - var(--ck-widget-outline-thickness));\n\t\ttop: 0;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n\t\t\twidth: var(--ck-widget-handler-icon-size);\n\t\t\theight: var(--ck-widget-handler-icon-size);\n\t\t\tcolor: var(--ck-color-widget-drag-handler-icon-color);\n\n\t\t\t/* The "selected" part of the icon is invisible by default */\n\t\t\t& .ck-icon__selected-indicator {\n\t\t\t\topacity: 0;\n\n\t\t\t\t/* Note: The animation is longer on purpose. Simply feels better. */\n\t\t\t\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\n\t\t\t}\n\t\t}\n\n\t\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n\t\t&:hover .ck-icon .ck-icon__selected-indicator {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\topacity: 1;\n\t\tbackground-color: var(--ck-color-widget-hover-border);\n\t}\n\n\t/* Show the selection handler when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\t& > .ck-widget__selection-handle {\n\t\t\topacity: 1;\n\t\t\tbackground-color: var(--ck-color-focus-border);\n\n\t\t\t/* When the widget is selected, notify the user using the proper look of the icon. */\n\t\t\t& .ck-icon .ck-icon__selected-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n\tleft: auto;\n\tright: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n\ttransition: none;\n\n\t&:not(.ck-widget_selected) {\n\t\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\n\t\t *\n\t\t * Leave the unit because this custom property is used in calc() by other features.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\n\t\t */\n\t\t--ck-widget-outline-thickness: 0px;\n\t}\n\n\t&.ck-widget_with-selection-handle {\n\t\t& .ck-widget__selection-handle,\n\t\t& .ck-widget__selection-handle:hover {\n\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t}\n\t}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline-color: var(--ck-color-widget-blurred-border);\n\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t& > .ck-widget__selection-handle,\n\t\t\t& > .ck-widget__selection-handle:hover {\n\t\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n\tIn fact, anything with overflow: hidden.\n\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\n\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n',
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      263: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}",
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgetresize.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css",
            ],
            names: [],
            mappings:
              "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD",
            sourcesContent: [
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n}\n\n.ck .ck-widget__resizer {\n\tdisplay: none;\n\tposition: absolute;\n\n\t/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n\tpointer-events: none;\n\n\tleft: 0;\n\ttop: 0;\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n\t& > .ck-widget__resizer {\n\t\tdisplay: block;\n\t}\n}\n\n.ck .ck-widget__resizer__handle {\n\tposition: absolute;\n\n\t/* Resizers are the only UI elements that should interfere with a pointer device. */\n\tpointer-events: all;\n\n\t&.ck-widget__resizer__handle-top-left,\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tcursor: nwse-resize;\n\t}\n\n\t&.ck-widget__resizer__handle-top-right,\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tcursor: nesw-resize;\n\t}\n}\n",
              "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-resizer-size: 10px;\n\n\t/* Set the resizer with a 50% offset. */\n\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n\t--ck-resizer-border-width: 1px;\n}\n\n.ck .ck-widget__resizer {\n\toutline: 1px solid var(--ck-color-resizer);\n}\n\n.ck .ck-widget__resizer__handle {\n\twidth: var(--ck-resizer-size);\n\theight: var(--ck-resizer-size);\n\tbackground: var(--ck-color-focus-border);\n\tborder: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n\tborder-radius: var(--ck-resizer-border-radius);\n\n\t&.ck-widget__resizer__handle-top-left {\n\t\ttop: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-top-right {\n\t\ttop: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n}\n",
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      137: (t, e, n) => {
        "use strict"
        n.d(e, { Z: () => c })
        var o = n(15)
        var r = n.n(o)
        var i = n(645)
        var s = n.n(i)
        var a = s()(r())
        a.push([
          t.id,
          '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}',
          "",
          {
            version: 3,
            sources: [
              "webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css",
              "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css",
            ],
            names: [],
            mappings:
              "AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD",
            sourcesContent: [
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\toverflow: hidden;\n\t\tz-index: var(--ck-z-default);\n\n\t\t& svg {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\tz-index: calc(var(--ck-z-default) + 2);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_before {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tleft: min(10%, 30px);\n\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_after {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tright: min(10%, 30px);\n\n\t\t\ttransform: translateY(50%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t\ttop: 1px;\n\t\t\tleft: 1px;\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tdisplay: none;\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\t/*\n\t * When the widget is hovered the "fake caret" would normally be narrower than the\n\t * extra outline displayed around the widget. Let\'s extend the "fake caret" to match\n\t * the full width of the widget.\n\t */\n\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\n\t\tright: calc( -1 * var(--ck-widget-outline-thickness) );\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n}\n\n/*\n * Integration with the read-only mode of the editor.\n */\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the restricted editing mode (feature) of the editor.\n */\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\n */\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\n\tdisplay: none;\n}\n',
              '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-widget-type-around-button-size: 20px;\n\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\n\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\n\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\n\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\n\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\n\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\n}\n\n@define-mixin ck-widget-type-around-button-visible {\n\topacity: 1;\n\tpointer-events: auto;\n}\n\n@define-mixin ck-widget-type-around-button-hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\twidth: var(--ck-widget-type-around-button-size);\n\t\theight: var(--ck-widget-type-around-button-size);\n\t\tbackground: var(--ck-color-widget-type-around-button);\n\t\tborder-radius: 100px;\n\t\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t@mixin ck-widget-type-around-button-hidden;\n\n\t\t& svg {\n\t\t\twidth: 10px;\n\t\t\theight: 8px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t\ttransition: transform .5s ease;\n\t\t\tmargin-top: 1px;\n\n\t\t\t& * {\n\t\t\t\tstroke-dasharray: 10;\n\t\t\t\tstroke-dashoffset: 0;\n\n\t\t\t\tfill: none;\n\t\t\t\tstroke: var(--ck-color-widget-type-around-button-icon);\n\t\t\t\tstroke-width: 1.5px;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t}\n\n\t\t\t& line {\n\t\t\t\tstroke-dasharray: 7;\n\t\t\t}\n\t\t}\n\n\t\t&:hover {\n\t\t\t/*\n\t\t\t * Display the "sonar" around the button when hovered.\n\t\t\t */\n\t\t\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\n\n\t\t\t/*\n\t\t\t * Animate active button\'s icon.\n\t\t\t */\n\t\t\t& svg {\n\t\t\t\t& polyline {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-dash 2s linear;\n\t\t\t\t}\n\n\t\t\t\t& line {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Show type around buttons when the widget gets selected or being hovered.\n\t */\n\t&.ck-widget_selected,\n\t&:hover {\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-visible;\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\n\t * and still can be hovered).\n\t */\n\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\tbackground: var(--ck-color-widget-type-around-button-hover);\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\tbackground: var(--ck-color-widget-type-around-button-active);\n\n\t\t&::after {\n\t\t\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\tborder-radius: 100px;\n\t\t\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the "before" button when the widget has a selection handle. Because some space\n\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\n\t */\n\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\n\t\tmargin-left: 20px;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& .ck-widget__type-around__fake-caret {\n\t\tpointer-events: none;\n\t\theight: 1px;\n\t\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\n\n\t\t/*\n\t\t * The semi-transparent-outline+background combo improves the contrast\n\t\t * when the background underneath the fake caret is dark.\n\t\t */\n\t\toutline: solid 1px hsla(0, 0%, 100%, .5);\n\t\tbackground: var(--ck-color-base-text);\n\t}\n\n\t/*\n\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t * Despite the widget being physically selected in the model, its outline should disappear.\n\t */\n\t&.ck-widget_selected {\n\t\t&.ck-widget_type-around_show-fake-caret_before,\n\t\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t\toutline-color: transparent;\n\t\t}\n\t}\n\n\t&.ck-widget_type-around_show-fake-caret_before,\n\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t/*\n\t\t * When the "fake caret" is visible we simulate that the widget is not selected\n\t\t * (despite being physically selected), so the outline color should be for the\n\t\t * unselected widget.\n\t\t */\n\t\t&.ck-widget_selected:hover {\n\t\t\toutline-color: var(--ck-color-widget-hover-border);\n\t\t}\n\n\t\t/*\n\t\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\n\t\t */\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\n\t\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\n\t\t */\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t&.ck-widget_selected,\n\t\t\t&.ck-widget_selected:hover {\n\t\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\t\topacity: 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\n\t\t * hide the resize UI because it creates too much noise. It can be visible when the user\n\t\t * hovers the widget, though.\n\t\t */\n\t\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\n\t\t\topacity: 0\n\t\t}\n\t}\n}\n\n/*\n * Styles for the "before" button when the widget has a selection handle in an RTL environment.\n * The selection handler is aligned to the right side of the widget so there is no need to create\n * additional space for it next to the "before" button.\n */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {\n\tmargin-left: 0;\n\tmargin-right: 20px;\n}\n\n/*\n * Hide type around buttons when the widget is selected as a child of a selected\n * nested editable (e.g. mulit-cell table selection).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\n */\n.ck-editor__nested-editable.ck-editor__editable_selected {\n\t& .ck-widget {\n\t\t&.ck-widget_selected,\n\t\t&:hover {\n\t\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\n */\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\n\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\n\n\t& svg * {\n\t\tstroke: hsl(0,0%,60%);\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-dash {\n\t0% {\n\t\tstroke-dashoffset: 10;\n\t}\n\t20%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-tip-dash {\n\t0%, 20% {\n\t\tstroke-dashoffset: 7;\n\t}\n\t40%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-button-sonar {\n\t0% {\n\t\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n\t50% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\n\t}\n\t100% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n}\n\n@keyframes ck-widget-type-around-fake-caret-pulse {\n\t0% {\n\t\topacity: 1;\n\t}\n\t49% {\n\t\topacity: 1;\n\t}\n\t50% {\n\t\topacity: 0;\n\t}\n\t99% {\n\t\topacity: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t}\n}\n',
            ],
            sourceRoot: "",
          },
        ])
        const c = a
      },
      645: (t) => {
        "use strict"
        t.exports = function (t) {
          var e = []
          e.toString = function e() {
            return this.map(function (e) {
              var n = t(e)
              if (e[2]) {
                return "@media ".concat(e[2], " {").concat(n, "}")
              }
              return n
            }).join("")
          }
          e.i = function (t, n, o) {
            if (typeof t === "string") {
              t = [[null, t, ""]]
            }
            var r = {}
            if (o) {
              for (var i = 0; i < this.length; i++) {
                var s = this[i][0]
                if (s != null) {
                  r[s] = true
                }
              }
            }
            for (var a = 0; a < t.length; a++) {
              var c = [].concat(t[a])
              if (o && r[c[0]]) {
                continue
              }
              if (n) {
                if (!c[2]) {
                  c[2] = n
                } else {
                  c[2] = "".concat(n, " and ").concat(c[2])
                }
              }
              e.push(c)
            }
          }
          return e
        }
      },
      15: (t) => {
        "use strict"
        function e(t, e) {
          return s(t) || i(t, e) || o(t, e) || n()
        }
        function n() {
          throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          )
        }
        function o(t, e) {
          if (!t) return
          if (typeof t === "string") return r(t, e)
          var n = Object.prototype.toString.call(t).slice(8, -1)
          if (n === "Object" && t.constructor) n = t.constructor.name
          if (n === "Map" || n === "Set") return Array.from(t)
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return r(t, e)
        }
        function r(t, e) {
          if (e == null || e > t.length) e = t.length
          for (var n = 0, o = new Array(e); n < e; n++) {
            o[n] = t[n]
          }
          return o
        }
        function i(t, e) {
          var n = t && ((typeof Symbol !== "undefined" && t[Symbol.iterator]) || t["@@iterator"])
          if (n == null) return
          var o = []
          var r = true
          var i = false
          var s, a
          try {
            for (n = n.call(t); !(r = (s = n.next()).done); r = true) {
              o.push(s.value)
              if (e && o.length === e) break
            }
          } catch (t) {
            i = true
            a = t
          } finally {
            try {
              if (!r && n["return"] != null) n["return"]()
            } finally {
              if (i) throw a
            }
          }
          return o
        }
        function s(t) {
          if (Array.isArray(t)) return t
        }
        t.exports = function t(n) {
          var o = e(n, 4),
            r = o[1],
            i = o[3]
          if (!i) {
            return r
          }
          if (typeof btoa === "function") {
            var s = btoa(unescape(encodeURIComponent(JSON.stringify(i))))
            var a = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(s)
            var c = "/*# ".concat(a, " */")
            var l = i.sources.map(function (t) {
              return "/*# sourceURL=".concat(i.sourceRoot || "").concat(t, " */")
            })
            return [r].concat(l).concat([c]).join("\n")
          }
          return [r].join("\n")
        }
      },
      379: (t, e, n) => {
        "use strict"
        var o = (function t() {
          var e
          return function t() {
            if (typeof e === "undefined") {
              e = Boolean(window && document && document.all && !window.atob)
            }
            return e
          }
        })()
        var r = (function t() {
          var e = {}
          return function t(n) {
            if (typeof e[n] === "undefined") {
              var o = document.querySelector(n)
              if (window.HTMLIFrameElement && o instanceof window.HTMLIFrameElement) {
                try {
                  o = o.contentDocument.head
                } catch (t) {
                  o = null
                }
              }
              e[n] = o
            }
            return e[n]
          }
        })()
        var i = []
        function s(t) {
          var e = -1
          for (var n = 0; n < i.length; n++) {
            if (i[n].identifier === t) {
              e = n
              break
            }
          }
          return e
        }
        function a(t, e) {
          var n = {}
          var o = []
          for (var r = 0; r < t.length; r++) {
            var a = t[r]
            var c = e.base ? a[0] + e.base : a[0]
            var l = n[c] || 0
            var d = "".concat(c, " ").concat(l)
            n[c] = l + 1
            var h = s(d)
            var u = { css: a[1], media: a[2], sourceMap: a[3] }
            if (h !== -1) {
              i[h].references++
              i[h].updater(u)
            } else {
              i.push({ identifier: d, updater: g(u, e), references: 1 })
            }
            o.push(d)
          }
          return o
        }
        function c(t) {
          var e = document.createElement("style")
          var o = t.attributes || {}
          if (typeof o.nonce === "undefined") {
            var i = true ? n.nc : 0
            if (i) {
              o.nonce = i
            }
          }
          Object.keys(o).forEach(function (t) {
            e.setAttribute(t, o[t])
          })
          if (typeof t.insert === "function") {
            t.insert(e)
          } else {
            var s = r(t.insert || "head")
            if (!s) {
              throw new Error(
                "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
              )
            }
            s.appendChild(e)
          }
          return e
        }
        function l(t) {
          if (t.parentNode === null) {
            return false
          }
          t.parentNode.removeChild(t)
        }
        var d = (function t() {
          var e = []
          return function t(n, o) {
            e[n] = o
            return e.filter(Boolean).join("\n")
          }
        })()
        function h(t, e, n, o) {
          var r = n ? "" : o.media ? "@media ".concat(o.media, " {").concat(o.css, "}") : o.css
          if (t.styleSheet) {
            t.styleSheet.cssText = d(e, r)
          } else {
            var i = document.createTextNode(r)
            var s = t.childNodes
            if (s[e]) {
              t.removeChild(s[e])
            }
            if (s.length) {
              t.insertBefore(i, s[e])
            } else {
              t.appendChild(i)
            }
          }
        }
        function u(t, e, n) {
          var o = n.css
          var r = n.media
          var i = n.sourceMap
          if (r) {
            t.setAttribute("media", r)
          } else {
            t.removeAttribute("media")
          }
          if (i && typeof btoa !== "undefined") {
            o += "\n/*# sourceMappingURL=data:application/json;base64,".concat(
              btoa(unescape(encodeURIComponent(JSON.stringify(i)))),
              " */"
            )
          }
          if (t.styleSheet) {
            t.styleSheet.cssText = o
          } else {
            while (t.firstChild) {
              t.removeChild(t.firstChild)
            }
            t.appendChild(document.createTextNode(o))
          }
        }
        var f = null
        var p = 0
        function g(t, e) {
          var n
          var o
          var r
          if (e.singleton) {
            var i = p++
            n = f || (f = c(e))
            o = h.bind(null, n, i, false)
            r = h.bind(null, n, i, true)
          } else {
            n = c(e)
            o = u.bind(null, n, e)
            r = function t() {
              l(n)
            }
          }
          o(t)
          return function e(n) {
            if (n) {
              if (n.css === t.css && n.media === t.media && n.sourceMap === t.sourceMap) {
                return
              }
              o((t = n))
            } else {
              r()
            }
          }
        }
        t.exports = function (t, e) {
          e = e || {}
          if (!e.singleton && typeof e.singleton !== "boolean") {
            e.singleton = o()
          }
          t = t || []
          var n = a(t, e)
          return function t(o) {
            o = o || []
            if (Object.prototype.toString.call(o) !== "[object Array]") {
              return
            }
            for (var r = 0; r < n.length; r++) {
              var c = n[r]
              var l = s(c)
              i[l].references--
            }
            var d = a(o, e)
            for (var h = 0; h < n.length; h++) {
              var u = n[h]
              var f = s(u)
              if (i[f].references === 0) {
                i[f].updater()
                i.splice(f, 1)
              }
            }
            n = d
          }
        }
      },
    }
    var e = {}
    function n(o) {
      var r = e[o]
      if (r !== undefined) {
        return r.exports
      }
      var i = (e[o] = { id: o, exports: {} })
      t[o](i, i.exports, n)
      return i.exports
    }
    ;(() => {
      n.n = (t) => {
        var e = t && t.__esModule ? () => t["default"] : () => t
        n.d(e, { a: e })
        return e
      }
    })()
    ;(() => {
      n.d = (t, e) => {
        for (var o in e) {
          if (n.o(e, o) && !n.o(t, o)) {
            Object.defineProperty(t, o, { enumerable: true, get: e[o] })
          }
        }
      }
    })()
    ;(() => {
      n.g = (function () {
        if (typeof globalThis === "object") return globalThis
        try {
          return this || new Function("return this")()
        } catch (t) {
          if (typeof window === "object") return window
        }
      })()
    })()
    ;(() => {
      n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)
    })()
    ;(() => {
      n.nc = undefined
    })()
    var o = {}
    ;(() => {
      "use strict"
      n.d(o, { default: () => $P })
      function t() {
        try {
          return navigator.userAgent.toLowerCase()
        } catch (t) {
          return ""
        }
      }
      const e = t()
      const r = {
        isMac: s(e),
        isWindows: a(e),
        isGecko: c(e),
        isSafari: l(e),
        isiOS: d(e),
        isAndroid: h(e),
        isBlink: u(e),
        features: { isRegExpUnicodePropertySupported: f() },
      }
      const i = r
      function s(t) {
        return t.indexOf("macintosh") > -1
      }
      function a(t) {
        return t.indexOf("windows") > -1
      }
      function c(t) {
        return !!t.match(/gecko\/\d+/)
      }
      function l(t) {
        return t.indexOf(" applewebkit/") > -1 && t.indexOf("chrome") === -1
      }
      function d(t) {
        return !!t.match(/iphone|ipad/i) || (s(t) && navigator.maxTouchPoints > 0)
      }
      function h(t) {
        return t.indexOf("android") > -1
      }
      function u(t) {
        return t.indexOf("chrome/") > -1 && t.indexOf("edge/") < 0
      }
      function f() {
        let t = false
        try {
          t = "ć".search(new RegExp("[\\p{L}]", "u")) === 0
        } catch (t) {}
        return t
      }
      function p(t, e, n, o) {
        n =
          n ||
          function (t, e) {
            return t === e
          }
        const r = Array.isArray(t) ? t : Array.prototype.slice.call(t)
        const i = Array.isArray(e) ? e : Array.prototype.slice.call(e)
        const s = g(r, i, n)
        const a = o ? w(s, i.length) : b(i, s)
        return a
      }
      function g(t, e, n) {
        const o = m(t, e, n)
        if (o === -1) {
          return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 }
        }
        const r = k(t, o)
        const i = k(e, o)
        const s = m(r, i, n)
        const a = t.length - s
        const c = e.length - s
        return { firstIndex: o, lastIndexOld: a, lastIndexNew: c }
      }
      function m(t, e, n) {
        for (let o = 0; o < Math.max(t.length, e.length); o++) {
          if (t[o] === undefined || e[o] === undefined || !n(t[o], e[o])) {
            return o
          }
        }
        return -1
      }
      function k(t, e) {
        return t.slice(e).reverse()
      }
      function b(t, e) {
        const n = []
        const { firstIndex: o, lastIndexOld: r, lastIndexNew: i } = e
        if (i - o > 0) {
          n.push({ index: o, type: "insert", values: t.slice(o, i) })
        }
        if (r - o > 0) {
          n.push({ index: o + (i - o), type: "delete", howMany: r - o })
        }
        return n
      }
      function w(t, e) {
        const { firstIndex: n, lastIndexOld: o, lastIndexNew: r } = t
        if (n === -1) {
          return Array(e).fill("equal")
        }
        let i = []
        if (n > 0) {
          i = i.concat(Array(n).fill("equal"))
        }
        if (r - n > 0) {
          i = i.concat(Array(r - n).fill("insert"))
        }
        if (o - n > 0) {
          i = i.concat(Array(o - n).fill("delete"))
        }
        if (r < e) {
          i = i.concat(Array(e - r).fill("equal"))
        }
        return i
      }
      function _(t, e, n) {
        n =
          n ||
          function (t, e) {
            return t === e
          }
        const o = t.length
        const r = e.length
        if (o > 200 || r > 200 || o + r > 300) {
          return _.fastDiff(t, e, n, true)
        }
        let i, s
        if (r < o) {
          const n = t
          t = e
          e = n
          i = "delete"
          s = "insert"
        } else {
          i = "insert"
          s = "delete"
        }
        const a = t.length
        const c = e.length
        const l = c - a
        const d = {}
        const h = {}
        function u(o) {
          const r = (h[o - 1] !== undefined ? h[o - 1] : -1) + 1
          const l = h[o + 1] !== undefined ? h[o + 1] : -1
          const u = r > l ? -1 : 1
          if (d[o + u]) {
            d[o] = d[o + u].slice(0)
          }
          if (!d[o]) {
            d[o] = []
          }
          d[o].push(r > l ? i : s)
          let f = Math.max(r, l)
          let p = f - o
          while (p < a && f < c && n(t[p], e[f])) {
            p++
            f++
            d[o].push("equal")
          }
          return f
        }
        let f = 0
        let p
        do {
          for (p = -f; p < l; p++) {
            h[p] = u(p)
          }
          for (p = l + f; p > l; p--) {
            h[p] = u(p)
          }
          h[l] = u(l)
          f++
        } while (h[l] !== c)
        return d[l].slice(1)
      }
      _.fastDiff = p
      function v() {
        return function t() {
          t.called = true
        }
      }
      const A = v
      class C {
        constructor(t, e) {
          this.source = t
          this.name = e
          this.path = []
          this.stop = A()
          this.off = A()
        }
      }
      const y = new Array(256).fill("").map((t, e) => ("0" + e.toString(16)).slice(-2))
      function x() {
        const t = (Math.random() * 4294967296) >>> 0
        const e = (Math.random() * 4294967296) >>> 0
        const n = (Math.random() * 4294967296) >>> 0
        const o = (Math.random() * 4294967296) >>> 0
        return (
          "e" +
          y[(t >> 0) & 255] +
          y[(t >> 8) & 255] +
          y[(t >> 16) & 255] +
          y[(t >> 24) & 255] +
          y[(e >> 0) & 255] +
          y[(e >> 8) & 255] +
          y[(e >> 16) & 255] +
          y[(e >> 24) & 255] +
          y[(n >> 0) & 255] +
          y[(n >> 8) & 255] +
          y[(n >> 16) & 255] +
          y[(n >> 24) & 255] +
          y[(o >> 0) & 255] +
          y[(o >> 8) & 255] +
          y[(o >> 16) & 255] +
          y[(o >> 24) & 255]
        )
      }
      const E = {
        get(t = "normal") {
          if (typeof t != "number") {
            return this[t] || this.normal
          } else {
            return t
          }
        },
        highest: 1e5,
        high: 1e3,
        normal: 0,
        low: -1e3,
        lowest: -1e5,
      }
      const D = E
      function S(t, e) {
        const n = D.get(e.priority)
        for (let o = 0; o < t.length; o++) {
          if (D.get(t[o].priority) < n) {
            t.splice(o, 0, e)
            return
          }
        }
        t.push(e)
      }
      const T = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html"
      class P extends Error {
        constructor(t, e, n) {
          super(M(t, n))
          this.name = "CKEditorError"
          this.context = e
          this.data = n
        }
        is(t) {
          return t === "CKEditorError"
        }
        static rethrowUnexpectedError(t, e) {
          if (t.is && t.is("CKEditorError")) {
            throw t
          }
          const n = new P(t.message, e)
          n.stack = t.stack
          throw n
        }
      }
      function B(t, e) {
        console.warn(...I(t, e))
      }
      function R(t, e) {
        console.error(...I(t, e))
      }
      function O(t) {
        return `\nRead more: ${T}#error-${t}`
      }
      function M(t, e) {
        const n = new WeakSet()
        const o = (t, e) => {
          if (typeof e === "object" && e !== null) {
            if (n.has(e)) {
              return `[object ${e.constructor.name}]`
            }
            n.add(e)
          }
          return e
        }
        const r = e ? ` ${JSON.stringify(e, o)}` : ""
        const i = O(t)
        return t + r + i
      }
      function I(t, e) {
        const n = O(t)
        return e ? [t, e, n] : [t, n]
      }
      const z = "38.1.0"
      const N = null && z
      const F = new Date(2023, 5, 28)
      const V = typeof window === "object" ? window : n.g
      if (V.CKEDITOR_VERSION) {
        throw new P("ckeditor-duplicated-modules", null)
      } else {
        V.CKEDITOR_VERSION = z
      }
      const L = Symbol("listeningTo")
      const j = Symbol("emitterId")
      const H = Symbol("delegations")
      const W = q(Object)
      function q(t) {
        if (!t) {
          return W
        }
        class e extends t {
          on(t, e, n) {
            this.listenTo(this, t, e, n)
          }
          once(t, e, n) {
            let o = false
            const r = (t, ...n) => {
              if (!o) {
                o = true
                t.off()
                e.call(this, t, ...n)
              }
            }
            this.listenTo(this, t, r, n)
          }
          off(t, e) {
            this.stopListening(this, t, e)
          }
          listenTo(t, e, n, o = {}) {
            let r, i
            if (!this[L]) {
              this[L] = {}
            }
            const s = this[L]
            if (!G(t)) {
              K(t)
            }
            const a = G(t)
            if (!(r = s[a])) {
              r = s[a] = { emitter: t, callbacks: {} }
            }
            if (!(i = r.callbacks[e])) {
              i = r.callbacks[e] = []
            }
            i.push(n)
            tt(this, t, e, n, o)
          }
          stopListening(t, e, n) {
            const o = this[L]
            let r = t && G(t)
            const i = o && r ? o[r] : undefined
            const s = i && e ? i.callbacks[e] : undefined
            if (!o || (t && !i) || (e && !s)) {
              return
            }
            if (n) {
              et(this, t, e, n)
              const o = s.indexOf(n)
              if (o !== -1) {
                if (s.length === 1) {
                  delete i.callbacks[e]
                } else {
                  et(this, t, e, n)
                }
              }
            } else if (s) {
              while ((n = s.pop())) {
                et(this, t, e, n)
              }
              delete i.callbacks[e]
            } else if (i) {
              for (e in i.callbacks) {
                this.stopListening(t, e)
              }
              delete o[r]
            } else {
              for (r in o) {
                this.stopListening(o[r].emitter)
              }
              delete this[L]
            }
          }
          fire(t, ...e) {
            try {
              const n = t instanceof C ? t : new C(this, t)
              const o = n.name
              let r = Q(this, o)
              n.path.push(this)
              if (r) {
                const t = [n, ...e]
                r = Array.from(r)
                for (let e = 0; e < r.length; e++) {
                  r[e].callback.apply(this, t)
                  if (n.off.called) {
                    delete n.off.called
                    this._removeEventListener(o, r[e].callback)
                  }
                  if (n.stop.called) {
                    break
                  }
                }
              }
              const i = this[H]
              if (i) {
                const t = i.get(o)
                const r = i.get("*")
                if (t) {
                  X(t, n, e)
                }
                if (r) {
                  X(r, n, e)
                }
              }
              return n.return
            } catch (t) {
              P.rethrowUnexpectedError(t, this)
            }
          }
          delegate(...t) {
            return {
              to: (e, n) => {
                if (!this[H]) {
                  this[H] = new Map()
                }
                t.forEach((t) => {
                  const o = this[H].get(t)
                  if (!o) {
                    this[H].set(t, new Map([[e, n]]))
                  } else {
                    o.set(e, n)
                  }
                })
              },
            }
          }
          stopDelegating(t, e) {
            if (!this[H]) {
              return
            }
            if (!t) {
              this[H].clear()
            } else if (!e) {
              this[H].delete(t)
            } else {
              const n = this[H].get(t)
              if (n) {
                n.delete(e)
              }
            }
          }
          _addEventListener(t, e, n) {
            Z(this, t)
            const o = Y(this, t)
            const r = D.get(n.priority)
            const i = { callback: e, priority: r }
            for (const t of o) {
              S(t, i)
            }
          }
          _removeEventListener(t, e) {
            const n = Y(this, t)
            for (const t of n) {
              for (let n = 0; n < t.length; n++) {
                if (t[n].callback == e) {
                  t.splice(n, 1)
                  n--
                }
              }
            }
          }
        }
        return e
      }
      ;[
        "on",
        "once",
        "off",
        "listenTo",
        "stopListening",
        "fire",
        "delegate",
        "stopDelegating",
        "_addEventListener",
        "_removeEventListener",
      ].forEach((t) => {
        q[t] = W.prototype[t]
      })
      function $(t, e) {
        const n = t[L]
        if (n && n[e]) {
          return n[e].emitter
        }
        return null
      }
      function K(t, e) {
        if (!t[j]) {
          t[j] = e || x()
        }
      }
      function G(t) {
        return t[j]
      }
      function U(t) {
        if (!t._events) {
          Object.defineProperty(t, "_events", { value: {} })
        }
        return t._events
      }
      function J() {
        return { callbacks: [], childEvents: [] }
      }
      function Z(t, e) {
        const n = U(t)
        if (n[e]) {
          return
        }
        let o = e
        let r = null
        const i = []
        while (o !== "") {
          if (n[o]) {
            break
          }
          n[o] = J()
          i.push(n[o])
          if (r) {
            n[o].childEvents.push(r)
          }
          r = o
          o = o.substr(0, o.lastIndexOf(":"))
        }
        if (o !== "") {
          for (const t of i) {
            t.callbacks = n[o].callbacks.slice()
          }
          n[o].childEvents.push(r)
        }
      }
      function Y(t, e) {
        const n = U(t)[e]
        if (!n) {
          return []
        }
        let o = [n.callbacks]
        for (let e = 0; e < n.childEvents.length; e++) {
          const r = Y(t, n.childEvents[e])
          o = o.concat(r)
        }
        return o
      }
      function Q(t, e) {
        let n
        if (!t._events || !(n = t._events[e]) || !n.callbacks.length) {
          if (e.indexOf(":") > -1) {
            return Q(t, e.substr(0, e.lastIndexOf(":")))
          } else {
            return null
          }
        }
        return n.callbacks
      }
      function X(t, e, n) {
        for (let [o, r] of t) {
          if (!r) {
            r = e.name
          } else if (typeof r == "function") {
            r = r(e.name)
          }
          const t = new C(e.source, r)
          t.path = [...e.path]
          o.fire(t, ...n)
        }
      }
      function tt(t, e, n, o, r) {
        if (e._addEventListener) {
          e._addEventListener(n, o, r)
        } else {
          t._addEventListener.call(e, n, o, r)
        }
      }
      function et(t, e, n, o) {
        if (e._removeEventListener) {
          e._removeEventListener(n, o)
        } else {
          t._removeEventListener.call(e, n, o)
        }
      }
      function nt(t) {
        var e = typeof t
        return t != null && (e == "object" || e == "function")
      }
      const ot = nt
      const rt = Symbol("observableProperties")
      const it = Symbol("boundObservables")
      const st = Symbol("boundProperties")
      const at = Symbol("decoratedMethods")
      const ct = Symbol("decoratedOriginal")
      const lt = dt(q())
      function dt(t) {
        if (!t) {
          return lt
        }
        class e extends t {
          set(t, e) {
            if (ot(t)) {
              Object.keys(t).forEach((e) => {
                this.set(e, t[e])
              }, this)
              return
            }
            ht(this)
            const n = this[rt]
            if (t in this && !n.has(t)) {
              throw new P("observable-set-cannot-override", this)
            }
            Object.defineProperty(this, t, {
              enumerable: true,
              configurable: true,
              get() {
                return n.get(t)
              },
              set(e) {
                const o = n.get(t)
                let r = this.fire(`set:${t}`, t, e, o)
                if (r === undefined) {
                  r = e
                }
                if (o !== r || !n.has(t)) {
                  n.set(t, r)
                  this.fire(`change:${t}`, t, r, o)
                }
              },
            })
            this[t] = e
          }
          bind(...t) {
            if (!t.length || !gt(t)) {
              throw new P("observable-bind-wrong-properties", this)
            }
            if (new Set(t).size !== t.length) {
              throw new P("observable-bind-duplicate-properties", this)
            }
            ht(this)
            const e = this[st]
            t.forEach((t) => {
              if (e.has(t)) {
                throw new P("observable-bind-rebind", this)
              }
            })
            const n = new Map()
            t.forEach((t) => {
              const o = { property: t, to: [] }
              e.set(t, o)
              n.set(t, o)
            })
            return {
              to: ut,
              toMany: ft,
              _observable: this,
              _bindProperties: t,
              _to: [],
              _bindings: n,
            }
          }
          unbind(...t) {
            if (!this[rt]) {
              return
            }
            const e = this[st]
            const n = this[it]
            if (t.length) {
              if (!gt(t)) {
                throw new P("observable-unbind-wrong-properties", this)
              }
              t.forEach((t) => {
                const o = e.get(t)
                if (!o) {
                  return
                }
                o.to.forEach(([t, e]) => {
                  const r = n.get(t)
                  const i = r[e]
                  i.delete(o)
                  if (!i.size) {
                    delete r[e]
                  }
                  if (!Object.keys(r).length) {
                    n.delete(t)
                    this.stopListening(t, "change")
                  }
                })
                e.delete(t)
              })
            } else {
              n.forEach((t, e) => {
                this.stopListening(e, "change")
              })
              n.clear()
              e.clear()
            }
          }
          decorate(t) {
            ht(this)
            const e = this[t]
            if (!e) {
              throw new P("observablemixin-cannot-decorate-undefined", this, {
                object: this,
                methodName: t,
              })
            }
            this.on(t, (t, n) => {
              t.return = e.apply(this, n)
            })
            this[t] = function (...e) {
              return this.fire(t, e)
            }
            this[t][ct] = e
            if (!this[at]) {
              this[at] = []
            }
            this[at].push(t)
          }
          stopListening(t, e, n) {
            if (!t && this[at]) {
              for (const t of this[at]) {
                this[t] = this[t][ct]
              }
              delete this[at]
            }
            super.stopListening(t, e, n)
          }
        }
        return e
      }
      ;[
        "set",
        "bind",
        "unbind",
        "decorate",
        "on",
        "once",
        "off",
        "listenTo",
        "stopListening",
        "fire",
        "delegate",
        "stopDelegating",
        "_addEventListener",
        "_removeEventListener",
      ].forEach((t) => {
        dt[t] = lt.prototype[t]
      })
      function ht(t) {
        if (t[rt]) {
          return
        }
        Object.defineProperty(t, rt, { value: new Map() })
        Object.defineProperty(t, it, { value: new Map() })
        Object.defineProperty(t, st, { value: new Map() })
      }
      function ut(...t) {
        const e = mt(...t)
        const n = Array.from(this._bindings.keys())
        const o = n.length
        if (!e.callback && e.to.length > 1) {
          throw new P("observable-bind-to-no-callback", this)
        }
        if (o > 1 && e.callback) {
          throw new P("observable-bind-to-extra-callback", this)
        }
        e.to.forEach((t) => {
          if (t.properties.length && t.properties.length !== o) {
            throw new P("observable-bind-to-properties-length", this)
          }
          if (!t.properties.length) {
            t.properties = this._bindProperties
          }
        })
        this._to = e.to
        if (e.callback) {
          this._bindings.get(n[0]).callback = e.callback
        }
        _t(this._observable, this._to)
        bt(this)
        this._bindProperties.forEach((t) => {
          wt(this._observable, t)
        })
      }
      function ft(t, e, n) {
        if (this._bindings.size > 1) {
          throw new P("observable-bind-to-many-not-one-binding", this)
        }
        this.to(...pt(t, e), n)
      }
      function pt(t, e) {
        const n = t.map((t) => [t, e])
        return Array.prototype.concat.apply([], n)
      }
      function gt(t) {
        return t.every((t) => typeof t == "string")
      }
      function mt(...t) {
        if (!t.length) {
          throw new P("observable-bind-to-parse-error", null)
        }
        const e = { to: [] }
        let n
        if (typeof t[t.length - 1] == "function") {
          e.callback = t.pop()
        }
        t.forEach((t) => {
          if (typeof t == "string") {
            n.properties.push(t)
          } else if (typeof t == "object") {
            n = { observable: t, properties: [] }
            e.to.push(n)
          } else {
            throw new P("observable-bind-to-parse-error", null)
          }
        })
        return e
      }
      function kt(t, e, n, o) {
        const r = t[it]
        const i = r.get(n)
        const s = i || {}
        if (!s[o]) {
          s[o] = new Set()
        }
        s[o].add(e)
        if (!i) {
          r.set(n, s)
        }
      }
      function bt(t) {
        let e
        t._bindings.forEach((n, o) => {
          t._to.forEach((r) => {
            e = r.properties[n.callback ? 0 : t._bindProperties.indexOf(o)]
            n.to.push([r.observable, e])
            kt(t._observable, n, r.observable, e)
          })
        })
      }
      function wt(t, e) {
        const n = t[st]
        const o = n.get(e)
        let r
        if (o.callback) {
          r = o.callback.apply(
            t,
            o.to.map((t) => t[0][t[1]])
          )
        } else {
          r = o.to[0]
          r = r[0][r[1]]
        }
        if (Object.prototype.hasOwnProperty.call(t, e)) {
          t[e] = r
        } else {
          t.set(e, r)
        }
      }
      function _t(t, e) {
        e.forEach((e) => {
          const n = t[it]
          let o
          if (!n.get(e.observable)) {
            t.listenTo(e.observable, "change", (r, i) => {
              o = n.get(e.observable)[i]
              if (o) {
                o.forEach((e) => {
                  wt(t, e.property)
                })
              }
            })
          }
        })
      }
      class vt {
        constructor() {
          this._replacedElements = []
        }
        replace(t, e) {
          this._replacedElements.push({ element: t, newElement: e })
          t.style.display = "none"
          if (e) {
            t.parentNode.insertBefore(e, t.nextSibling)
          }
        }
        restore() {
          this._replacedElements.forEach(({ element: t, newElement: e }) => {
            t.style.display = ""
            if (e) {
              e.remove()
            }
          })
          this._replacedElements = []
        }
      }
      function At(t) {
        let e = 0
        for (const n of t) {
          e++
        }
        return e
      }
      function Ct(t, e) {
        const n = Math.min(t.length, e.length)
        for (let o = 0; o < n; o++) {
          if (t[o] != e[o]) {
            return o
          }
        }
        if (t.length == e.length) {
          return "same"
        } else if (t.length < e.length) {
          return "prefix"
        } else {
          return "extension"
        }
      }
      function yt(t) {
        return !!(t && t[Symbol.iterator])
      }
      var xt = typeof global == "object" && global && global.Object === Object && global
      const Et = xt
      var Dt = typeof self == "object" && self && self.Object === Object && self
      var St = Et || Dt || Function("return this")()
      const Tt = St
      var Pt = Tt.Symbol
      const Bt = Pt
      var Rt = Object.prototype
      var Ot = Rt.hasOwnProperty
      var Mt = Rt.toString
      var It = Bt ? Bt.toStringTag : undefined
      function zt(t) {
        var e = Ot.call(t, It),
          n = t[It]
        try {
          t[It] = undefined
          var o = true
        } catch (t) {}
        var r = Mt.call(t)
        if (o) {
          if (e) {
            t[It] = n
          } else {
            delete t[It]
          }
        }
        return r
      }
      const Nt = zt
      var Ft = Object.prototype
      var Vt = Ft.toString
      function Lt(t) {
        return Vt.call(t)
      }
      const jt = Lt
      var Ht = "[object Null]",
        Wt = "[object Undefined]"
      var qt = Bt ? Bt.toStringTag : undefined
      function $t(t) {
        if (t == null) {
          return t === undefined ? Wt : Ht
        }
        return qt && qt in Object(t) ? Nt(t) : jt(t)
      }
      const Kt = $t
      var Gt = Array.isArray
      const Ut = Gt
      function Jt(t) {
        return t != null && typeof t == "object"
      }
      const Zt = Jt
      var Yt = "[object String]"
      function Qt(t) {
        return typeof t == "string" || (!Ut(t) && Zt(t) && Kt(t) == Yt)
      }
      const Xt = Qt
      function te(t, e, n = {}, o = []) {
        const r = n && n.xmlns
        const i = r ? t.createElementNS(r, e) : t.createElement(e)
        for (const t in n) {
          i.setAttribute(t, n[t])
        }
        if (Xt(o) || !yt(o)) {
          o = [o]
        }
        for (let e of o) {
          if (Xt(e)) {
            e = t.createTextNode(e)
          }
          i.appendChild(e)
        }
        return i
      }
      function ee(t, e) {
        return function (n) {
          return t(e(n))
        }
      }
      const ne = ee
      var oe = ne(Object.getPrototypeOf, Object)
      const re = oe
      var ie = "[object Object]"
      var se = Function.prototype,
        ae = Object.prototype
      var ce = se.toString
      var le = ae.hasOwnProperty
      var de = ce.call(Object)
      function he(t) {
        if (!Zt(t) || Kt(t) != ie) {
          return false
        }
        var e = re(t)
        if (e === null) {
          return true
        }
        var n = le.call(e, "constructor") && e.constructor
        return typeof n == "function" && n instanceof n && ce.call(n) == de
      }
      const ue = he
      function fe() {
        this.__data__ = []
        this.size = 0
      }
      const pe = fe
      function ge(t, e) {
        return t === e || (t !== t && e !== e)
      }
      const me = ge
      function ke(t, e) {
        var n = t.length
        while (n--) {
          if (me(t[n][0], e)) {
            return n
          }
        }
        return -1
      }
      const be = ke
      var we = Array.prototype
      var _e = we.splice
      function ve(t) {
        var e = this.__data__,
          n = be(e, t)
        if (n < 0) {
          return false
        }
        var o = e.length - 1
        if (n == o) {
          e.pop()
        } else {
          _e.call(e, n, 1)
        }
        --this.size
        return true
      }
      const Ae = ve
      function Ce(t) {
        var e = this.__data__,
          n = be(e, t)
        return n < 0 ? undefined : e[n][1]
      }
      const ye = Ce
      function xe(t) {
        return be(this.__data__, t) > -1
      }
      const Ee = xe
      function De(t, e) {
        var n = this.__data__,
          o = be(n, t)
        if (o < 0) {
          ++this.size
          n.push([t, e])
        } else {
          n[o][1] = e
        }
        return this
      }
      const Se = De
      function Te(t) {
        var e = -1,
          n = t == null ? 0 : t.length
        this.clear()
        while (++e < n) {
          var o = t[e]
          this.set(o[0], o[1])
        }
      }
      Te.prototype.clear = pe
      Te.prototype["delete"] = Ae
      Te.prototype.get = ye
      Te.prototype.has = Ee
      Te.prototype.set = Se
      const Pe = Te
      function Be() {
        this.__data__ = new Pe()
        this.size = 0
      }
      const Re = Be
      function Oe(t) {
        var e = this.__data__,
          n = e["delete"](t)
        this.size = e.size
        return n
      }
      const Me = Oe
      function Ie(t) {
        return this.__data__.get(t)
      }
      const ze = Ie
      function Ne(t) {
        return this.__data__.has(t)
      }
      const Fe = Ne
      var Ve = "[object AsyncFunction]",
        Le = "[object Function]",
        je = "[object GeneratorFunction]",
        He = "[object Proxy]"
      function We(t) {
        if (!ot(t)) {
          return false
        }
        var e = Kt(t)
        return e == Le || e == je || e == Ve || e == He
      }
      const qe = We
      var $e = Tt["__core-js_shared__"]
      const Ke = $e
      var Ge = (function () {
        var t = /[^.]+$/.exec((Ke && Ke.keys && Ke.keys.IE_PROTO) || "")
        return t ? "Symbol(src)_1." + t : ""
      })()
      function Ue(t) {
        return !!Ge && Ge in t
      }
      const Je = Ue
      var Ze = Function.prototype
      var Ye = Ze.toString
      function Qe(t) {
        if (t != null) {
          try {
            return Ye.call(t)
          } catch (t) {}
          try {
            return t + ""
          } catch (t) {}
        }
        return ""
      }
      const Xe = Qe
      var tn = /[\\^$.*+?()[\]{}|]/g
      var en = /^\[object .+?Constructor\]$/
      var nn = Function.prototype,
        on = Object.prototype
      var rn = nn.toString
      var sn = on.hasOwnProperty
      var an = RegExp(
        "^" +
          rn
            .call(sn)
            .replace(tn, "\\$&")
            .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") +
          "$"
      )
      function cn(t) {
        if (!ot(t) || Je(t)) {
          return false
        }
        var e = qe(t) ? an : en
        return e.test(Xe(t))
      }
      const ln = cn
      function dn(t, e) {
        return t == null ? undefined : t[e]
      }
      const hn = dn
      function un(t, e) {
        var n = hn(t, e)
        return ln(n) ? n : undefined
      }
      const fn = un
      var pn = fn(Tt, "Map")
      const gn = pn
      var mn = fn(Object, "create")
      const kn = mn
      function bn() {
        this.__data__ = kn ? kn(null) : {}
        this.size = 0
      }
      const wn = bn
      function _n(t) {
        var e = this.has(t) && delete this.__data__[t]
        this.size -= e ? 1 : 0
        return e
      }
      const vn = _n
      var An = "__lodash_hash_undefined__"
      var Cn = Object.prototype
      var yn = Cn.hasOwnProperty
      function xn(t) {
        var e = this.__data__
        if (kn) {
          var n = e[t]
          return n === An ? undefined : n
        }
        return yn.call(e, t) ? e[t] : undefined
      }
      const En = xn
      var Dn = Object.prototype
      var Sn = Dn.hasOwnProperty
      function Tn(t) {
        var e = this.__data__
        return kn ? e[t] !== undefined : Sn.call(e, t)
      }
      const Pn = Tn
      var Bn = "__lodash_hash_undefined__"
      function Rn(t, e) {
        var n = this.__data__
        this.size += this.has(t) ? 0 : 1
        n[t] = kn && e === undefined ? Bn : e
        return this
      }
      const On = Rn
      function Mn(t) {
        var e = -1,
          n = t == null ? 0 : t.length
        this.clear()
        while (++e < n) {
          var o = t[e]
          this.set(o[0], o[1])
        }
      }
      Mn.prototype.clear = wn
      Mn.prototype["delete"] = vn
      Mn.prototype.get = En
      Mn.prototype.has = Pn
      Mn.prototype.set = On
      const In = Mn
      function zn() {
        this.size = 0
        this.__data__ = { hash: new In(), map: new (gn || Pe)(), string: new In() }
      }
      const Nn = zn
      function Fn(t) {
        var e = typeof t
        return e == "string" || e == "number" || e == "symbol" || e == "boolean"
          ? t !== "__proto__"
          : t === null
      }
      const Vn = Fn
      function Ln(t, e) {
        var n = t.__data__
        return Vn(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map
      }
      const jn = Ln
      function Hn(t) {
        var e = jn(this, t)["delete"](t)
        this.size -= e ? 1 : 0
        return e
      }
      const Wn = Hn
      function qn(t) {
        return jn(this, t).get(t)
      }
      const $n = qn
      function Kn(t) {
        return jn(this, t).has(t)
      }
      const Gn = Kn
      function Un(t, e) {
        var n = jn(this, t),
          o = n.size
        n.set(t, e)
        this.size += n.size == o ? 0 : 1
        return this
      }
      const Jn = Un
      function Zn(t) {
        var e = -1,
          n = t == null ? 0 : t.length
        this.clear()
        while (++e < n) {
          var o = t[e]
          this.set(o[0], o[1])
        }
      }
      Zn.prototype.clear = Nn
      Zn.prototype["delete"] = Wn
      Zn.prototype.get = $n
      Zn.prototype.has = Gn
      Zn.prototype.set = Jn
      const Yn = Zn
      var Qn = 200
      function Xn(t, e) {
        var n = this.__data__
        if (n instanceof Pe) {
          var o = n.__data__
          if (!gn || o.length < Qn - 1) {
            o.push([t, e])
            this.size = ++n.size
            return this
          }
          n = this.__data__ = new Yn(o)
        }
        n.set(t, e)
        this.size = n.size
        return this
      }
      const to = Xn
      function eo(t) {
        var e = (this.__data__ = new Pe(t))
        this.size = e.size
      }
      eo.prototype.clear = Re
      eo.prototype["delete"] = Me
      eo.prototype.get = ze
      eo.prototype.has = Fe
      eo.prototype.set = to
      const no = eo
      function oo(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length
        while (++n < o) {
          if (e(t[n], n, t) === false) {
            break
          }
        }
        return t
      }
      const ro = oo
      var io = (function () {
        try {
          var t = fn(Object, "defineProperty")
          t({}, "", {})
          return t
        } catch (t) {}
      })()
      const so = io
      function ao(t, e, n) {
        if (e == "__proto__" && so) {
          so(t, e, { configurable: true, enumerable: true, value: n, writable: true })
        } else {
          t[e] = n
        }
      }
      const co = ao
      var lo = Object.prototype
      var ho = lo.hasOwnProperty
      function uo(t, e, n) {
        var o = t[e]
        if (!(ho.call(t, e) && me(o, n)) || (n === undefined && !(e in t))) {
          co(t, e, n)
        }
      }
      const fo = uo
      function po(t, e, n, o) {
        var r = !n
        n || (n = {})
        var i = -1,
          s = e.length
        while (++i < s) {
          var a = e[i]
          var c = o ? o(n[a], t[a], a, n, t) : undefined
          if (c === undefined) {
            c = t[a]
          }
          if (r) {
            co(n, a, c)
          } else {
            fo(n, a, c)
          }
        }
        return n
      }
      const go = po
      function mo(t, e) {
        var n = -1,
          o = Array(t)
        while (++n < t) {
          o[n] = e(n)
        }
        return o
      }
      const ko = mo
      var bo = "[object Arguments]"
      function wo(t) {
        return Zt(t) && Kt(t) == bo
      }
      const _o = wo
      var vo = Object.prototype
      var Ao = vo.hasOwnProperty
      var Co = vo.propertyIsEnumerable
      var yo = _o(
        (function () {
          return arguments
        })()
      )
        ? _o
        : function (t) {
            return Zt(t) && Ao.call(t, "callee") && !Co.call(t, "callee")
          }
      const xo = yo
      function Eo() {
        return false
      }
      const Do = Eo
      var So = typeof exports == "object" && exports && !exports.nodeType && exports
      var To = So && typeof module == "object" && module && !module.nodeType && module
      var Po = To && To.exports === So
      var Bo = Po ? Tt.Buffer : undefined
      var Ro = Bo ? Bo.isBuffer : undefined
      var Oo = Ro || Do
      const Mo = Oo
      var Io = 9007199254740991
      var zo = /^(?:0|[1-9]\d*)$/
      function No(t, e) {
        var n = typeof t
        e = e == null ? Io : e
        return (
          !!e && (n == "number" || (n != "symbol" && zo.test(t))) && t > -1 && t % 1 == 0 && t < e
        )
      }
      const Fo = No
      var Vo = 9007199254740991
      function Lo(t) {
        return typeof t == "number" && t > -1 && t % 1 == 0 && t <= Vo
      }
      const jo = Lo
      var Ho = "[object Arguments]",
        Wo = "[object Array]",
        qo = "[object Boolean]",
        $o = "[object Date]",
        Ko = "[object Error]",
        Go = "[object Function]",
        Uo = "[object Map]",
        Jo = "[object Number]",
        Zo = "[object Object]",
        Yo = "[object RegExp]",
        Qo = "[object Set]",
        Xo = "[object String]",
        tr = "[object WeakMap]"
      var er = "[object ArrayBuffer]",
        nr = "[object DataView]",
        or = "[object Float32Array]",
        rr = "[object Float64Array]",
        ir = "[object Int8Array]",
        sr = "[object Int16Array]",
        ar = "[object Int32Array]",
        cr = "[object Uint8Array]",
        lr = "[object Uint8ClampedArray]",
        dr = "[object Uint16Array]",
        hr = "[object Uint32Array]"
      var ur = {}
      ur[or] = ur[rr] = ur[ir] = ur[sr] = ur[ar] = ur[cr] = ur[lr] = ur[dr] = ur[hr] = true
      ur[Ho] =
        ur[Wo] =
        ur[er] =
        ur[qo] =
        ur[nr] =
        ur[$o] =
        ur[Ko] =
        ur[Go] =
        ur[Uo] =
        ur[Jo] =
        ur[Zo] =
        ur[Yo] =
        ur[Qo] =
        ur[Xo] =
        ur[tr] =
          false
      function fr(t) {
        return Zt(t) && jo(t.length) && !!ur[Kt(t)]
      }
      const pr = fr
      function gr(t) {
        return function (e) {
          return t(e)
        }
      }
      const mr = gr
      var kr = typeof exports == "object" && exports && !exports.nodeType && exports
      var br = kr && typeof module == "object" && module && !module.nodeType && module
      var wr = br && br.exports === kr
      var _r = wr && Et.process
      var vr = (function () {
        try {
          var t = br && br.require && br.require("util").types
          if (t) {
            return t
          }
          return _r && _r.binding && _r.binding("util")
        } catch (t) {}
      })()
      const Ar = vr
      var Cr = Ar && Ar.isTypedArray
      var yr = Cr ? mr(Cr) : pr
      const xr = yr
      var Er = Object.prototype
      var Dr = Er.hasOwnProperty
      function Sr(t, e) {
        var n = Ut(t),
          o = !n && xo(t),
          r = !n && !o && Mo(t),
          i = !n && !o && !r && xr(t),
          s = n || o || r || i,
          a = s ? ko(t.length, String) : [],
          c = a.length
        for (var l in t) {
          if (
            (e || Dr.call(t, l)) &&
            !(
              s &&
              (l == "length" ||
                (r && (l == "offset" || l == "parent")) ||
                (i && (l == "buffer" || l == "byteLength" || l == "byteOffset")) ||
                Fo(l, c))
            )
          ) {
            a.push(l)
          }
        }
        return a
      }
      const Tr = Sr
      var Pr = Object.prototype
      function Br(t) {
        var e = t && t.constructor,
          n = (typeof e == "function" && e.prototype) || Pr
        return t === n
      }
      const Rr = Br
      var Or = ne(Object.keys, Object)
      const Mr = Or
      var Ir = Object.prototype
      var zr = Ir.hasOwnProperty
      function Nr(t) {
        if (!Rr(t)) {
          return Mr(t)
        }
        var e = []
        for (var n in Object(t)) {
          if (zr.call(t, n) && n != "constructor") {
            e.push(n)
          }
        }
        return e
      }
      const Fr = Nr
      function Vr(t) {
        return t != null && jo(t.length) && !qe(t)
      }
      const Lr = Vr
      function jr(t) {
        return Lr(t) ? Tr(t) : Fr(t)
      }
      const Hr = jr
      function Wr(t, e) {
        return t && go(e, Hr(e), t)
      }
      const qr = Wr
      function $r(t) {
        var e = []
        if (t != null) {
          for (var n in Object(t)) {
            e.push(n)
          }
        }
        return e
      }
      const Kr = $r
      var Gr = Object.prototype
      var Ur = Gr.hasOwnProperty
      function Jr(t) {
        if (!ot(t)) {
          return Kr(t)
        }
        var e = Rr(t),
          n = []
        for (var o in t) {
          if (!(o == "constructor" && (e || !Ur.call(t, o)))) {
            n.push(o)
          }
        }
        return n
      }
      const Zr = Jr
      function Yr(t) {
        return Lr(t) ? Tr(t, true) : Zr(t)
      }
      const Qr = Yr
      function Xr(t, e) {
        return t && go(e, Qr(e), t)
      }
      const ti = Xr
      var ei = typeof exports == "object" && exports && !exports.nodeType && exports
      var ni = ei && typeof module == "object" && module && !module.nodeType && module
      var oi = ni && ni.exports === ei
      var ri = oi ? Tt.Buffer : undefined,
        ii = ri ? ri.allocUnsafe : undefined
      function si(t, e) {
        if (e) {
          return t.slice()
        }
        var n = t.length,
          o = ii ? ii(n) : new t.constructor(n)
        t.copy(o)
        return o
      }
      const ai = si
      function ci(t, e) {
        var n = -1,
          o = t.length
        e || (e = Array(o))
        while (++n < o) {
          e[n] = t[n]
        }
        return e
      }
      const li = ci
      function di(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length,
          r = 0,
          i = []
        while (++n < o) {
          var s = t[n]
          if (e(s, n, t)) {
            i[r++] = s
          }
        }
        return i
      }
      const hi = di
      function ui() {
        return []
      }
      const fi = ui
      var pi = Object.prototype
      var gi = pi.propertyIsEnumerable
      var mi = Object.getOwnPropertySymbols
      var ki = !mi
        ? fi
        : function (t) {
            if (t == null) {
              return []
            }
            t = Object(t)
            return hi(mi(t), function (e) {
              return gi.call(t, e)
            })
          }
      const bi = ki
      function wi(t, e) {
        return go(t, bi(t), e)
      }
      const _i = wi
      function vi(t, e) {
        var n = -1,
          o = e.length,
          r = t.length
        while (++n < o) {
          t[r + n] = e[n]
        }
        return t
      }
      const Ai = vi
      var Ci = Object.getOwnPropertySymbols
      var yi = !Ci
        ? fi
        : function (t) {
            var e = []
            while (t) {
              Ai(e, bi(t))
              t = re(t)
            }
            return e
          }
      const xi = yi
      function Ei(t, e) {
        return go(t, xi(t), e)
      }
      const Di = Ei
      function Si(t, e, n) {
        var o = e(t)
        return Ut(t) ? o : Ai(o, n(t))
      }
      const Ti = Si
      function Pi(t) {
        return Ti(t, Hr, bi)
      }
      const Bi = Pi
      function Ri(t) {
        return Ti(t, Qr, xi)
      }
      const Oi = Ri
      var Mi = fn(Tt, "DataView")
      const Ii = Mi
      var zi = fn(Tt, "Promise")
      const Ni = zi
      var Fi = fn(Tt, "Set")
      const Vi = Fi
      var Li = fn(Tt, "WeakMap")
      const ji = Li
      var Hi = "[object Map]",
        Wi = "[object Object]",
        qi = "[object Promise]",
        $i = "[object Set]",
        Ki = "[object WeakMap]"
      var Gi = "[object DataView]"
      var Ui = Xe(Ii),
        Ji = Xe(gn),
        Zi = Xe(Ni),
        Yi = Xe(Vi),
        Qi = Xe(ji)
      var Xi = Kt
      if (
        (Ii && Xi(new Ii(new ArrayBuffer(1))) != Gi) ||
        (gn && Xi(new gn()) != Hi) ||
        (Ni && Xi(Ni.resolve()) != qi) ||
        (Vi && Xi(new Vi()) != $i) ||
        (ji && Xi(new ji()) != Ki)
      ) {
        Xi = function (t) {
          var e = Kt(t),
            n = e == Wi ? t.constructor : undefined,
            o = n ? Xe(n) : ""
          if (o) {
            switch (o) {
              case Ui:
                return Gi
              case Ji:
                return Hi
              case Zi:
                return qi
              case Yi:
                return $i
              case Qi:
                return Ki
            }
          }
          return e
        }
      }
      const ts = Xi
      var es = Object.prototype
      var ns = es.hasOwnProperty
      function os(t) {
        var e = t.length,
          n = new t.constructor(e)
        if (e && typeof t[0] == "string" && ns.call(t, "index")) {
          n.index = t.index
          n.input = t.input
        }
        return n
      }
      const rs = os
      var is = Tt.Uint8Array
      const ss = is
      function as(t) {
        var e = new t.constructor(t.byteLength)
        new ss(e).set(new ss(t))
        return e
      }
      const cs = as
      function ls(t, e) {
        var n = e ? cs(t.buffer) : t.buffer
        return new t.constructor(n, t.byteOffset, t.byteLength)
      }
      const ds = ls
      var hs = /\w*$/
      function us(t) {
        var e = new t.constructor(t.source, hs.exec(t))
        e.lastIndex = t.lastIndex
        return e
      }
      const fs = us
      var ps = Bt ? Bt.prototype : undefined,
        gs = ps ? ps.valueOf : undefined
      function ms(t) {
        return gs ? Object(gs.call(t)) : {}
      }
      const ks = ms
      function bs(t, e) {
        var n = e ? cs(t.buffer) : t.buffer
        return new t.constructor(n, t.byteOffset, t.length)
      }
      const ws = bs
      var _s = "[object Boolean]",
        vs = "[object Date]",
        As = "[object Map]",
        Cs = "[object Number]",
        ys = "[object RegExp]",
        xs = "[object Set]",
        Es = "[object String]",
        Ds = "[object Symbol]"
      var Ss = "[object ArrayBuffer]",
        Ts = "[object DataView]",
        Ps = "[object Float32Array]",
        Bs = "[object Float64Array]",
        Rs = "[object Int8Array]",
        Os = "[object Int16Array]",
        Ms = "[object Int32Array]",
        Is = "[object Uint8Array]",
        zs = "[object Uint8ClampedArray]",
        Ns = "[object Uint16Array]",
        Fs = "[object Uint32Array]"
      function Vs(t, e, n) {
        var o = t.constructor
        switch (e) {
          case Ss:
            return cs(t)
          case _s:
          case vs:
            return new o(+t)
          case Ts:
            return ds(t, n)
          case Ps:
          case Bs:
          case Rs:
          case Os:
          case Ms:
          case Is:
          case zs:
          case Ns:
          case Fs:
            return ws(t, n)
          case As:
            return new o()
          case Cs:
          case Es:
            return new o(t)
          case ys:
            return fs(t)
          case xs:
            return new o()
          case Ds:
            return ks(t)
        }
      }
      const Ls = Vs
      var js = Object.create
      var Hs = (function () {
        function t() {}
        return function (e) {
          if (!ot(e)) {
            return {}
          }
          if (js) {
            return js(e)
          }
          t.prototype = e
          var n = new t()
          t.prototype = undefined
          return n
        }
      })()
      const Ws = Hs
      function qs(t) {
        return typeof t.constructor == "function" && !Rr(t) ? Ws(re(t)) : {}
      }
      const $s = qs
      var Ks = "[object Map]"
      function Gs(t) {
        return Zt(t) && ts(t) == Ks
      }
      const Us = Gs
      var Js = Ar && Ar.isMap
      var Zs = Js ? mr(Js) : Us
      const Ys = Zs
      var Qs = "[object Set]"
      function Xs(t) {
        return Zt(t) && ts(t) == Qs
      }
      const ta = Xs
      var ea = Ar && Ar.isSet
      var na = ea ? mr(ea) : ta
      const oa = na
      var ra = 1,
        ia = 2,
        sa = 4
      var aa = "[object Arguments]",
        ca = "[object Array]",
        la = "[object Boolean]",
        da = "[object Date]",
        ha = "[object Error]",
        ua = "[object Function]",
        fa = "[object GeneratorFunction]",
        pa = "[object Map]",
        ga = "[object Number]",
        ma = "[object Object]",
        ka = "[object RegExp]",
        ba = "[object Set]",
        wa = "[object String]",
        _a = "[object Symbol]",
        va = "[object WeakMap]"
      var Aa = "[object ArrayBuffer]",
        Ca = "[object DataView]",
        ya = "[object Float32Array]",
        xa = "[object Float64Array]",
        Ea = "[object Int8Array]",
        Da = "[object Int16Array]",
        Sa = "[object Int32Array]",
        Ta = "[object Uint8Array]",
        Pa = "[object Uint8ClampedArray]",
        Ba = "[object Uint16Array]",
        Ra = "[object Uint32Array]"
      var Oa = {}
      Oa[aa] =
        Oa[ca] =
        Oa[Aa] =
        Oa[Ca] =
        Oa[la] =
        Oa[da] =
        Oa[ya] =
        Oa[xa] =
        Oa[Ea] =
        Oa[Da] =
        Oa[Sa] =
        Oa[pa] =
        Oa[ga] =
        Oa[ma] =
        Oa[ka] =
        Oa[ba] =
        Oa[wa] =
        Oa[_a] =
        Oa[Ta] =
        Oa[Pa] =
        Oa[Ba] =
        Oa[Ra] =
          true
      Oa[ha] = Oa[ua] = Oa[va] = false
      function Ma(t, e, n, o, r, i) {
        var s,
          a = e & ra,
          c = e & ia,
          l = e & sa
        if (n) {
          s = r ? n(t, o, r, i) : n(t)
        }
        if (s !== undefined) {
          return s
        }
        if (!ot(t)) {
          return t
        }
        var d = Ut(t)
        if (d) {
          s = rs(t)
          if (!a) {
            return li(t, s)
          }
        } else {
          var h = ts(t),
            u = h == ua || h == fa
          if (Mo(t)) {
            return ai(t, a)
          }
          if (h == ma || h == aa || (u && !r)) {
            s = c || u ? {} : $s(t)
            if (!a) {
              return c ? Di(t, ti(s, t)) : _i(t, qr(s, t))
            }
          } else {
            if (!Oa[h]) {
              return r ? t : {}
            }
            s = Ls(t, h, a)
          }
        }
        i || (i = new no())
        var f = i.get(t)
        if (f) {
          return f
        }
        i.set(t, s)
        if (oa(t)) {
          t.forEach(function (o) {
            s.add(Ma(o, e, n, o, t, i))
          })
        } else if (Ys(t)) {
          t.forEach(function (o, r) {
            s.set(r, Ma(o, e, n, r, t, i))
          })
        }
        var p = l ? (c ? Oi : Bi) : c ? Qr : Hr
        var g = d ? undefined : p(t)
        ro(g || t, function (o, r) {
          if (g) {
            r = o
            o = t[r]
          }
          fo(s, r, Ma(o, e, n, r, t, i))
        })
        return s
      }
      const Ia = Ma
      var za = 1,
        Na = 4
      function Fa(t, e) {
        e = typeof e == "function" ? e : undefined
        return Ia(t, za | Na, e)
      }
      const Va = Fa
      function La(t) {
        return Zt(t) && t.nodeType === 1 && !ue(t)
      }
      const ja = La
      class Ha {
        constructor(t, e) {
          this._config = {}
          if (e) {
            this.define(Wa(e))
          }
          if (t) {
            this._setObjectToTarget(this._config, t)
          }
        }
        set(t, e) {
          this._setToTarget(this._config, t, e)
        }
        define(t, e) {
          const n = true
          this._setToTarget(this._config, t, e, n)
        }
        get(t) {
          return this._getFromSource(this._config, t)
        }
        *names() {
          for (const t of Object.keys(this._config)) {
            yield t
          }
        }
        _setToTarget(t, e, n, o = false) {
          if (ue(e)) {
            this._setObjectToTarget(t, e, o)
            return
          }
          const r = e.split(".")
          e = r.pop()
          for (const e of r) {
            if (!ue(t[e])) {
              t[e] = {}
            }
            t = t[e]
          }
          if (ue(n)) {
            if (!ue(t[e])) {
              t[e] = {}
            }
            t = t[e]
            this._setObjectToTarget(t, n, o)
            return
          }
          if (o && typeof t[e] != "undefined") {
            return
          }
          t[e] = n
        }
        _getFromSource(t, e) {
          const n = e.split(".")
          e = n.pop()
          for (const e of n) {
            if (!ue(t[e])) {
              t = null
              break
            }
            t = t[e]
          }
          return t ? Wa(t[e]) : undefined
        }
        _setObjectToTarget(t, e, n) {
          Object.keys(e).forEach((o) => {
            this._setToTarget(t, o, e[o], n)
          })
        }
      }
      function Wa(t) {
        return Va(t, qa)
      }
      function qa(t) {
        return ja(t) ? t : undefined
      }
      function $a(t) {
        if (t) {
          if (t.defaultView) {
            return t instanceof t.defaultView.Document
          } else if (t.ownerDocument && t.ownerDocument.defaultView) {
            return t instanceof t.ownerDocument.defaultView.Node
          }
        }
        return false
      }
      function Ka(t) {
        const e = Object.prototype.toString.apply(t)
        if (e == "[object Window]") {
          return true
        }
        if (e == "[object global]") {
          return true
        }
        return false
      }
      const Ga = Ua(q())
      function Ua(t) {
        if (!t) {
          return Ga
        }
        class e extends t {
          listenTo(t, e, n, o = {}) {
            if ($a(t) || Ka(t)) {
              const r = { capture: !!o.useCapture, passive: !!o.usePassive }
              const i = this._getProxyEmitter(t, r) || new Ja(t, r)
              this.listenTo(i, e, n, o)
            } else {
              super.listenTo(t, e, n, o)
            }
          }
          stopListening(t, e, n) {
            if ($a(t) || Ka(t)) {
              const o = this._getAllProxyEmitters(t)
              for (const t of o) {
                this.stopListening(t, e, n)
              }
            } else {
              super.stopListening(t, e, n)
            }
          }
          _getProxyEmitter(t, e) {
            return $(this, Ya(t, e))
          }
          _getAllProxyEmitters(t) {
            return [
              { capture: false, passive: false },
              { capture: false, passive: true },
              { capture: true, passive: false },
              { capture: true, passive: true },
            ]
              .map((e) => this._getProxyEmitter(t, e))
              .filter((t) => !!t)
          }
        }
        return e
      }
      ;[
        "_getProxyEmitter",
        "_getAllProxyEmitters",
        "on",
        "once",
        "off",
        "listenTo",
        "stopListening",
        "fire",
        "delegate",
        "stopDelegating",
        "_addEventListener",
        "_removeEventListener",
      ].forEach((t) => {
        Ua[t] = Ga.prototype[t]
      })
      class Ja extends q() {
        constructor(t, e) {
          super()
          K(this, Ya(t, e))
          this._domNode = t
          this._options = e
        }
        attach(t) {
          if (this._domListeners && this._domListeners[t]) {
            return
          }
          const e = this._createDomListener(t)
          this._domNode.addEventListener(t, e, this._options)
          if (!this._domListeners) {
            this._domListeners = {}
          }
          this._domListeners[t] = e
        }
        detach(t) {
          let e
          if (this._domListeners[t] && (!(e = this._events[t]) || !e.callbacks.length)) {
            this._domListeners[t].removeListener()
          }
        }
        _addEventListener(t, e, n) {
          this.attach(t)
          q().prototype._addEventListener.call(this, t, e, n)
        }
        _removeEventListener(t, e) {
          q().prototype._removeEventListener.call(this, t, e)
          this.detach(t)
        }
        _createDomListener(t) {
          const e = (e) => {
            this.fire(t, e)
          }
          e.removeListener = () => {
            this._domNode.removeEventListener(t, e, this._options)
            delete this._domListeners[t]
          }
          return e
        }
      }
      function Za(t) {
        return t["data-ck-expando"] || (t["data-ck-expando"] = x())
      }
      function Ya(t, e) {
        let n = Za(t)
        for (const t of Object.keys(e).sort()) {
          if (e[t]) {
            n += "-" + t
          }
        }
        return n
      }
      let Qa
      try {
        Qa = { window, document }
      } catch (t) {
        Qa = { window: {}, document: {} }
      }
      const Xa = Qa
      function tc(t) {
        let e = t.parentElement
        if (!e) {
          return null
        }
        while (e.tagName != "BODY") {
          const t = e.style.overflowY || Xa.window.getComputedStyle(e).overflowY
          if (t === "auto" || t === "scroll") {
            break
          }
          e = e.parentElement
          if (!e) {
            return null
          }
        }
        return e
      }
      function ec(t) {
        const e = []
        let n = t
        while (n && n.nodeType != Node.DOCUMENT_NODE) {
          e.unshift(n)
          n = n.parentNode
        }
        return e
      }
      function nc(t) {
        if (t instanceof HTMLTextAreaElement) {
          return t.value
        }
        return t.innerHTML
      }
      function oc(t) {
        return Object.prototype.toString.call(t) == "[object Text]"
      }
      function rc(t) {
        return Object.prototype.toString.apply(t) == "[object Range]"
      }
      function ic(t) {
        const e = t.ownerDocument.defaultView.getComputedStyle(t)
        return {
          top: parseInt(e.borderTopWidth, 10),
          right: parseInt(e.borderRightWidth, 10),
          bottom: parseInt(e.borderBottomWidth, 10),
          left: parseInt(e.borderLeftWidth, 10),
        }
      }
      const sc = ["top", "right", "bottom", "left", "width", "height"]
      class ac {
        constructor(t) {
          const e = rc(t)
          Object.defineProperty(this, "_source", {
            value: t._source || t,
            writable: true,
            enumerable: false,
          })
          if (dc(t) || e) {
            if (e) {
              const e = ac.getDomRangeRects(t)
              cc(this, ac.getBoundingRect(e))
            } else {
              cc(this, t.getBoundingClientRect())
            }
          } else if (Ka(t)) {
            const { innerWidth: e, innerHeight: n } = t
            cc(this, { top: 0, right: e, bottom: n, left: 0, width: e, height: n })
          } else {
            cc(this, t)
          }
        }
        clone() {
          return new ac(this)
        }
        moveTo(t, e) {
          this.top = e
          this.right = t + this.width
          this.bottom = e + this.height
          this.left = t
          return this
        }
        moveBy(t, e) {
          this.top += e
          this.right += t
          this.left += t
          this.bottom += e
          return this
        }
        getIntersection(t) {
          const e = {
            top: Math.max(this.top, t.top),
            right: Math.min(this.right, t.right),
            bottom: Math.min(this.bottom, t.bottom),
            left: Math.max(this.left, t.left),
            width: 0,
            height: 0,
          }
          e.width = e.right - e.left
          e.height = e.bottom - e.top
          if (e.width < 0 || e.height < 0) {
            return null
          } else {
            return new ac(e)
          }
        }
        getIntersectionArea(t) {
          const e = this.getIntersection(t)
          if (e) {
            return e.getArea()
          } else {
            return 0
          }
        }
        getArea() {
          return this.width * this.height
        }
        getVisible() {
          const t = this._source
          let e = this.clone()
          if (lc(t)) {
            return e
          }
          let n = t
          let o = t.parentNode || t.commonAncestorContainer
          let r
          while (o && !lc(o)) {
            if (n instanceof HTMLElement && hc(n) === "absolute") {
              r = n
            }
            if (r && (hc(o) !== "relative" || uc(o) === "visible")) {
              n = o
              o = o.parentNode
              continue
            }
            const t = new ac(o)
            const i = e.getIntersection(t)
            if (i) {
              if (i.getArea() < e.getArea()) {
                e = i
              }
            } else {
              return null
            }
            n = o
            o = o.parentNode
          }
          return e
        }
        isEqual(t) {
          for (const e of sc) {
            if (this[e] !== t[e]) {
              return false
            }
          }
          return true
        }
        contains(t) {
          const e = this.getIntersection(t)
          return !!(e && e.isEqual(t))
        }
        excludeScrollbarsAndBorders() {
          const t = this._source
          let e, n, o
          if (Ka(t)) {
            e = t.innerWidth - t.document.documentElement.clientWidth
            n = t.innerHeight - t.document.documentElement.clientHeight
            o = t.getComputedStyle(t.document.documentElement).direction
          } else {
            const r = ic(t)
            e = t.offsetWidth - t.clientWidth - r.left - r.right
            n = t.offsetHeight - t.clientHeight - r.top - r.bottom
            o = t.ownerDocument.defaultView.getComputedStyle(t).direction
            this.left += r.left
            this.top += r.top
            this.right -= r.right
            this.bottom -= r.bottom
            this.width = this.right - this.left
            this.height = this.bottom - this.top
          }
          this.width -= e
          if (o === "ltr") {
            this.right -= e
          } else {
            this.left += e
          }
          this.height -= n
          this.bottom -= n
          return this
        }
        static getDomRangeRects(t) {
          const e = []
          const n = Array.from(t.getClientRects())
          if (n.length) {
            for (const t of n) {
              e.push(new ac(t))
            }
          } else {
            let n = t.startContainer
            if (oc(n)) {
              n = n.parentNode
            }
            const o = new ac(n.getBoundingClientRect())
            o.right = o.left
            o.width = 0
            e.push(o)
          }
          return e
        }
        static getBoundingRect(t) {
          const e = {
            left: Number.POSITIVE_INFINITY,
            top: Number.POSITIVE_INFINITY,
            right: Number.NEGATIVE_INFINITY,
            bottom: Number.NEGATIVE_INFINITY,
            width: 0,
            height: 0,
          }
          let n = 0
          for (const o of t) {
            n++
            e.left = Math.min(e.left, o.left)
            e.top = Math.min(e.top, o.top)
            e.right = Math.max(e.right, o.right)
            e.bottom = Math.max(e.bottom, o.bottom)
          }
          if (n == 0) {
            return null
          }
          e.width = e.right - e.left
          e.height = e.bottom - e.top
          return new ac(e)
        }
      }
      function cc(t, e) {
        for (const n of sc) {
          t[n] = e[n]
        }
      }
      function lc(t) {
        if (!dc(t)) {
          return false
        }
        return t === t.ownerDocument.body
      }
      function dc(t) {
        return (
          t !== null &&
          typeof t === "object" &&
          t.nodeType === 1 &&
          typeof t.getBoundingClientRect === "function"
        )
      }
      function hc(t) {
        return t.ownerDocument.defaultView.getComputedStyle(t).position
      }
      function uc(t) {
        return t.ownerDocument.defaultView.getComputedStyle(t).overflow
      }
      class fc {
        constructor(t, e) {
          if (!fc._observerInstance) {
            fc._createObserver()
          }
          this._element = t
          this._callback = e
          fc._addElementCallback(t, e)
          fc._observerInstance.observe(t)
        }
        get element() {
          return this._element
        }
        destroy() {
          fc._deleteElementCallback(this._element, this._callback)
        }
        static _addElementCallback(t, e) {
          if (!fc._elementCallbacks) {
            fc._elementCallbacks = new Map()
          }
          let n = fc._elementCallbacks.get(t)
          if (!n) {
            n = new Set()
            fc._elementCallbacks.set(t, n)
          }
          n.add(e)
        }
        static _deleteElementCallback(t, e) {
          const n = fc._getElementCallbacks(t)
          if (n) {
            n.delete(e)
            if (!n.size) {
              fc._elementCallbacks.delete(t)
              fc._observerInstance.unobserve(t)
            }
          }
          if (fc._elementCallbacks && !fc._elementCallbacks.size) {
            fc._observerInstance = null
            fc._elementCallbacks = null
          }
        }
        static _getElementCallbacks(t) {
          if (!fc._elementCallbacks) {
            return null
          }
          return fc._elementCallbacks.get(t)
        }
        static _createObserver() {
          fc._observerInstance = new Xa.window.ResizeObserver((t) => {
            for (const e of t) {
              const t = fc._getElementCallbacks(e.target)
              if (t) {
                for (const n of t) {
                  n(e)
                }
              }
            }
          })
        }
      }
      fc._observerInstance = null
      fc._elementCallbacks = null
      function pc(t, e) {
        if (t instanceof HTMLTextAreaElement) {
          t.value = e
        }
        t.innerHTML = e
      }
      function gc(t) {
        return (e) => e + t
      }
      function mc(t) {
        let e = 0
        while (t.previousSibling) {
          t = t.previousSibling
          e++
        }
        return e
      }
      function kc(t, e, n) {
        t.insertBefore(n, t.childNodes[e] || null)
      }
      function bc(t) {
        return t && t.nodeType === Node.COMMENT_NODE
      }
      function wc(t) {
        try {
          Xa.document.createAttribute(t)
        } catch (t) {
          return false
        }
        return true
      }
      function _c(t) {
        return !!(t && t.getClientRects && t.getClientRects().length)
      }
      function vc(t) {
        if (!t || !t.parentNode) {
          return null
        }
        if (t.offsetParent === Xa.document.body) {
          return null
        }
        return t.offsetParent
      }
      function Ac({
        element: t,
        target: e,
        positions: n,
        limiter: o,
        fitInViewport: r,
        viewportOffsetConfig: i,
      }) {
        if (qe(e)) {
          e = e()
        }
        if (qe(o)) {
          o = o()
        }
        const s = vc(t)
        const a = new ac(t)
        const c = new ac(e)
        let l
        const d = (r && Cc(i)) || null
        const h = { targetRect: c, elementRect: a, positionedElementAncestor: s, viewportRect: d }
        if (!o && !r) {
          l = new Dc(n[0], h)
        } else {
          const t = o && new ac(o).getVisible()
          Object.assign(h, { limiterRect: t, viewportRect: d })
          l = yc(n, h) || new Dc(n[0], h)
        }
        return l
      }
      function Cc(t) {
        t = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, t)
        const e = new ac(Xa.window)
        e.top += t.top
        e.height -= t.top
        e.bottom -= t.bottom
        e.height -= t.bottom
        return e
      }
      function yc(t, e) {
        const { elementRect: n } = e
        const o = n.getArea()
        const r = t.map((t) => new Dc(t, e)).filter((t) => !!t.name)
        let i = 0
        let s = null
        for (const t of r) {
          const { limiterIntersectionArea: e, viewportIntersectionArea: n } = t
          if (e === o) {
            return t
          }
          const r = n ** 2 + e ** 2
          if (r > i) {
            i = r
            s = t
          }
        }
        return s
      }
      function xc(t, e) {
        const n = Ec(new ac(e))
        const o = ic(e)
        let r = 0
        let i = 0
        r -= n.left
        i -= n.top
        r += e.scrollLeft
        i += e.scrollTop
        r -= o.left
        i -= o.top
        t.moveBy(r, i)
      }
      function Ec(t) {
        const { scrollX: e, scrollY: n } = Xa.window
        return t.clone().moveBy(e, n)
      }
      class Dc {
        constructor(t, e) {
          const n = t(e.targetRect, e.elementRect, e.viewportRect)
          if (!n) {
            return
          }
          const { left: o, top: r, name: i, config: s } = n
          this.name = i
          this.config = s
          this._positioningFunctionCorrdinates = { left: o, top: r }
          this._options = e
        }
        get left() {
          return this._absoluteRect.left
        }
        get top() {
          return this._absoluteRect.top
        }
        get limiterIntersectionArea() {
          const t = this._options.limiterRect
          if (t) {
            const e = this._options.viewportRect
            if (e) {
              const n = t.getIntersection(e)
              if (n) {
                return n.getIntersectionArea(this._rect)
              }
            } else {
              return t.getIntersectionArea(this._rect)
            }
          }
          return 0
        }
        get viewportIntersectionArea() {
          const t = this._options.viewportRect
          if (t) {
            return t.getIntersectionArea(this._rect)
          }
          return 0
        }
        get _rect() {
          if (this._cachedRect) {
            return this._cachedRect
          }
          this._cachedRect = this._options.elementRect
            .clone()
            .moveTo(
              this._positioningFunctionCorrdinates.left,
              this._positioningFunctionCorrdinates.top
            )
          return this._cachedRect
        }
        get _absoluteRect() {
          if (this._cachedAbsoluteRect) {
            return this._cachedAbsoluteRect
          }
          this._cachedAbsoluteRect = Ec(this._rect)
          if (this._options.positionedElementAncestor) {
            xc(this._cachedAbsoluteRect, this._options.positionedElementAncestor)
          }
          return this._cachedAbsoluteRect
        }
      }
      function Sc(t) {
        const e = t.parentNode
        if (e) {
          e.removeChild(t)
        }
      }
      function Tc({
        target: t,
        viewportOffset: e = 0,
        ancestorOffset: n = 0,
        alignToTop: o,
        forceScroll: r,
      }) {
        const i = Nc(t)
        let s = i
        let a = null
        e = Lc(e)
        while (s) {
          let c
          if (s == i) {
            c = Fc(t)
          } else {
            c = Fc(a)
          }
          Rc({
            parent: c,
            getRect: () => Vc(t, s),
            alignToTop: o,
            ancestorOffset: n,
            forceScroll: r,
          })
          const l = Vc(t, s)
          Bc({ window: s, rect: l, viewportOffset: e, alignToTop: o, forceScroll: r })
          if (s.parent != s) {
            a = s.frameElement
            s = s.parent
            if (!a) {
              return
            }
          } else {
            s = null
          }
        }
      }
      function Pc(t, e) {
        const n = Fc(t)
        Rc({ parent: n, getRect: () => new Rect(t), ancestorOffset: e })
      }
      function Bc({ window: t, rect: e, alignToTop: n, forceScroll: o, viewportOffset: r }) {
        const i = e.clone().moveBy(0, r.bottom)
        const s = e.clone().moveBy(0, -r.top)
        const a = new ac(t).excludeScrollbarsAndBorders()
        const c = [s, i]
        const l = n && o
        const d = c.every((t) => a.contains(t))
        let { scrollX: h, scrollY: u } = t
        const f = h
        const p = u
        if (l) {
          u -= a.top - e.top + r.top
        } else if (!d) {
          if (Mc(s, a)) {
            u -= a.top - e.top + r.top
          } else if (Oc(i, a)) {
            if (n) {
              u += e.top - a.top - r.top
            } else {
              u += e.bottom - a.bottom + r.bottom
            }
          }
        }
        if (!d) {
          if (Ic(e, a)) {
            h -= a.left - e.left + r.left
          } else if (zc(e, a)) {
            h += e.right - a.right + r.right
          }
        }
        if (h != f || u !== p) {
          t.scrollTo(h, u)
        }
      }
      function Rc({ parent: t, getRect: e, alignToTop: n, forceScroll: o, ancestorOffset: r = 0 }) {
        const i = Nc(t)
        const s = n && o
        let a, c, l
        while (t != i.document.body) {
          c = e()
          a = new ac(t).excludeScrollbarsAndBorders()
          l = a.contains(c)
          if (s) {
            t.scrollTop -= a.top - c.top + r
          } else if (!l) {
            if (Mc(c, a)) {
              t.scrollTop -= a.top - c.top + r
            } else if (Oc(c, a)) {
              if (n) {
                t.scrollTop += c.top - a.top - r
              } else {
                t.scrollTop += c.bottom - a.bottom + r
              }
            }
          }
          if (!l) {
            if (Ic(c, a)) {
              t.scrollLeft -= a.left - c.left + r
            } else if (zc(c, a)) {
              t.scrollLeft += c.right - a.right + r
            }
          }
          t = t.parentNode
        }
      }
      function Oc(t, e) {
        return t.bottom > e.bottom
      }
      function Mc(t, e) {
        return t.top < e.top
      }
      function Ic(t, e) {
        return t.left < e.left
      }
      function zc(t, e) {
        return t.right > e.right
      }
      function Nc(t) {
        if (rc(t)) {
          return t.startContainer.ownerDocument.defaultView
        } else {
          return t.ownerDocument.defaultView
        }
      }
      function Fc(t) {
        if (rc(t)) {
          let e = t.commonAncestorContainer
          if (oc(e)) {
            e = e.parentNode
          }
          return e
        } else {
          return t.parentNode
        }
      }
      function Vc(t, e) {
        const n = Nc(t)
        const o = new ac(t)
        if (n === e) {
          return o
        } else {
          let t = n
          while (t != e) {
            const e = t.frameElement
            const n = new ac(e).excludeScrollbarsAndBorders()
            o.moveBy(n.left, n.top)
            t = t.parent
          }
        }
        return o
      }
      function Lc(t) {
        if (typeof t === "number") {
          return { top: t, bottom: t, left: t, right: t }
        }
        return t
      }
      const jc = { ctrl: "⌃", cmd: "⌘", alt: "⌥", shift: "⇧" }
      const Hc = { ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+" }
      const Wc = Qc()
      const qc = Object.fromEntries(
        Object.entries(Wc).map(([t, e]) => [e, t.charAt(0).toUpperCase() + t.slice(1)])
      )
      function $c(t) {
        let e
        if (typeof t == "string") {
          e = Wc[t.toLowerCase()]
          if (!e) {
            throw new P("keyboard-unknown-key", null, { key: t })
          }
        } else {
          e =
            t.keyCode +
            (t.altKey ? Wc.alt : 0) +
            (t.ctrlKey ? Wc.ctrl : 0) +
            (t.shiftKey ? Wc.shift : 0) +
            (t.metaKey ? Wc.cmd : 0)
        }
        return e
      }
      function Kc(t) {
        if (typeof t == "string") {
          t = Xc(t)
        }
        return t.map((t) => (typeof t == "string" ? Zc(t) : t)).reduce((t, e) => e + t, 0)
      }
      function Gc(t) {
        let e = Kc(t)
        const n = Object.entries(i.isMac ? jc : Hc)
        const o = n.reduce((t, [n, o]) => {
          if ((e & Wc[n]) != 0) {
            e &= ~Wc[n]
            t += o
          }
          return t
        }, "")
        return o + (e ? qc[e] : "")
      }
      function Uc(t) {
        return t == Wc.arrowright || t == Wc.arrowleft || t == Wc.arrowup || t == Wc.arrowdown
      }
      function Jc(t, e) {
        const n = e === "ltr"
        switch (t) {
          case Wc.arrowleft:
            return n ? "left" : "right"
          case Wc.arrowright:
            return n ? "right" : "left"
          case Wc.arrowup:
            return "up"
          case Wc.arrowdown:
            return "down"
        }
      }
      function Zc(t) {
        if (t.endsWith("!")) {
          return $c(t.slice(0, -1))
        }
        const e = $c(t)
        return i.isMac && e == Wc.ctrl ? Wc.cmd : e
      }
      function Yc(t, e) {
        const n = Jc(t, e)
        return n === "down" || n === "right"
      }
      function Qc() {
        const t = {
          arrowleft: 37,
          arrowup: 38,
          arrowright: 39,
          arrowdown: 40,
          backspace: 8,
          delete: 46,
          enter: 13,
          space: 32,
          esc: 27,
          tab: 9,
          ctrl: 1114112,
          shift: 2228224,
          alt: 4456448,
          cmd: 8912896,
        }
        for (let e = 65; e <= 90; e++) {
          const n = String.fromCharCode(e)
          t[n.toLowerCase()] = e
        }
        for (let e = 48; e <= 57; e++) {
          t[e - 48] = e
        }
        for (let e = 112; e <= 123; e++) {
          t["f" + (e - 111)] = e
        }
        for (const e of "`-=[];',./\\") {
          t[e] = e.charCodeAt(0)
        }
        return t
      }
      function Xc(t) {
        return t.split("+").map((t) => t.trim())
      }
      function tl(t) {
        return Array.isArray(t) ? t : [t]
      }
      if (!Xa.window.CKEDITOR_TRANSLATIONS) {
        Xa.window.CKEDITOR_TRANSLATIONS = {}
      }
      function el(t, e, n) {
        if (!global.window.CKEDITOR_TRANSLATIONS[t]) {
          global.window.CKEDITOR_TRANSLATIONS[t] = {}
        }
        const o = global.window.CKEDITOR_TRANSLATIONS[t]
        o.dictionary = o.dictionary || {}
        o.getPluralForm = n || o.getPluralForm
        Object.assign(o.dictionary, e)
      }
      function nl(t, e, n = 1) {
        if (typeof n !== "number") {
          throw new P("translation-service-quantity-not-a-number", null, { quantity: n })
        }
        const o = il()
        if (o === 1) {
          t = Object.keys(Xa.window.CKEDITOR_TRANSLATIONS)[0]
        }
        const r = e.id || e.string
        if (o === 0 || !rl(t, r)) {
          if (n !== 1) {
            return e.plural
          }
          return e.string
        }
        const i = Xa.window.CKEDITOR_TRANSLATIONS[t].dictionary
        const s = Xa.window.CKEDITOR_TRANSLATIONS[t].getPluralForm || ((t) => (t === 1 ? 0 : 1))
        const a = i[r]
        if (typeof a === "string") {
          return a
        }
        const c = Number(s(n))
        return a[c]
      }
      function ol() {
        global.window.CKEDITOR_TRANSLATIONS = {}
      }
      function rl(t, e) {
        return (
          !!Xa.window.CKEDITOR_TRANSLATIONS[t] && !!Xa.window.CKEDITOR_TRANSLATIONS[t].dictionary[e]
        )
      }
      function il() {
        return Object.keys(Xa.window.CKEDITOR_TRANSLATIONS).length
      }
      const sl = ["ar", "ara", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig"]
      function al(t) {
        return sl.includes(t) ? "rtl" : "ltr"
      }
      class cl {
        constructor({ uiLanguage: t = "en", contentLanguage: e } = {}) {
          this.uiLanguage = t
          this.contentLanguage = e || this.uiLanguage
          this.uiLanguageDirection = al(this.uiLanguage)
          this.contentLanguageDirection = al(this.contentLanguage)
          this.t = (t, e) => this._t(t, e)
        }
        get language() {
          console.warn(
            "locale-deprecated-language-property: " +
              "The Locale#language property has been deprecated and will be removed in the near future. " +
              "Please use #uiLanguage and #contentLanguage properties instead."
          )
          return this.uiLanguage
        }
        _t(t, e = []) {
          e = tl(e)
          if (typeof t === "string") {
            t = { string: t }
          }
          const n = !!t.plural
          const o = n ? e[0] : 1
          const r = nl(this.uiLanguage, t, o)
          return ll(r, e)
        }
      }
      function ll(t, e) {
        return t.replace(/%(\d+)/g, (t, n) => (n < e.length ? e[n] : t))
      }
      class dl extends q() {
        constructor(t = {}, e = {}) {
          super()
          const n = yt(t)
          if (!n) {
            e = t
          }
          this._items = []
          this._itemMap = new Map()
          this._idProperty = e.idProperty || "id"
          this._bindToExternalToInternalMap = new WeakMap()
          this._bindToInternalToExternalMap = new WeakMap()
          this._skippedIndexesFromExternal = []
          if (n) {
            for (const e of t) {
              this._items.push(e)
              this._itemMap.set(this._getItemIdBeforeAdding(e), e)
            }
          }
        }
        get length() {
          return this._items.length
        }
        get first() {
          return this._items[0] || null
        }
        get last() {
          return this._items[this.length - 1] || null
        }
        add(t, e) {
          return this.addMany([t], e)
        }
        addMany(t, e) {
          if (e === undefined) {
            e = this._items.length
          } else if (e > this._items.length || e < 0) {
            throw new P("collection-add-item-invalid-index", this)
          }
          let n = 0
          for (const o of t) {
            const t = this._getItemIdBeforeAdding(o)
            const r = e + n
            this._items.splice(r, 0, o)
            this._itemMap.set(t, o)
            this.fire("add", o, r)
            n++
          }
          this.fire("change", { added: t, removed: [], index: e })
          return this
        }
        get(t) {
          let e
          if (typeof t == "string") {
            e = this._itemMap.get(t)
          } else if (typeof t == "number") {
            e = this._items[t]
          } else {
            throw new P("collection-get-invalid-arg", this)
          }
          return e || null
        }
        has(t) {
          if (typeof t == "string") {
            return this._itemMap.has(t)
          } else {
            const e = this._idProperty
            const n = t[e]
            return n && this._itemMap.has(n)
          }
        }
        getIndex(t) {
          let e
          if (typeof t == "string") {
            e = this._itemMap.get(t)
          } else {
            e = t
          }
          return e ? this._items.indexOf(e) : -1
        }
        remove(t) {
          const [e, n] = this._remove(t)
          this.fire("change", { added: [], removed: [e], index: n })
          return e
        }
        map(t, e) {
          return this._items.map(t, e)
        }
        find(t, e) {
          return this._items.find(t, e)
        }
        filter(t, e) {
          return this._items.filter(t, e)
        }
        clear() {
          if (this._bindToCollection) {
            this.stopListening(this._bindToCollection)
            this._bindToCollection = null
          }
          const t = Array.from(this._items)
          while (this.length) {
            this._remove(0)
          }
          this.fire("change", { added: [], removed: t, index: 0 })
        }
        bindTo(t) {
          if (this._bindToCollection) {
            throw new P("collection-bind-to-rebind", this)
          }
          this._bindToCollection = t
          return {
            as: (t) => {
              this._setUpBindToBinding((e) => new t(e))
            },
            using: (t) => {
              if (typeof t == "function") {
                this._setUpBindToBinding(t)
              } else {
                this._setUpBindToBinding((e) => e[t])
              }
            },
          }
        }
        _setUpBindToBinding(t) {
          const e = this._bindToCollection
          const n = (n, o, r) => {
            const i = e._bindToCollection == this
            const s = e._bindToInternalToExternalMap.get(o)
            if (i && s) {
              this._bindToExternalToInternalMap.set(o, s)
              this._bindToInternalToExternalMap.set(s, o)
            } else {
              const n = t(o)
              if (!n) {
                this._skippedIndexesFromExternal.push(r)
                return
              }
              let i = r
              for (const t of this._skippedIndexesFromExternal) {
                if (r > t) {
                  i--
                }
              }
              for (const t of e._skippedIndexesFromExternal) {
                if (i >= t) {
                  i++
                }
              }
              this._bindToExternalToInternalMap.set(o, n)
              this._bindToInternalToExternalMap.set(n, o)
              this.add(n, i)
              for (let t = 0; t < e._skippedIndexesFromExternal.length; t++) {
                if (i <= e._skippedIndexesFromExternal[t]) {
                  e._skippedIndexesFromExternal[t]++
                }
              }
            }
          }
          for (const t of e) {
            n(null, t, e.getIndex(t))
          }
          this.listenTo(e, "add", n)
          this.listenTo(e, "remove", (t, e, n) => {
            const o = this._bindToExternalToInternalMap.get(e)
            if (o) {
              this.remove(o)
            }
            this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((t, e) => {
              if (n < e) {
                t.push(e - 1)
              }
              if (n > e) {
                t.push(e)
              }
              return t
            }, [])
          })
        }
        _getItemIdBeforeAdding(t) {
          const e = this._idProperty
          let n
          if (e in t) {
            n = t[e]
            if (typeof n != "string") {
              throw new P("collection-add-invalid-id", this)
            }
            if (this.get(n)) {
              throw new P("collection-add-item-already-exists", this)
            }
          } else {
            t[e] = n = x()
          }
          return n
        }
        _remove(t) {
          let e, n, o
          let r = false
          const i = this._idProperty
          if (typeof t == "string") {
            n = t
            o = this._itemMap.get(n)
            r = !o
            if (o) {
              e = this._items.indexOf(o)
            }
          } else if (typeof t == "number") {
            e = t
            o = this._items[e]
            r = !o
            if (o) {
              n = o[i]
            }
          } else {
            o = t
            n = o[i]
            e = this._items.indexOf(o)
            r = e == -1 || !this._itemMap.get(n)
          }
          if (r) {
            throw new P("collection-remove-404", this)
          }
          this._items.splice(e, 1)
          this._itemMap.delete(n)
          const s = this._bindToInternalToExternalMap.get(o)
          this._bindToInternalToExternalMap.delete(o)
          this._bindToExternalToInternalMap.delete(s)
          this.fire("remove", o, e)
          return [o, e]
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]()
        }
      }
      function hl(t) {
        const e = t.next()
        if (e.done) {
          return null
        }
        return e.value
      }
      class ul extends Ua(dt()) {
        constructor() {
          super()
          this._elements = new Set()
          this._nextEventLoopTimeout = null
          this.set("isFocused", false)
          this.set("focusedElement", null)
        }
        add(t) {
          if (this._elements.has(t)) {
            throw new P("focustracker-add-element-already-exist", this)
          }
          this.listenTo(t, "focus", () => this._focus(t), { useCapture: true })
          this.listenTo(t, "blur", () => this._blur(), { useCapture: true })
          this._elements.add(t)
        }
        remove(t) {
          if (t === this.focusedElement) {
            this._blur()
          }
          if (this._elements.has(t)) {
            this.stopListening(t)
            this._elements.delete(t)
          }
        }
        destroy() {
          this.stopListening()
        }
        _focus(t) {
          clearTimeout(this._nextEventLoopTimeout)
          this.focusedElement = t
          this.isFocused = true
        }
        _blur() {
          clearTimeout(this._nextEventLoopTimeout)
          this._nextEventLoopTimeout = setTimeout(() => {
            this.focusedElement = null
            this.isFocused = false
          }, 0)
        }
      }
      class fl {
        constructor() {
          this._listener = new (Ua())()
        }
        listenTo(t) {
          this._listener.listenTo(t, "keydown", (t, e) => {
            this._listener.fire("_keydown:" + $c(e), e)
          })
        }
        set(t, e, n = {}) {
          const o = Kc(t)
          const r = n.priority
          this._listener.listenTo(
            this._listener,
            "_keydown:" + o,
            (t, n) => {
              e(n, () => {
                n.preventDefault()
                n.stopPropagation()
                t.stop()
              })
              t.return = true
            },
            { priority: r }
          )
        }
        press(t) {
          return !!this._listener.fire("_keydown:" + $c(t), t)
        }
        stopListening(t) {
          this._listener.stopListening(t)
        }
        destroy() {
          this.stopListening()
        }
      }
      function pl(t) {
        const e = new Map()
        for (const n in t) {
          e.set(n, t[n])
        }
        return e
      }
      function gl(t) {
        if (yt(t)) {
          return new Map(t)
        } else {
          return pl(t)
        }
      }
      const ml = 1e4
      function kl(t, e, n, o) {
        if (Math.max(e.length, t.length) > ml) {
          return t
            .slice(0, n)
            .concat(e)
            .concat(t.slice(n + o, t.length))
        } else {
          const r = Array.from(t)
          r.splice(n, o, ...e)
          return r
        }
      }
      function bl(t, e) {
        let n
        function o(...r) {
          o.cancel()
          n = setTimeout(() => t(...r), e)
        }
        o.cancel = () => {
          clearTimeout(n)
        }
        return o
      }
      function wl(t) {
        function e(t) {
          if (t.length >= 40 && t.length <= 255) {
            return "VALID"
          } else {
            return "INVALID"
          }
        }
        if (!t) {
          return "INVALID"
        }
        let n = ""
        try {
          n = atob(t)
        } catch (t) {
          return "INVALID"
        }
        const o = n.split("-")
        const r = o[0]
        const i = o[1]
        if (!i) {
          return e(t)
        }
        try {
          atob(i)
        } catch (n) {
          try {
            atob(r)
            if (!atob(r).length) {
              return e(t)
            }
          } catch (n) {
            return e(t)
          }
        }
        if (r.length < 40 || r.length > 255) {
          return "INVALID"
        }
        let s = ""
        try {
          atob(r)
          s = atob(i)
        } catch (t) {
          return "INVALID"
        }
        if (s.length !== 8) {
          return "INVALID"
        }
        const a = Number(s.substring(0, 4))
        const c = Number(s.substring(4, 6)) - 1
        const l = Number(s.substring(6, 8))
        const d = new Date(a, c, l)
        if (d < F || isNaN(Number(d))) {
          return "INVALID"
        }
        return "VALID"
      }
      function _l(t) {
        return (
          !!t &&
          t.length == 1 &&
          /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(t)
        )
      }
      function vl(t) {
        return !!t && t.length == 1 && /[\ud800-\udbff]/.test(t)
      }
      function Al(t) {
        return !!t && t.length == 1 && /[\udc00-\udfff]/.test(t)
      }
      function Cl(t, e) {
        return vl(t.charAt(e - 1)) && Al(t.charAt(e))
      }
      function yl(t, e) {
        return _l(t.charAt(e))
      }
      const xl = Dl()
      function El(t, e) {
        const n = String(t).matchAll(xl)
        return Array.from(n).some((t) => t.index < e && e < t.index + t[0].length)
      }
      function Dl() {
        const t = [
          /\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u,
          /\p{Emoji}\u{FE0F}?\u{20E3}/u,
          /\p{Emoji}\u{FE0F}/u,
          /(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u,
        ]
        const e = /\p{Regional_Indicator}{2}/u.source
        const n = "(?:" + t.map((t) => t.source).join("|") + ")"
        const o = `${e}|${n}(?:‍${n})*`
        return new RegExp(o, "ug")
      }
      class Sl extends dl {
        constructor(t = []) {
          super(t, { idProperty: "viewUid" })
          this.on("add", (t, e, n) => {
            this._renderViewIntoCollectionParent(e, n)
          })
          this.on("remove", (t, e) => {
            if (e.element && this._parentElement) {
              e.element.remove()
            }
          })
          this._parentElement = null
        }
        destroy() {
          this.map((t) => t.destroy())
        }
        setParent(t) {
          this._parentElement = t
          for (const t of this) {
            this._renderViewIntoCollectionParent(t)
          }
        }
        delegate(...t) {
          if (!t.length || !Tl(t)) {
            throw new P("ui-viewcollection-delegate-wrong-events", this)
          }
          return {
            to: (e) => {
              for (const n of this) {
                for (const o of t) {
                  n.delegate(o).to(e)
                }
              }
              this.on("add", (n, o) => {
                for (const n of t) {
                  o.delegate(n).to(e)
                }
              })
              this.on("remove", (n, o) => {
                for (const n of t) {
                  o.stopDelegating(n, e)
                }
              })
            },
          }
        }
        _renderViewIntoCollectionParent(t, e) {
          if (!t.isRendered) {
            t.render()
          }
          if (t.element && this._parentElement) {
            this._parentElement.insertBefore(t.element, this._parentElement.children[e])
          }
        }
        remove(t) {
          return super.remove(t)
        }
      }
      function Tl(t) {
        return t.every((t) => typeof t == "string")
      }
      var Pl = n(379)
      var Bl = n.n(Pl)
      var Rl = n(150)
      var Ol = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      Ol.insert = "head"
      Ol.singleton = true
      var Ml = Bl()(Rl.Z, Ol)
      const Il = Rl.Z.locals || {}
      class zl extends Ua(dt()) {
        constructor(t) {
          super()
          this.element = null
          this.isRendered = false
          this.locale = t
          this.t = t && t.t
          this._viewCollections = new dl()
          this._unboundChildren = this.createCollection()
          this._viewCollections.on("add", (e, n) => {
            n.locale = t
            n.t = t && t.t
          })
          this.decorate("render")
        }
        get bindTemplate() {
          if (this._bindTemplate) {
            return this._bindTemplate
          }
          return (this._bindTemplate = Fl.bind(this, this))
        }
        createCollection(t) {
          const e = new Sl(t)
          this._viewCollections.add(e)
          return e
        }
        registerChild(t) {
          if (!yt(t)) {
            t = [t]
          }
          for (const e of t) {
            this._unboundChildren.add(e)
          }
        }
        deregisterChild(t) {
          if (!yt(t)) {
            t = [t]
          }
          for (const e of t) {
            this._unboundChildren.remove(e)
          }
        }
        setTemplate(t) {
          this.template = new Fl(t)
        }
        extendTemplate(t) {
          Fl.extend(this.template, t)
        }
        render() {
          if (this.isRendered) {
            throw new P("ui-view-render-already-rendered", this)
          }
          if (this.template) {
            this.element = this.template.render()
            this.registerChild(this.template.getViews())
          }
          this.isRendered = true
        }
        destroy() {
          this.stopListening()
          this._viewCollections.map((t) => t.destroy())
          if (this.template && this.template._revertData) {
            this.template.revert(this.element)
          }
        }
      }
      const Nl = "http://www.w3.org/1999/xhtml"
      class Fl extends q() {
        constructor(t) {
          super()
          Object.assign(this, Jl(Ul(t)))
          this._isRendered = false
          this._revertData = null
        }
        render() {
          const t = this._renderNode({ intoFragment: true })
          this._isRendered = true
          return t
        }
        apply(t) {
          this._revertData = ld()
          this._renderNode({
            node: t,
            intoFragment: false,
            isApplying: true,
            revertData: this._revertData,
          })
          return t
        }
        revert(t) {
          if (!this._revertData) {
            throw new P("ui-template-revert-not-applied", [this, t])
          }
          this._revertTemplateFromNode(t, this._revertData)
        }
        *getViews() {
          function* t(e) {
            if (e.children) {
              for (const n of e.children) {
                if (id(n)) {
                  yield n
                } else if (sd(n)) {
                  yield* t(n)
                }
              }
            }
          }
          yield* t(this)
        }
        static bind(t, e) {
          return {
            to(n, o) {
              return new Ll({
                eventNameOrFunction: n,
                attribute: n,
                observable: t,
                emitter: e,
                callback: o,
              })
            },
            if(n, o, r) {
              return new jl({
                observable: t,
                emitter: e,
                attribute: n,
                valueIfTrue: o,
                callback: r,
              })
            },
          }
        }
        static extend(t, e) {
          if (t._isRendered) {
            throw new P("template-extend-render", [this, t])
          }
          od(t, Jl(Ul(e)))
        }
        _renderNode(t) {
          let e
          if (t.node) {
            e = this.tag && this.text
          } else {
            e = this.tag ? this.text : !this.text
          }
          if (e) {
            throw new P("ui-template-wrong-syntax", this)
          }
          if (this.text) {
            return this._renderText(t)
          } else {
            return this._renderElement(t)
          }
        }
        _renderElement(t) {
          let e = t.node
          if (!e) {
            e = t.node = document.createElementNS(this.ns || Nl, this.tag)
          }
          this._renderAttributes(t)
          this._renderElementChildren(t)
          this._setUpListeners(t)
          return e
        }
        _renderText(t) {
          let e = t.node
          if (e) {
            t.revertData.text = e.textContent
          } else {
            e = t.node = document.createTextNode("")
          }
          if (Hl(this.text)) {
            this._bindToObservable({ schema: this.text, updater: $l(e), data: t })
          } else {
            e.textContent = this.text.join("")
          }
          return e
        }
        _renderAttributes(t) {
          if (!this.attributes) {
            return
          }
          const e = t.node
          const n = t.revertData
          for (const o in this.attributes) {
            const r = e.getAttribute(o)
            const i = this.attributes[o]
            if (n) {
              n.attributes[o] = r
            }
            const s = cd(i) ? i[0].ns : null
            if (Hl(i)) {
              const a = cd(i) ? i[0].value : i
              if (n && dd(o)) {
                a.unshift(r)
              }
              this._bindToObservable({ schema: a, updater: Kl(e, o, s), data: t })
            } else if (o == "style" && typeof i[0] !== "string") {
              this._renderStyleAttribute(i[0], t)
            } else {
              if (n && r && dd(o)) {
                i.unshift(r)
              }
              const t = i
                .map((t) => (t ? t.value || t : t))
                .reduce((t, e) => t.concat(e), [])
                .reduce(ed, "")
              if (!rd(t)) {
                e.setAttributeNS(s, o, t)
              }
            }
          }
        }
        _renderStyleAttribute(t, e) {
          const n = e.node
          for (const o in t) {
            const r = t[o]
            if (Hl(r)) {
              this._bindToObservable({ schema: [r], updater: Gl(n, o), data: e })
            } else {
              n.style[o] = r
            }
          }
        }
        _renderElementChildren(t) {
          const e = t.node
          const n = t.intoFragment ? document.createDocumentFragment() : e
          const o = t.isApplying
          let r = 0
          for (const i of this.children) {
            if (ad(i)) {
              if (!o) {
                i.setParent(e)
                for (const t of i) {
                  n.appendChild(t.element)
                }
              }
            } else if (id(i)) {
              if (!o) {
                if (!i.isRendered) {
                  i.render()
                }
                n.appendChild(i.element)
              }
            } else if ($a(i)) {
              n.appendChild(i)
            } else {
              if (o) {
                const e = t.revertData
                const o = ld()
                e.children.push(o)
                i._renderNode({
                  intoFragment: false,
                  node: n.childNodes[r++],
                  isApplying: true,
                  revertData: o,
                })
              } else {
                n.appendChild(i.render())
              }
            }
          }
          if (t.intoFragment) {
            e.appendChild(n)
          }
        }
        _setUpListeners(t) {
          if (!this.eventListeners) {
            return
          }
          for (const e in this.eventListeners) {
            const n = this.eventListeners[e].map((n) => {
              const [o, r] = e.split("@")
              return n.activateDomEventListener(o, r, t)
            })
            if (t.revertData) {
              t.revertData.bindings.push(n)
            }
          }
        }
        _bindToObservable({ schema: t, updater: e, data: n }) {
          const o = n.revertData
          ql(t, e, n)
          const r = t
            .filter((t) => !rd(t))
            .filter((t) => t.observable)
            .map((o) => o.activateAttributeListener(t, e, n))
          if (o) {
            o.bindings.push(r)
          }
        }
        _revertTemplateFromNode(t, e) {
          for (const t of e.bindings) {
            for (const e of t) {
              e()
            }
          }
          if (e.text) {
            t.textContent = e.text
            return
          }
          const n = t
          for (const t in e.attributes) {
            const o = e.attributes[t]
            if (o === null) {
              n.removeAttribute(t)
            } else {
              n.setAttribute(t, o)
            }
          }
          for (let t = 0; t < e.children.length; ++t) {
            this._revertTemplateFromNode(n.childNodes[t], e.children[t])
          }
        }
      }
      class Vl {
        constructor(t) {
          this.attribute = t.attribute
          this.observable = t.observable
          this.emitter = t.emitter
          this.callback = t.callback
        }
        getValue(t) {
          const e = this.observable[this.attribute]
          return this.callback ? this.callback(e, t) : e
        }
        activateAttributeListener(t, e, n) {
          const o = () => ql(t, e, n)
          this.emitter.listenTo(this.observable, `change:${this.attribute}`, o)
          return () => {
            this.emitter.stopListening(this.observable, `change:${this.attribute}`, o)
          }
        }
      }
      class Ll extends Vl {
        constructor(t) {
          super(t)
          this.eventNameOrFunction = t.eventNameOrFunction
        }
        activateDomEventListener(t, e, n) {
          const o = (t, n) => {
            if (!e || n.target.matches(e)) {
              if (typeof this.eventNameOrFunction == "function") {
                this.eventNameOrFunction(n)
              } else {
                this.observable.fire(this.eventNameOrFunction, n)
              }
            }
          }
          this.emitter.listenTo(n.node, t, o)
          return () => {
            this.emitter.stopListening(n.node, t, o)
          }
        }
      }
      class jl extends Vl {
        constructor(t) {
          super(t)
          this.valueIfTrue = t.valueIfTrue
        }
        getValue(t) {
          const e = super.getValue(t)
          return rd(e) ? false : this.valueIfTrue || true
        }
      }
      function Hl(t) {
        if (!t) {
          return false
        }
        if (t.value) {
          t = t.value
        }
        if (Array.isArray(t)) {
          return t.some(Hl)
        } else if (t instanceof Vl) {
          return true
        }
        return false
      }
      function Wl(t, e) {
        return t.map((t) => {
          if (t instanceof Vl) {
            return t.getValue(e)
          }
          return t
        })
      }
      function ql(t, e, { node: n }) {
        const o = Wl(t, n)
        let r
        if (t.length == 1 && t[0] instanceof jl) {
          r = o[0]
        } else {
          r = o.reduce(ed, "")
        }
        if (rd(r)) {
          e.remove()
        } else {
          e.set(r)
        }
      }
      function $l(t) {
        return {
          set(e) {
            t.textContent = e
          },
          remove() {
            t.textContent = ""
          },
        }
      }
      function Kl(t, e, n) {
        return {
          set(o) {
            t.setAttributeNS(n, e, o)
          },
          remove() {
            t.removeAttributeNS(n, e)
          },
        }
      }
      function Gl(t, e) {
        return {
          set(n) {
            t.style[e] = n
          },
          remove() {
            t.style[e] = null
          },
        }
      }
      function Ul(t) {
        const e = Va(t, (t) => {
          if (t && (t instanceof Vl || sd(t) || id(t) || ad(t))) {
            return t
          }
        })
        return e
      }
      function Jl(t) {
        if (typeof t == "string") {
          t = Ql(t)
        } else if (t.text) {
          Xl(t)
        }
        if (t.on) {
          t.eventListeners = Yl(t.on)
          delete t.on
        }
        if (!t.text) {
          if (t.attributes) {
            Zl(t.attributes)
          }
          const e = []
          if (t.children) {
            if (ad(t.children)) {
              e.push(t.children)
            } else {
              for (const n of t.children) {
                if (sd(n) || id(n) || $a(n)) {
                  e.push(n)
                } else {
                  e.push(new Fl(n))
                }
              }
            }
          }
          t.children = e
        }
        return t
      }
      function Zl(t) {
        for (const e in t) {
          if (t[e].value) {
            t[e].value = tl(t[e].value)
          }
          td(t, e)
        }
      }
      function Yl(t) {
        for (const e in t) {
          td(t, e)
        }
        return t
      }
      function Ql(t) {
        return { text: [t] }
      }
      function Xl(t) {
        t.text = tl(t.text)
      }
      function td(t, e) {
        t[e] = tl(t[e])
      }
      function ed(t, e) {
        if (rd(e)) {
          return t
        } else if (rd(t)) {
          return e
        } else {
          return `${t} ${e}`
        }
      }
      function nd(t, e) {
        for (const n in e) {
          if (t[n]) {
            t[n].push(...e[n])
          } else {
            t[n] = e[n]
          }
        }
      }
      function od(t, e) {
        if (e.attributes) {
          if (!t.attributes) {
            t.attributes = {}
          }
          nd(t.attributes, e.attributes)
        }
        if (e.eventListeners) {
          if (!t.eventListeners) {
            t.eventListeners = {}
          }
          nd(t.eventListeners, e.eventListeners)
        }
        if (e.text) {
          t.text.push(...e.text)
        }
        if (e.children && e.children.length) {
          if (t.children.length != e.children.length) {
            throw new P("ui-template-extend-children-mismatch", t)
          }
          let n = 0
          for (const o of e.children) {
            od(t.children[n++], o)
          }
        }
      }
      function rd(t) {
        return !t && t !== 0
      }
      function id(t) {
        return t instanceof zl
      }
      function sd(t) {
        return t instanceof Fl
      }
      function ad(t) {
        return t instanceof Sl
      }
      function cd(t) {
        return ot(t[0]) && t[0].ns
      }
      function ld() {
        return { children: [], bindings: [], attributes: {} }
      }
      function dd(t) {
        return t == "class" || t == "style"
      }
      class hd extends Sl {
        constructor(t, e = []) {
          super(e)
          this.locale = t
        }
        get bodyCollectionContainer() {
          return this._bodyCollectionContainer
        }
        attachToDom() {
          this._bodyCollectionContainer = new Fl({
            tag: "div",
            attributes: {
              class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"],
              dir: this.locale.uiLanguageDirection,
            },
            children: this,
          }).render()
          let t = document.querySelector(".ck-body-wrapper")
          if (!t) {
            t = te(document, "div", { class: "ck-body-wrapper" })
            document.body.appendChild(t)
          }
          t.appendChild(this._bodyCollectionContainer)
        }
        detachFromDom() {
          super.destroy()
          if (this._bodyCollectionContainer) {
            this._bodyCollectionContainer.remove()
          }
          const t = document.querySelector(".ck-body-wrapper")
          if (t && t.childElementCount == 0) {
            t.remove()
          }
        }
      }
      var ud = n(174)
      var fd = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      fd.insert = "head"
      fd.singleton = true
      var pd = Bl()(ud.Z, fd)
      const gd = ud.Z.locals || {}
      class md extends zl {
        constructor() {
          super()
          const t = this.bindTemplate
          this.set("content", "")
          this.set("viewBox", "0 0 20 20")
          this.set("fillColor", "")
          this.set("isColorInherited", true)
          this.setTemplate({
            tag: "svg",
            ns: "http://www.w3.org/2000/svg",
            attributes: {
              class: [
                "ck",
                "ck-icon",
                "ck-reset_all-excluded",
                t.if("isColorInherited", "ck-icon_inherit-color"),
              ],
              viewBox: t.to("viewBox"),
            },
          })
        }
        render() {
          super.render()
          this._updateXMLContent()
          this._colorFillPaths()
          this.on("change:content", () => {
            this._updateXMLContent()
            this._colorFillPaths()
          })
          this.on("change:fillColor", () => {
            this._colorFillPaths()
          })
        }
        _updateXMLContent() {
          if (this.content) {
            const t = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml")
            const e = t.querySelector("svg")
            const n = e.getAttribute("viewBox")
            if (n) {
              this.viewBox = n
            }
            for (const { name: t, value: n } of Array.from(e.attributes)) {
              if (md.presentationalAttributeNames.includes(t)) {
                this.element.setAttribute(t, n)
              }
            }
            while (this.element.firstChild) {
              this.element.removeChild(this.element.firstChild)
            }
            while (e.childNodes.length > 0) {
              this.element.appendChild(e.childNodes[0])
            }
          }
        }
        _colorFillPaths() {
          if (this.fillColor) {
            this.element.querySelectorAll(".ck-icon__fill").forEach((t) => {
              t.style.fill = this.fillColor
            })
          }
        }
      }
      md.presentationalAttributeNames = [
        "alignment-baseline",
        "baseline-shift",
        "clip-path",
        "clip-rule",
        "color",
        "color-interpolation",
        "color-interpolation-filters",
        "color-rendering",
        "cursor",
        "direction",
        "display",
        "dominant-baseline",
        "fill",
        "fill-opacity",
        "fill-rule",
        "filter",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "mask",
        "opacity",
        "overflow",
        "paint-order",
        "pointer-events",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "stroke",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-overflow",
        "text-rendering",
        "transform",
        "unicode-bidi",
        "vector-effect",
        "visibility",
        "white-space",
        "word-spacing",
        "writing-mode",
      ]
      var kd = n(499)
      var bd = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      bd.insert = "head"
      bd.singleton = true
      var wd = Bl()(kd.Z, bd)
      const _d = kd.Z.locals || {}
      class vd extends zl {
        constructor(t) {
          super(t)
          this._focusDelayed = null
          const e = this.bindTemplate
          const n = x()
          this.set("ariaChecked", undefined)
          this.set("ariaLabel", undefined)
          this.set("ariaLabelledBy", `ck-editor__aria-label_${n}`)
          this.set("class", undefined)
          this.set("labelStyle", undefined)
          this.set("icon", undefined)
          this.set("isEnabled", true)
          this.set("isOn", false)
          this.set("isVisible", true)
          this.set("isToggleable", false)
          this.set("keystroke", undefined)
          this.set("label", undefined)
          this.set("role", undefined)
          this.set("tabindex", -1)
          this.set("tooltip", false)
          this.set("tooltipPosition", "s")
          this.set("type", "button")
          this.set("withText", false)
          this.set("withKeystroke", false)
          this.children = this.createCollection()
          this.labelView = this._createLabelView()
          this.iconView = new md()
          this.iconView.extendTemplate({ attributes: { class: "ck-button__icon" } })
          this.keystrokeView = this._createKeystrokeView()
          this.bind("_tooltipString").to(
            this,
            "tooltip",
            this,
            "label",
            this,
            "keystroke",
            this._getTooltipString.bind(this)
          )
          const o = {
            tag: "button",
            attributes: {
              class: [
                "ck",
                "ck-button",
                e.to("class"),
                e.if("isEnabled", "ck-disabled", (t) => !t),
                e.if("isVisible", "ck-hidden", (t) => !t),
                e.to("isOn", (t) => (t ? "ck-on" : "ck-off")),
                e.if("withText", "ck-button_with-text"),
                e.if("withKeystroke", "ck-button_with-keystroke"),
              ],
              role: e.to("role"),
              type: e.to("type", (t) => (t ? t : "button")),
              tabindex: e.to("tabindex"),
              "aria-label": e.to("ariaLabel"),
              "aria-labelledby": e.to("ariaLabelledBy"),
              "aria-disabled": e.if("isEnabled", true, (t) => !t),
              "aria-checked": e.to("isOn"),
              "aria-pressed": e.to("isOn", (t) => (this.isToggleable ? String(!!t) : false)),
              "data-cke-tooltip-text": e.to("_tooltipString"),
              "data-cke-tooltip-position": e.to("tooltipPosition"),
            },
            children: this.children,
            on: {
              click: e.to((t) => {
                if (this.isEnabled) {
                  this.fire("execute")
                } else {
                  t.preventDefault()
                }
              }),
            },
          }
          if (i.isSafari) {
            if (!this._focusDelayed) {
              this._focusDelayed = bl(() => this.focus(), 0)
            }
            o.on.mousedown = e.to(() => {
              this._focusDelayed()
            })
            o.on.mouseup = e.to(() => {
              this._focusDelayed.cancel()
            })
          }
          this.setTemplate(o)
        }
        render() {
          super.render()
          if (this.icon) {
            this.iconView.bind("content").to(this, "icon")
            this.children.add(this.iconView)
          }
          this.children.add(this.labelView)
          if (this.withKeystroke && this.keystroke) {
            this.children.add(this.keystrokeView)
          }
        }
        focus() {
          this.element.focus()
        }
        destroy() {
          if (this._focusDelayed) {
            this._focusDelayed.cancel()
          }
          super.destroy()
        }
        _createLabelView() {
          const t = new zl()
          const e = this.bindTemplate
          t.setTemplate({
            tag: "span",
            attributes: {
              class: ["ck", "ck-button__label"],
              style: e.to("labelStyle"),
              id: this.ariaLabelledBy,
            },
            children: [{ text: e.to("label") }],
          })
          return t
        }
        _createKeystrokeView() {
          const t = new zl()
          t.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-button__keystroke"] },
            children: [{ text: this.bindTemplate.to("keystroke", (t) => Gc(t)) }],
          })
          return t
        }
        _getTooltipString(t, e, n) {
          if (t) {
            if (typeof t == "string") {
              return t
            } else {
              if (n) {
                n = Gc(n)
              }
              if (t instanceof Function) {
                return t(e, n)
              } else {
                return `${e}${n ? ` (${n})` : ""}`
              }
            }
          }
          return ""
        }
      }
      var Ad = n(681)
      var Cd = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      Cd.insert = "head"
      Cd.singleton = true
      var yd = Bl()(Ad.Z, Cd)
      const xd = Ad.Z.locals || {}
      class Ed extends vd {
        constructor(t) {
          super(t)
          this.isToggleable = true
          this.toggleSwitchView = this._createToggleView()
          this.extendTemplate({ attributes: { class: "ck-switchbutton" } })
        }
        render() {
          super.render()
          this.children.add(this.toggleSwitchView)
        }
        _createToggleView() {
          const t = new zl()
          t.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-button__toggle"] },
            children: [{ tag: "span", attributes: { class: ["ck", "ck-button__toggle__inner"] } }],
          })
          return t
        }
      }
      class Dd extends (null && ButtonView) {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.set("color", undefined)
          this.set("hasBorder", false)
          this.icon = checkIcon
          this.extendTemplate({
            attributes: {
              style: { backgroundColor: e.to("color") },
              class: [
                "ck",
                "ck-color-grid__tile",
                e.if("hasBorder", "ck-color-table__color-tile_bordered"),
              ],
            },
          })
        }
        render() {
          super.render()
          this.iconView.fillColor = "hsl(0, 0%, 100%)"
        }
      }
      var Sd = n(923)
      var Td = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      Td.insert = "head"
      Td.singleton = true
      var Pd = Bl()(Sd.Z, Td)
      const Bd = Sd.Z.locals || {}
      class Rd extends (null && View) {
        constructor(t, e) {
          super(t)
          const n = e && e.colorDefinitions ? e.colorDefinitions : []
          this.columns = e && e.columns ? e.columns : 5
          const o = { gridTemplateColumns: `repeat( ${this.columns}, 1fr)` }
          this.set("selectedColor", undefined)
          this.items = this.createCollection()
          this.focusTracker = new FocusTracker()
          this.keystrokes = new KeystrokeHandler()
          this.items.on("add", (t, e) => {
            e.isOn = e.color === this.selectedColor
          })
          n.forEach((t) => {
            const e = new ColorTileView()
            e.set({ color: t.color, label: t.label, tooltip: true, hasBorder: t.options.hasBorder })
            e.on("execute", () => {
              this.fire("execute", {
                value: t.color,
                hasBorder: t.options.hasBorder,
                label: t.label,
              })
            })
            this.items.add(e)
          })
          this.setTemplate({
            tag: "div",
            children: this.items,
            attributes: { class: ["ck", "ck-color-grid"], style: o },
          })
          this.on("change:selectedColor", (t, e, n) => {
            for (const t of this.items) {
              t.isOn = t.color === n
            }
          })
        }
        focus() {
          if (this.items.length) {
            this.items.first.focus()
          }
        }
        focusLast() {
          if (this.items.length) {
            this.items.last.focus()
          }
        }
        render() {
          super.render()
          for (const t of this.items) {
            this.focusTracker.add(t.element)
          }
          this.items.on("add", (t, e) => {
            this.focusTracker.add(e.element)
          })
          this.items.on("remove", (t, e) => {
            this.focusTracker.remove(e.element)
          })
          this.keystrokes.listenTo(this.element)
          addKeyboardHandlingForGrid({
            keystrokeHandler: this.keystrokes,
            focusTracker: this.focusTracker,
            gridItems: this.items,
            numberOfColumns: this.columns,
            uiLanguageDirection: this.locale && this.locale.uiLanguageDirection,
          })
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
        }
      }
      var Od = n(874)
      const Md = null && zd
      var Id = { red: 0, orange: 60, yellow: 120, green: 180, blue: 240, purple: 300 }
      function zd(t) {
        var e,
          n = [],
          o = 1,
          r
        if (typeof t === "string") {
          if (names[t]) {
            n = names[t].slice()
            r = "rgb"
          } else if (t === "transparent") {
            o = 0
            r = "rgb"
            n = [0, 0, 0]
          } else if (/^#[A-Fa-f0-9]+$/.test(t)) {
            var i = t.slice(1)
            var s = i.length
            var a = s <= 4
            o = 1
            if (a) {
              n = [parseInt(i[0] + i[0], 16), parseInt(i[1] + i[1], 16), parseInt(i[2] + i[2], 16)]
              if (s === 4) {
                o = parseInt(i[3] + i[3], 16) / 255
              }
            } else {
              n = [parseInt(i[0] + i[1], 16), parseInt(i[2] + i[3], 16), parseInt(i[4] + i[5], 16)]
              if (s === 8) {
                o = parseInt(i[6] + i[7], 16) / 255
              }
            }
            if (!n[0]) n[0] = 0
            if (!n[1]) n[1] = 0
            if (!n[2]) n[2] = 0
            r = "rgb"
          } else if (
            (e =
              /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(
                t
              ))
          ) {
            var c = e[1]
            var l = c === "rgb"
            var i = c.replace(/a$/, "")
            r = i
            var s = i === "cmyk" ? 4 : i === "gray" ? 1 : 3
            n = e[2]
              .trim()
              .split(/\s*[,\/]\s*|\s+/)
              .map(function (t, e) {
                if (/%$/.test(t)) {
                  if (e === s) return parseFloat(t) / 100
                  if (i === "rgb") return (parseFloat(t) * 255) / 100
                  return parseFloat(t)
                } else if (i[e] === "h") {
                  if (/deg$/.test(t)) {
                    return parseFloat(t)
                  } else if (Id[t] !== undefined) {
                    return Id[t]
                  }
                }
                return parseFloat(t)
              })
            if (c === i) n.push(1)
            o = l ? 1 : n[s] === undefined ? 1 : n[s]
            n = n.slice(0, s)
          } else if (t.length > 10 && /[0-9](?:\s|\/)/.test(t)) {
            n = t.match(/([0-9]+)/g).map(function (t) {
              return parseFloat(t)
            })
            r = t
              .match(/([a-z])/gi)
              .join("")
              .toLowerCase()
          }
        } else if (!isNaN(t)) {
          r = "rgb"
          n = [t >>> 16, (t & 65280) >>> 8, t & 255]
        } else if (Array.isArray(t) || t.length) {
          n = [t[0], t[1], t[2]]
          r = "rgb"
          o = t.length === 4 ? t[3] : 1
        } else if (t instanceof Object) {
          if (t.r != null || t.red != null || t.R != null) {
            r = "rgb"
            n = [t.r || t.red || t.R || 0, t.g || t.green || t.G || 0, t.b || t.blue || t.B || 0]
          } else {
            r = "hsl"
            n = [
              t.h || t.hue || t.H || 0,
              t.s || t.saturation || t.S || 0,
              t.l || t.lightness || t.L || t.b || t.brightness,
            ]
          }
          o = t.a || t.alpha || t.opacity || 1
          if (t.opacity != null) o /= 100
        }
        return { space: r, values: n, alpha: o }
      }
      var Nd = n(85)
      function Fd(t, e) {
        if (!t) {
          return ""
        }
        const n = jd(t)
        if (!n) {
          return ""
        }
        if (n.space === e) {
          return t
        }
        if (!Hd(n)) {
          return ""
        }
        const o = convert[n.space]
        const r = o[e]
        if (!r) {
          return ""
        }
        const i = r(n.space === "hex" ? n.hexValue : n.values)
        return Ld(i, e)
      }
      function Vd(t) {
        if (!t) {
          return ""
        }
        const e = jd(t)
        if (!e) {
          return "#000"
        }
        if (e.space === "hex") {
          return e.hexValue
        }
        return Fd(t, "hex")
      }
      function Ld(t, e) {
        switch (e) {
          case "hex":
            return `#${t}`
          case "rgb":
            return `rgb( ${t[0]}, ${t[1]}, ${t[2]} )`
          case "hsl":
            return `hsl( ${t[0]}, ${t[1]}%, ${t[2]}% )`
          case "hwb":
            return `hwb( ${t[0]}, ${t[1]}, ${t[2]} )`
          case "lab":
            return `lab( ${t[0]}% ${t[1]} ${t[2]} )`
          case "lch":
            return `lch( ${t[0]}% ${t[1]} ${t[2]} )`
          default:
            return ""
        }
      }
      function jd(t) {
        if (t.startsWith("#")) {
          const e = parse(t)
          return { space: "hex", values: e.values, hexValue: t, alpha: e.alpha }
        }
        const e = parse(t)
        if (!e.space) {
          return null
        }
        return e
      }
      function Hd(t) {
        return Object.keys(convert).includes(t.space)
      }
      var Wd = n(751)
      var qd = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      qd.insert = "head"
      qd.singleton = true
      var $d = Bl()(Wd.Z, qd)
      const Kd = Wd.Z.locals || {}
      class Gd extends zl {
        constructor(t) {
          super(t)
          this.set("text", undefined)
          this.set("for", undefined)
          this.id = `ck-editor__label_${x()}`
          const e = this.bindTemplate
          this.setTemplate({
            tag: "label",
            attributes: { class: ["ck", "ck-label"], id: this.id, for: e.to("for") },
            children: [{ text: e.to("text") }],
          })
        }
      }
      var Ud = n(957)
      var Jd = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      Jd.insert = "head"
      Jd.singleton = true
      var Zd = Bl()(Ud.Z, Jd)
      const Yd = Ud.Z.locals || {}
      class Qd extends (null && View) {
        constructor(t, e) {
          super(t)
          const n = `ck-labeled-field-view-${uid()}`
          const o = `ck-labeled-field-view-status-${uid()}`
          this.fieldView = e(this, n, o)
          this.set("label", undefined)
          this.set("isEnabled", true)
          this.set("isEmpty", true)
          this.set("isFocused", false)
          this.set("errorText", null)
          this.set("infoText", null)
          this.set("class", undefined)
          this.set("placeholder", undefined)
          this.labelView = this._createLabelView(n)
          this.statusView = this._createStatusView(o)
          this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView])
          this.bind("_statusText").to(this, "errorText", this, "infoText", (t, e) => t || e)
          const r = this.bindTemplate
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-labeled-field-view",
                r.to("class"),
                r.if("isEnabled", "ck-disabled", (t) => !t),
                r.if("isEmpty", "ck-labeled-field-view_empty"),
                r.if("isFocused", "ck-labeled-field-view_focused"),
                r.if("placeholder", "ck-labeled-field-view_placeholder"),
                r.if("errorText", "ck-error"),
              ],
            },
            children: [
              {
                tag: "div",
                attributes: { class: ["ck", "ck-labeled-field-view__input-wrapper"] },
                children: this.fieldWrapperChildren,
              },
              this.statusView,
            ],
          })
        }
        _createLabelView(t) {
          const e = new LabelView(this.locale)
          e.for = t
          e.bind("text").to(this, "label")
          return e
        }
        _createStatusView(t) {
          const e = new View(this.locale)
          const n = this.bindTemplate
          e.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-labeled-field-view__status",
                n.if("errorText", "ck-labeled-field-view__status_error"),
                n.if("_statusText", "ck-hidden", (t) => !t),
              ],
              id: t,
              role: n.if("errorText", "alert"),
            },
            children: [{ text: n.to("_statusText") }],
          })
          return e
        }
        focus() {
          this.fieldView.focus()
        }
      }
      var Xd = n(985)
      var th = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      th.insert = "head"
      th.singleton = true
      var eh = Bl()(Xd.Z, th)
      const nh = Xd.Z.locals || {}
      class oh extends (null && View) {
        constructor(t) {
          super(t)
          this.set("value", undefined)
          this.set("id", undefined)
          this.set("placeholder", undefined)
          this.set("isReadOnly", false)
          this.set("hasError", false)
          this.set("ariaDescribedById", undefined)
          this.focusTracker = new FocusTracker()
          this.bind("isFocused").to(this.focusTracker)
          this.set("isEmpty", true)
          this.set("inputMode", "text")
          const e = this.bindTemplate
          this.setTemplate({
            tag: "input",
            attributes: {
              class: [
                "ck",
                "ck-input",
                e.if("isFocused", "ck-input_focused"),
                e.if("isEmpty", "ck-input-text_empty"),
                e.if("hasError", "ck-error"),
              ],
              id: e.to("id"),
              placeholder: e.to("placeholder"),
              readonly: e.to("isReadOnly"),
              inputmode: e.to("inputMode"),
              "aria-invalid": e.if("hasError", true),
              "aria-describedby": e.to("ariaDescribedById"),
            },
            on: {
              input: e.to((...t) => {
                this.fire("input", ...t)
                this._updateIsEmpty()
              }),
              change: e.to(this._updateIsEmpty.bind(this)),
            },
          })
        }
        render() {
          super.render()
          this.focusTracker.add(this.element)
          this._setDomElementValue(this.value)
          this._updateIsEmpty()
          this.on("change:value", (t, e, n) => {
            this._setDomElementValue(n)
            this._updateIsEmpty()
          })
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
        }
        select() {
          this.element.select()
        }
        focus() {
          this.element.focus()
        }
        _updateIsEmpty() {
          this.isEmpty = rh(this.element)
        }
        _setDomElementValue(t) {
          this.element.value = !t && t !== 0 ? "" : t
        }
      }
      function rh(t) {
        return !t.value
      }
      class ih extends (null && InputView) {
        constructor(t) {
          super(t)
          this.extendTemplate({ attributes: { type: "text", class: ["ck-input-text"] } })
        }
      }
      class sh extends (null && InputView) {
        constructor(t, { min: e, max: n, step: o } = {}) {
          super(t)
          const r = this.bindTemplate
          this.set("min", e)
          this.set("max", n)
          this.set("step", o)
          this.extendTemplate({
            attributes: {
              type: "number",
              class: ["ck-input-number"],
              min: r.to("min"),
              max: r.to("max"),
              step: r.to("step"),
            },
          })
        }
      }
      class ah extends zl {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.set("isVisible", false)
          this.set("position", "se")
          this.children = this.createCollection()
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-reset",
                "ck-dropdown__panel",
                e.to("position", (t) => `ck-dropdown__panel_${t}`),
                e.if("isVisible", "ck-dropdown__panel-visible"),
              ],
            },
            children: this.children,
            on: {
              selectstart: e.to((t) => {
                if (t.target.tagName.toLocaleLowerCase() === "input") {
                  return
                }
                t.preventDefault()
              }),
            },
          })
        }
        focus() {
          if (this.children.length) {
            const t = this.children.first
            if (typeof t.focus === "function") {
              t.focus()
            } else {
              B("ui-dropdown-panel-focus-child-missing-focus", {
                childView: this.children.first,
                dropdownPanel: this,
              })
            }
          }
        }
        focusLast() {
          if (this.children.length) {
            const t = this.children.last
            if (typeof t.focusLast === "function") {
              t.focusLast()
            } else {
              t.focus()
            }
          }
        }
      }
      var ch = n(488)
      var lh = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      lh.insert = "head"
      lh.singleton = true
      var dh = Bl()(ch.Z, lh)
      const hh = ch.Z.locals || {}
      class uh extends zl {
        constructor(t, e, n) {
          super(t)
          const o = this.bindTemplate
          this.buttonView = e
          this.panelView = n
          this.set("isOpen", false)
          this.set("isEnabled", true)
          this.set("class", undefined)
          this.set("id", undefined)
          this.set("panelPosition", "auto")
          this.keystrokes = new fl()
          this.focusTracker = new ul()
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-dropdown",
                o.to("class"),
                o.if("isEnabled", "ck-disabled", (t) => !t),
              ],
              id: o.to("id"),
              "aria-describedby": o.to("ariaDescribedById"),
            },
            children: [e, n],
          })
          e.extendTemplate({
            attributes: {
              class: ["ck-dropdown__button"],
              "data-cke-tooltip-disabled": o.to("isOpen"),
            },
          })
        }
        render() {
          super.render()
          this.focusTracker.add(this.buttonView.element)
          this.focusTracker.add(this.panelView.element)
          this.listenTo(this.buttonView, "open", () => {
            this.isOpen = !this.isOpen
          })
          this.panelView.bind("isVisible").to(this, "isOpen")
          this.on("change:isOpen", (t, e, n) => {
            if (!n) {
              return
            }
            if (this.panelPosition === "auto") {
              this.panelView.position = uh._getOptimalPosition({
                element: this.panelView.element,
                target: this.buttonView.element,
                fitInViewport: true,
                positions: this._panelPositions,
              }).name
            } else {
              this.panelView.position = this.panelPosition
            }
          })
          this.keystrokes.listenTo(this.element)
          const t = (t, e) => {
            if (this.isOpen) {
              this.isOpen = false
              e()
            }
          }
          this.keystrokes.set("arrowdown", (t, e) => {
            if (this.buttonView.isEnabled && !this.isOpen) {
              this.isOpen = true
              e()
            }
          })
          this.keystrokes.set("arrowright", (t, e) => {
            if (this.isOpen) {
              e()
            }
          })
          this.keystrokes.set("arrowleft", t)
          this.keystrokes.set("esc", t)
        }
        focus() {
          this.buttonView.focus()
        }
        get _panelPositions() {
          const {
            south: t,
            north: e,
            southEast: n,
            southWest: o,
            northEast: r,
            northWest: i,
            southMiddleEast: s,
            southMiddleWest: a,
            northMiddleEast: c,
            northMiddleWest: l,
          } = uh.defaultPanelPositions
          if (this.locale.uiLanguageDirection !== "rtl") {
            return [n, o, s, a, t, r, i, c, l, e]
          } else {
            return [o, n, a, s, t, i, r, l, c, e]
          }
        }
      }
      uh.defaultPanelPositions = {
        south: (t, e) => ({ top: t.bottom, left: t.left - (e.width - t.width) / 2, name: "s" }),
        southEast: (t) => ({ top: t.bottom, left: t.left, name: "se" }),
        southWest: (t, e) => ({ top: t.bottom, left: t.left - e.width + t.width, name: "sw" }),
        southMiddleEast: (t, e) => ({
          top: t.bottom,
          left: t.left - (e.width - t.width) / 4,
          name: "sme",
        }),
        southMiddleWest: (t, e) => ({
          top: t.bottom,
          left: t.left - ((e.width - t.width) * 3) / 4,
          name: "smw",
        }),
        north: (t, e) => ({
          top: t.top - e.height,
          left: t.left - (e.width - t.width) / 2,
          name: "n",
        }),
        northEast: (t, e) => ({ top: t.top - e.height, left: t.left, name: "ne" }),
        northWest: (t, e) => ({
          top: t.top - e.height,
          left: t.left - e.width + t.width,
          name: "nw",
        }),
        northMiddleEast: (t, e) => ({
          top: t.top - e.height,
          left: t.left - (e.width - t.width) / 4,
          name: "nme",
        }),
        northMiddleWest: (t, e) => ({
          top: t.top - e.height,
          left: t.left - ((e.width - t.width) * 3) / 4,
          name: "nmw",
        }),
      }
      uh._getOptimalPosition = Ac
      const fh =
        '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>'
      class ph extends vd {
        constructor(t) {
          super(t)
          this.arrowView = this._createArrowView()
          this.extendTemplate({
            attributes: {
              "aria-haspopup": true,
              "aria-expanded": this.bindTemplate.to("isOn", (t) => String(t)),
            },
          })
          this.delegate("execute").to(this, "open")
        }
        render() {
          super.render()
          this.children.add(this.arrowView)
        }
        _createArrowView() {
          const t = new md()
          t.content = fh
          t.extendTemplate({ attributes: { class: "ck-dropdown__arrow" } })
          return t
        }
      }
      class gh {
        constructor(t) {
          this.focusables = t.focusables
          this.focusTracker = t.focusTracker
          this.keystrokeHandler = t.keystrokeHandler
          this.actions = t.actions
          if (t.actions && t.keystrokeHandler) {
            for (const e in t.actions) {
              let n = t.actions[e]
              if (typeof n == "string") {
                n = [n]
              }
              for (const o of n) {
                t.keystrokeHandler.set(o, (t, n) => {
                  this[e]()
                  n()
                })
              }
            }
          }
        }
        get first() {
          return this.focusables.find(mh) || null
        }
        get last() {
          return this.focusables.filter(mh).slice(-1)[0] || null
        }
        get next() {
          return this._getFocusableItem(1)
        }
        get previous() {
          return this._getFocusableItem(-1)
        }
        get current() {
          let t = null
          if (this.focusTracker.focusedElement === null) {
            return null
          }
          this.focusables.find((e, n) => {
            const o = e.element === this.focusTracker.focusedElement
            if (o) {
              t = n
            }
            return o
          })
          return t
        }
        focusFirst() {
          this._focus(this.first)
        }
        focusLast() {
          this._focus(this.last)
        }
        focusNext() {
          this._focus(this.next)
        }
        focusPrevious() {
          this._focus(this.previous)
        }
        _focus(t) {
          if (t) {
            t.focus()
          }
        }
        _getFocusableItem(t) {
          const e = this.current
          const n = this.focusables.length
          if (!n) {
            return null
          }
          if (e === null) {
            return this[t === 1 ? "first" : "last"]
          }
          let o = (e + n + t) % n
          do {
            const e = this.focusables.get(o)
            if (mh(e)) {
              return e
            }
            o = (o + n + t) % n
          } while (o !== e)
          return null
        }
      }
      function mh(t) {
        return !!(t.focus && _c(t.element))
      }
      class kh extends zl {
        constructor(t) {
          super(t)
          this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__separator"] } })
        }
      }
      class bh extends zl {
        constructor(t) {
          super(t)
          this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__line-break"] } })
        }
      }
      function wh(t) {
        return t.bindTemplate.to((e) => {
          if (e.target === t.element) {
            e.preventDefault()
          }
        })
      }
      function _h(t) {
        if (Array.isArray(t)) {
          return { items: t, removeItems: [] }
        }
        if (!t) {
          return { items: [], removeItems: [] }
        }
        return Object.assign({ items: [], removeItems: [] }, t)
      }
      class vh extends dt() {
        constructor(t) {
          super()
          this._disableStack = new Set()
          this.editor = t
          this.set("isEnabled", true)
        }
        forceDisabled(t) {
          this._disableStack.add(t)
          if (this._disableStack.size == 1) {
            this.on("set:isEnabled", Ah, { priority: "highest" })
            this.isEnabled = false
          }
        }
        clearForceDisabled(t) {
          this._disableStack.delete(t)
          if (this._disableStack.size == 0) {
            this.off("set:isEnabled", Ah)
            this.isEnabled = true
          }
        }
        destroy() {
          this.stopListening()
        }
        static get isContextPlugin() {
          return false
        }
      }
      function Ah(t) {
        t.return = false
        t.stop()
      }
      class Ch extends dt() {
        constructor(t) {
          super()
          this.editor = t
          this.set("value", undefined)
          this.set("isEnabled", false)
          this._affectsData = true
          this._isEnabledBasedOnSelection = true
          this._disableStack = new Set()
          this.decorate("execute")
          this.listenTo(this.editor.model.document, "change", () => {
            this.refresh()
          })
          this.listenTo(t, "change:isReadOnly", () => {
            this.refresh()
          })
          this.on(
            "set:isEnabled",
            (e) => {
              if (!this.affectsData) {
                return
              }
              if (
                t.isReadOnly ||
                (this._isEnabledBasedOnSelection && !t.model.canEditAt(t.model.document.selection))
              ) {
                e.return = false
                e.stop()
              }
            },
            { priority: "highest" }
          )
          this.on(
            "execute",
            (t) => {
              if (!this.isEnabled) {
                t.stop()
              }
            },
            { priority: "high" }
          )
        }
        get affectsData() {
          return this._affectsData
        }
        set affectsData(t) {
          this._affectsData = t
        }
        refresh() {
          this.isEnabled = true
        }
        forceDisabled(t) {
          this._disableStack.add(t)
          if (this._disableStack.size == 1) {
            this.on("set:isEnabled", yh, { priority: "highest" })
            this.isEnabled = false
          }
        }
        clearForceDisabled(t) {
          this._disableStack.delete(t)
          if (this._disableStack.size == 0) {
            this.off("set:isEnabled", yh)
            this.refresh()
          }
        }
        execute(...t) {
          return undefined
        }
        destroy() {
          this.stopListening()
        }
      }
      function yh(t) {
        t.return = false
        t.stop()
      }
      class xh extends (null && Command) {
        constructor() {
          super(...arguments)
          this._childCommandsDefinitions = []
        }
        refresh() {}
        execute(...t) {
          const e = this._getFirstEnabledCommand()
          return !!e && e.execute(t)
        }
        registerChildCommand(t, e = {}) {
          insertToPriorityArray(this._childCommandsDefinitions, {
            command: t,
            priority: e.priority || "normal",
          })
          t.on("change:isEnabled", () => this._checkEnabled())
          this._checkEnabled()
        }
        _checkEnabled() {
          this.isEnabled = !!this._getFirstEnabledCommand()
        }
        _getFirstEnabledCommand() {
          const t = this._childCommandsDefinitions.find(({ command: t }) => t.isEnabled)
          return t && t.command
        }
      }
      class Eh extends q() {
        constructor(t, e = [], n = []) {
          super()
          this._plugins = new Map()
          this._context = t
          this._availablePlugins = new Map()
          for (const t of e) {
            if (t.pluginName) {
              this._availablePlugins.set(t.pluginName, t)
            }
          }
          this._contextPlugins = new Map()
          for (const [t, e] of n) {
            this._contextPlugins.set(t, e)
            this._contextPlugins.set(e, t)
            if (t.pluginName) {
              this._availablePlugins.set(t.pluginName, t)
            }
          }
        }
        *[Symbol.iterator]() {
          for (const t of this._plugins) {
            if (typeof t[0] == "function") {
              yield t
            }
          }
        }
        get(t) {
          const e = this._plugins.get(t)
          if (!e) {
            let e = t
            if (typeof t == "function") {
              e = t.pluginName || t.name
            }
            throw new P("plugincollection-plugin-not-loaded", this._context, { plugin: e })
          }
          return e
        }
        has(t) {
          return this._plugins.has(t)
        }
        init(t, e = [], n = []) {
          const o = this
          const r = this._context
          u(t)
          p(t)
          const i = t.filter((t) => !d(t, e))
          const s = [...f(i)]
          _(s, n)
          const a = b(s)
          return w(a, "init")
            .then(() => w(a, "afterInit"))
            .then(() => a)
          function c(t) {
            return typeof t === "function"
          }
          function l(t) {
            return c(t) && !!t.isContextPlugin
          }
          function d(t, e) {
            return e.some((e) => {
              if (e === t) {
                return true
              }
              if (h(t) === e) {
                return true
              }
              if (h(e) === t) {
                return true
              }
              return false
            })
          }
          function h(t) {
            return c(t) ? t.pluginName || t.name : t
          }
          function u(t, e = new Set()) {
            t.forEach((t) => {
              if (!c(t)) {
                return
              }
              if (e.has(t)) {
                return
              }
              e.add(t)
              if (t.pluginName && !o._availablePlugins.has(t.pluginName)) {
                o._availablePlugins.set(t.pluginName, t)
              }
              if (t.requires) {
                u(t.requires, e)
              }
            })
          }
          function f(t, e = new Set()) {
            return t
              .map((t) => (c(t) ? t : o._availablePlugins.get(t)))
              .reduce((t, n) => {
                if (e.has(n)) {
                  return t
                }
                e.add(n)
                if (n.requires) {
                  p(n.requires, n)
                  f(n.requires, e).forEach((e) => t.add(e))
                }
                return t.add(n)
              }, new Set())
          }
          function p(t, e = null) {
            t.map((t) => (c(t) ? t : o._availablePlugins.get(t) || t)).forEach((t) => {
              g(t, e)
              m(t, e)
              k(t, e)
            })
          }
          function g(t, e) {
            if (c(t)) {
              return
            }
            if (e) {
              throw new P("plugincollection-soft-required", r, {
                missingPlugin: t,
                requiredBy: h(e),
              })
            }
            throw new P("plugincollection-plugin-not-found", r, { plugin: t })
          }
          function m(t, e) {
            if (!l(e)) {
              return
            }
            if (l(t)) {
              return
            }
            throw new P("plugincollection-context-required", r, { plugin: h(t), requiredBy: h(e) })
          }
          function k(t, n) {
            if (!n) {
              return
            }
            if (!d(t, e)) {
              return
            }
            throw new P("plugincollection-required", r, { plugin: h(t), requiredBy: h(n) })
          }
          function b(t) {
            return t.map((t) => {
              let e = o._contextPlugins.get(t)
              e = e || new t(r)
              o._add(t, e)
              return e
            })
          }
          function w(t, e) {
            return t.reduce((t, n) => {
              if (!n[e]) {
                return t
              }
              if (o._contextPlugins.has(n)) {
                return t
              }
              return t.then(n[e].bind(n))
            }, Promise.resolve())
          }
          function _(t, e) {
            for (const n of e) {
              if (typeof n != "function") {
                throw new P("plugincollection-replace-plugin-invalid-type", null, { pluginItem: n })
              }
              const e = n.pluginName
              if (!e) {
                throw new P("plugincollection-replace-plugin-missing-name", null, { pluginItem: n })
              }
              if (n.requires && n.requires.length) {
                throw new P(
                  "plugincollection-plugin-for-replacing-cannot-have-dependencies",
                  null,
                  { pluginName: e }
                )
              }
              const r = o._availablePlugins.get(e)
              if (!r) {
                throw new P("plugincollection-plugin-for-replacing-not-exist", null, {
                  pluginName: e,
                })
              }
              const i = t.indexOf(r)
              if (i === -1) {
                if (o._contextPlugins.has(r)) {
                  return
                }
                throw new P("plugincollection-plugin-for-replacing-not-loaded", null, {
                  pluginName: e,
                })
              }
              if (r.requires && r.requires.length) {
                throw new P("plugincollection-replaced-plugin-cannot-have-dependencies", null, {
                  pluginName: e,
                })
              }
              t.splice(i, 1, n)
              o._availablePlugins.set(e, n)
            }
          }
        }
        destroy() {
          const t = []
          for (const [, e] of this) {
            if (typeof e.destroy == "function" && !this._contextPlugins.has(e)) {
              t.push(e.destroy())
            }
          }
          return Promise.all(t)
        }
        _add(t, e) {
          this._plugins.set(t, e)
          const n = t.pluginName
          if (!n) {
            return
          }
          if (this._plugins.has(n)) {
            throw new P("plugincollection-plugin-name-conflict", null, {
              pluginName: n,
              plugin1: this._plugins.get(n).constructor,
              plugin2: t,
            })
          }
          this._plugins.set(n, e)
        }
      }
      class Dh {
        constructor(t) {
          this._contextOwner = null
          this.config = new Ha(t, this.constructor.defaultConfig)
          const e = this.constructor.builtinPlugins
          this.config.define("plugins", e)
          this.plugins = new Eh(this, e)
          const n = this.config.get("language") || {}
          this.locale = new cl({
            uiLanguage: typeof n === "string" ? n : n.ui,
            contentLanguage: this.config.get("language.content"),
          })
          this.t = this.locale.t
          this.editors = new dl()
        }
        initPlugins() {
          const t = this.config.get("plugins") || []
          const e = this.config.get("substitutePlugins") || []
          for (const n of t.concat(e)) {
            if (typeof n != "function") {
              throw new P("context-initplugins-constructor-only", null, { Plugin: n })
            }
            if (n.isContextPlugin !== true) {
              throw new P("context-initplugins-invalid-plugin", null, { Plugin: n })
            }
          }
          return this.plugins.init(t, [], e)
        }
        destroy() {
          return Promise.all(Array.from(this.editors, (t) => t.destroy())).then(() =>
            this.plugins.destroy()
          )
        }
        _addEditor(t, e) {
          if (this._contextOwner) {
            throw new P("context-addeditor-private-context")
          }
          this.editors.add(t)
          if (e) {
            this._contextOwner = t
          }
        }
        _removeEditor(t) {
          if (this.editors.has(t)) {
            this.editors.remove(t)
          }
          if (this._contextOwner === t) {
            return this.destroy()
          }
          return Promise.resolve()
        }
        _getEditorConfig() {
          const t = {}
          for (const e of this.config.names()) {
            if (!["plugins", "removePlugins", "extraPlugins"].includes(e)) {
              t[e] = this.config.get(e)
            }
          }
          return t
        }
        static create(t) {
          return new Promise((e) => {
            const n = new this(t)
            e(n.initPlugins().then(() => n))
          })
        }
      }
      class Sh extends dt() {
        constructor(t) {
          super()
          this.context = t
        }
        destroy() {
          this.stopListening()
        }
        static get isContextPlugin() {
          return true
        }
      }
      var Th = n(894)
      var Ph = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      Ph.insert = "head"
      Ph.singleton = true
      var Bh = Bl()(Th.Z, Ph)
      const Rh = Th.Z.locals || {}
      const Oh = new WeakMap()
      function Mh({
        view: t,
        element: e,
        text: n,
        isDirectHost: o = true,
        keepOnFocus: r = false,
      }) {
        const i = t.document
        if (!Oh.has(i)) {
          Oh.set(i, new Map())
          i.registerPostFixer((t) => Vh(i, t))
          i.on(
            "change:isComposing",
            () => {
              t.change((t) => Vh(i, t))
            },
            { priority: "high" }
          )
        }
        Oh.get(i).set(e, { text: n, isDirectHost: o, keepOnFocus: r, hostElement: o ? e : null })
        t.change((t) => Vh(i, t))
      }
      function Ih(t, e) {
        const n = e.document
        if (!Oh.has(n)) {
          return
        }
        t.change((t) => {
          const o = Oh.get(n)
          const r = o.get(e)
          t.removeAttribute("data-placeholder", r.hostElement)
          Nh(t, r.hostElement)
          o.delete(e)
        })
      }
      function zh(t, e) {
        if (!e.hasClass("ck-placeholder")) {
          t.addClass("ck-placeholder", e)
          return true
        }
        return false
      }
      function Nh(t, e) {
        if (e.hasClass("ck-placeholder")) {
          t.removeClass("ck-placeholder", e)
          return true
        }
        return false
      }
      function Fh(t, e) {
        if (!t.isAttached()) {
          return false
        }
        const n = Array.from(t.getChildren()).some((t) => !t.is("uiElement"))
        if (n) {
          return false
        }
        const o = t.document
        const r = o.selection
        const i = r.anchor
        if (o.isComposing && i && i.parent === t) {
          return false
        }
        if (e) {
          return true
        }
        if (!o.isFocused) {
          return true
        }
        return !!i && i.parent !== t
      }
      function Vh(t, e) {
        const n = Oh.get(t)
        const o = []
        let r = false
        for (const [t, i] of n) {
          if (i.isDirectHost) {
            o.push(t)
            if (Lh(e, t, i)) {
              r = true
            }
          }
        }
        for (const [t, i] of n) {
          if (i.isDirectHost) {
            continue
          }
          const n = jh(t)
          if (!n) {
            continue
          }
          if (o.includes(n)) {
            continue
          }
          i.hostElement = n
          if (Lh(e, t, i)) {
            r = true
          }
        }
        return r
      }
      function Lh(t, e, n) {
        const { text: o, isDirectHost: r, hostElement: i } = n
        let s = false
        if (i.getAttribute("data-placeholder") !== o) {
          t.setAttribute("data-placeholder", o, i)
          s = true
        }
        const a = r || e.childCount == 1
        if (a && Fh(i, n.keepOnFocus)) {
          if (zh(t, i)) {
            s = true
          }
        } else if (Nh(t, i)) {
          s = true
        }
        return s
      }
      function jh(t) {
        if (t.childCount) {
          const e = t.getChild(0)
          if (e.is("element") && !e.is("uiElement") && !e.is("attributeElement")) {
            return e
          }
        }
        return null
      }
      class Hh {
        is() {
          throw new Error("is() method is abstract")
        }
      }
      var Wh = 4
      function qh(t) {
        return Ia(t, Wh)
      }
      const $h = qh
      class Kh extends q(Hh) {
        constructor(t) {
          super()
          this.document = t
          this.parent = null
        }
        get index() {
          let t
          if (!this.parent) {
            return null
          }
          if ((t = this.parent.getChildIndex(this)) == -1) {
            throw new P("view-node-not-found-in-parent", this)
          }
          return t
        }
        get nextSibling() {
          const t = this.index
          return (t !== null && this.parent.getChild(t + 1)) || null
        }
        get previousSibling() {
          const t = this.index
          return (t !== null && this.parent.getChild(t - 1)) || null
        }
        get root() {
          let t = this
          while (t.parent) {
            t = t.parent
          }
          return t
        }
        isAttached() {
          return this.root.is("rootElement")
        }
        getPath() {
          const t = []
          let e = this
          while (e.parent) {
            t.unshift(e.index)
            e = e.parent
          }
          return t
        }
        getAncestors(t = {}) {
          const e = []
          let n = t.includeSelf ? this : this.parent
          while (n) {
            e[t.parentFirst ? "push" : "unshift"](n)
            n = n.parent
          }
          return e
        }
        getCommonAncestor(t, e = {}) {
          const n = this.getAncestors(e)
          const o = t.getAncestors(e)
          let r = 0
          while (n[r] == o[r] && n[r]) {
            r++
          }
          return r === 0 ? null : n[r - 1]
        }
        isBefore(t) {
          if (this == t) {
            return false
          }
          if (this.root !== t.root) {
            return false
          }
          const e = this.getPath()
          const n = t.getPath()
          const o = Ct(e, n)
          switch (o) {
            case "prefix":
              return true
            case "extension":
              return false
            default:
              return e[o] < n[o]
          }
        }
        isAfter(t) {
          if (this == t) {
            return false
          }
          if (this.root !== t.root) {
            return false
          }
          return !this.isBefore(t)
        }
        _remove() {
          this.parent._removeChildren(this.index)
        }
        _fireChange(t, e) {
          this.fire(`change:${t}`, e)
          if (this.parent) {
            this.parent._fireChange(t, e)
          }
        }
        toJSON() {
          const t = $h(this)
          delete t.parent
          return t
        }
      }
      Kh.prototype.is = function (t) {
        return t === "node" || t === "view:node"
      }
      class Gh extends Kh {
        constructor(t, e) {
          super(t)
          this._textData = e
        }
        get data() {
          return this._textData
        }
        get _data() {
          return this.data
        }
        set _data(t) {
          this._fireChange("text", this)
          this._textData = t
        }
        isSimilar(t) {
          if (!(t instanceof Gh)) {
            return false
          }
          return this === t || this.data === t.data
        }
        _clone() {
          return new Gh(this.document, this.data)
        }
      }
      Gh.prototype.is = function (t) {
        return (
          t === "$text" ||
          t === "view:$text" ||
          t === "text" ||
          t === "view:text" ||
          t === "node" ||
          t === "view:node"
        )
      }
      class Uh extends Hh {
        constructor(t, e, n) {
          super()
          this.textNode = t
          if (e < 0 || e > t.data.length) {
            throw new P("view-textproxy-wrong-offsetintext", this)
          }
          if (n < 0 || e + n > t.data.length) {
            throw new P("view-textproxy-wrong-length", this)
          }
          this.data = t.data.substring(e, e + n)
          this.offsetInText = e
        }
        get offsetSize() {
          return this.data.length
        }
        get isPartial() {
          return this.data.length !== this.textNode.data.length
        }
        get parent() {
          return this.textNode.parent
        }
        get root() {
          return this.textNode.root
        }
        get document() {
          return this.textNode.document
        }
        getAncestors(t = {}) {
          const e = []
          let n = t.includeSelf ? this.textNode : this.parent
          while (n !== null) {
            e[t.parentFirst ? "push" : "unshift"](n)
            n = n.parent
          }
          return e
        }
      }
      Uh.prototype.is = function (t) {
        return (
          t === "$textProxy" ||
          t === "view:$textProxy" ||
          t === "textProxy" ||
          t === "view:textProxy"
        )
      }
      class Jh {
        constructor(...t) {
          this._patterns = []
          this.add(...t)
        }
        add(...t) {
          for (let e of t) {
            if (typeof e == "string" || e instanceof RegExp) {
              e = { name: e }
            }
            this._patterns.push(e)
          }
        }
        match(...t) {
          for (const e of t) {
            for (const t of this._patterns) {
              const n = Zh(e, t)
              if (n) {
                return { element: e, pattern: t, match: n }
              }
            }
          }
          return null
        }
        matchAll(...t) {
          const e = []
          for (const n of t) {
            for (const t of this._patterns) {
              const o = Zh(n, t)
              if (o) {
                e.push({ element: n, pattern: t, match: o })
              }
            }
          }
          return e.length > 0 ? e : null
        }
        getElementName() {
          if (this._patterns.length !== 1) {
            return null
          }
          const t = this._patterns[0]
          const e = t.name
          return typeof t != "function" && e && !(e instanceof RegExp) ? e : null
        }
      }
      function Zh(t, e) {
        if (typeof e == "function") {
          return e(t)
        }
        const n = {}
        if (e.name) {
          n.name = Yh(e.name, t.name)
          if (!n.name) {
            return null
          }
        }
        if (e.attributes) {
          n.attributes = nu(e.attributes, t)
          if (!n.attributes) {
            return null
          }
        }
        if (e.classes) {
          n.classes = ou(e.classes, t)
          if (!n.classes) {
            return null
          }
        }
        if (e.styles) {
          n.styles = ru(e.styles, t)
          if (!n.styles) {
            return null
          }
        }
        return n
      }
      function Yh(t, e) {
        if (t instanceof RegExp) {
          return !!e.match(t)
        }
        return t === e
      }
      function Qh(t, e, n) {
        const o = Xh(t)
        const r = Array.from(e)
        const i = []
        o.forEach(([t, e]) => {
          r.forEach((o) => {
            if (tu(t, o) && eu(e, o, n)) {
              i.push(o)
            }
          })
        })
        if (!o.length || i.length < o.length) {
          return undefined
        }
        return i
      }
      function Xh(t) {
        if (Array.isArray(t)) {
          return t.map((t) => {
            if (ue(t)) {
              if (t.key === undefined || t.value === undefined) {
                B("matcher-pattern-missing-key-or-value", t)
              }
              return [t.key, t.value]
            }
            return [t, true]
          })
        }
        if (ue(t)) {
          return Object.entries(t)
        }
        return [[t, true]]
      }
      function tu(t, e) {
        return t === true || t === e || (t instanceof RegExp && e.match(t))
      }
      function eu(t, e, n) {
        if (t === true) {
          return true
        }
        const o = n(e)
        return t === o || (t instanceof RegExp && !!String(o).match(t))
      }
      function nu(t, e) {
        const n = new Set(e.getAttributeKeys())
        if (ue(t)) {
          if (t.style !== undefined) {
            B("matcher-pattern-deprecated-attributes-style-key", t)
          }
          if (t.class !== undefined) {
            B("matcher-pattern-deprecated-attributes-class-key", t)
          }
        } else {
          n.delete("style")
          n.delete("class")
        }
        return Qh(t, n, (t) => e.getAttribute(t))
      }
      function ou(t, e) {
        return Qh(t, e.getClassNames(), () => {})
      }
      function ru(t, e) {
        return Qh(t, e.getStyleNames(true), (t) => e.getStyle(t))
      }
      var iu = "[object Symbol]"
      function su(t) {
        return typeof t == "symbol" || (Zt(t) && Kt(t) == iu)
      }
      const au = su
      var cu = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        lu = /^\w*$/
      function du(t, e) {
        if (Ut(t)) {
          return false
        }
        var n = typeof t
        if (n == "number" || n == "symbol" || n == "boolean" || t == null || au(t)) {
          return true
        }
        return lu.test(t) || !cu.test(t) || (e != null && t in Object(e))
      }
      const hu = du
      var uu = "Expected a function"
      function fu(t, e) {
        if (typeof t != "function" || (e != null && typeof e != "function")) {
          throw new TypeError(uu)
        }
        var n = function () {
          var o = arguments,
            r = e ? e.apply(this, o) : o[0],
            i = n.cache
          if (i.has(r)) {
            return i.get(r)
          }
          var s = t.apply(this, o)
          n.cache = i.set(r, s) || i
          return s
        }
        n.cache = new (fu.Cache || Yn)()
        return n
      }
      fu.Cache = Yn
      const pu = fu
      var gu = 500
      function mu(t) {
        var e = pu(t, function (t) {
          if (n.size === gu) {
            n.clear()
          }
          return t
        })
        var n = e.cache
        return e
      }
      const ku = mu
      var bu =
        /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
      var wu = /\\(\\)?/g
      var _u = ku(function (t) {
        var e = []
        if (t.charCodeAt(0) === 46) {
          e.push("")
        }
        t.replace(bu, function (t, n, o, r) {
          e.push(o ? r.replace(wu, "$1") : n || t)
        })
        return e
      })
      const vu = _u
      function Au(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length,
          r = Array(o)
        while (++n < o) {
          r[n] = e(t[n], n, t)
        }
        return r
      }
      const Cu = Au
      var yu = 1 / 0
      var xu = Bt ? Bt.prototype : undefined,
        Eu = xu ? xu.toString : undefined
      function Du(t) {
        if (typeof t == "string") {
          return t
        }
        if (Ut(t)) {
          return Cu(t, Du) + ""
        }
        if (au(t)) {
          return Eu ? Eu.call(t) : ""
        }
        var e = t + ""
        return e == "0" && 1 / t == -yu ? "-0" : e
      }
      const Su = Du
      function Tu(t) {
        return t == null ? "" : Su(t)
      }
      const Pu = Tu
      function Bu(t, e) {
        if (Ut(t)) {
          return t
        }
        return hu(t, e) ? [t] : vu(Pu(t))
      }
      const Ru = Bu
      function Ou(t) {
        var e = t == null ? 0 : t.length
        return e ? t[e - 1] : undefined
      }
      const Mu = Ou
      var Iu = 1 / 0
      function zu(t) {
        if (typeof t == "string" || au(t)) {
          return t
        }
        var e = t + ""
        return e == "0" && 1 / t == -Iu ? "-0" : e
      }
      const Nu = zu
      function Fu(t, e) {
        e = Ru(e, t)
        var n = 0,
          o = e.length
        while (t != null && n < o) {
          t = t[Nu(e[n++])]
        }
        return n && n == o ? t : undefined
      }
      const Vu = Fu
      function Lu(t, e, n) {
        var o = -1,
          r = t.length
        if (e < 0) {
          e = -e > r ? 0 : r + e
        }
        n = n > r ? r : n
        if (n < 0) {
          n += r
        }
        r = e > n ? 0 : (n - e) >>> 0
        e >>>= 0
        var i = Array(r)
        while (++o < r) {
          i[o] = t[o + e]
        }
        return i
      }
      const ju = Lu
      function Hu(t, e) {
        return e.length < 2 ? t : Vu(t, ju(e, 0, -1))
      }
      const Wu = Hu
      function qu(t, e) {
        e = Ru(e, t)
        t = Wu(t, e)
        return t == null || delete t[Nu(Mu(e))]
      }
      const $u = qu
      function Ku(t, e) {
        return t == null ? true : $u(t, e)
      }
      const Gu = Ku
      function Uu(t, e, n) {
        var o = t == null ? undefined : Vu(t, e)
        return o === undefined ? n : o
      }
      const Ju = Uu
      function Zu(t, e, n) {
        if ((n !== undefined && !me(t[e], n)) || (n === undefined && !(e in t))) {
          co(t, e, n)
        }
      }
      const Yu = Zu
      function Qu(t) {
        return function (e, n, o) {
          var r = -1,
            i = Object(e),
            s = o(e),
            a = s.length
          while (a--) {
            var c = s[t ? a : ++r]
            if (n(i[c], c, i) === false) {
              break
            }
          }
          return e
        }
      }
      const Xu = Qu
      var tf = Xu()
      const ef = tf
      function nf(t) {
        return Zt(t) && Lr(t)
      }
      const of = nf
      function rf(t, e) {
        if (e === "constructor" && typeof t[e] === "function") {
          return
        }
        if (e == "__proto__") {
          return
        }
        return t[e]
      }
      const sf = rf
      function af(t) {
        return go(t, Qr(t))
      }
      const cf = af
      function lf(t, e, n, o, r, i, s) {
        var a = sf(t, n),
          c = sf(e, n),
          l = s.get(c)
        if (l) {
          Yu(t, n, l)
          return
        }
        var d = i ? i(a, c, n + "", t, e, s) : undefined
        var h = d === undefined
        if (h) {
          var u = Ut(c),
            f = !u && Mo(c),
            p = !u && !f && xr(c)
          d = c
          if (u || f || p) {
            if (Ut(a)) {
              d = a
            } else if (of(a)) {
              d = li(a)
            } else if (f) {
              h = false
              d = ai(c, true)
            } else if (p) {
              h = false
              d = ws(c, true)
            } else {
              d = []
            }
          } else if (ue(c) || xo(c)) {
            d = a
            if (xo(a)) {
              d = cf(a)
            } else if (!ot(a) || qe(a)) {
              d = $s(c)
            }
          } else {
            h = false
          }
        }
        if (h) {
          s.set(c, d)
          r(d, c, o, i, s)
          s["delete"](c)
        }
        Yu(t, n, d)
      }
      const df = lf
      function hf(t, e, n, o, r) {
        if (t === e) {
          return
        }
        ef(
          e,
          function (i, s) {
            r || (r = new no())
            if (ot(i)) {
              df(t, e, s, n, hf, o, r)
            } else {
              var a = o ? o(sf(t, s), i, s + "", t, e, r) : undefined
              if (a === undefined) {
                a = i
              }
              Yu(t, s, a)
            }
          },
          Qr
        )
      }
      const uf = hf
      function ff(t) {
        return t
      }
      const pf = ff
      function gf(t, e, n) {
        switch (n.length) {
          case 0:
            return t.call(e)
          case 1:
            return t.call(e, n[0])
          case 2:
            return t.call(e, n[0], n[1])
          case 3:
            return t.call(e, n[0], n[1], n[2])
        }
        return t.apply(e, n)
      }
      const mf = gf
      var kf = Math.max
      function bf(t, e, n) {
        e = kf(e === undefined ? t.length - 1 : e, 0)
        return function () {
          var o = arguments,
            r = -1,
            i = kf(o.length - e, 0),
            s = Array(i)
          while (++r < i) {
            s[r] = o[e + r]
          }
          r = -1
          var a = Array(e + 1)
          while (++r < e) {
            a[r] = o[r]
          }
          a[e] = n(s)
          return mf(t, this, a)
        }
      }
      const wf = bf
      function _f(t) {
        return function () {
          return t
        }
      }
      const vf = _f
      var Af = !so
        ? pf
        : function (t, e) {
            return so(t, "toString", {
              configurable: true,
              enumerable: false,
              value: vf(e),
              writable: true,
            })
          }
      const Cf = Af
      var yf = 800,
        xf = 16
      var Ef = Date.now
      function Df(t) {
        var e = 0,
          n = 0
        return function () {
          var o = Ef(),
            r = xf - (o - n)
          n = o
          if (r > 0) {
            if (++e >= yf) {
              return arguments[0]
            }
          } else {
            e = 0
          }
          return t.apply(undefined, arguments)
        }
      }
      const Sf = Df
      var Tf = Sf(Cf)
      const Pf = Tf
      function Bf(t, e) {
        return Pf(wf(t, e, pf), t + "")
      }
      const Rf = Bf
      function Of(t, e, n) {
        if (!ot(n)) {
          return false
        }
        var o = typeof e
        if (o == "number" ? Lr(n) && Fo(e, n.length) : o == "string" && e in n) {
          return me(n[e], t)
        }
        return false
      }
      const Mf = Of
      function If(t) {
        return Rf(function (e, n) {
          var o = -1,
            r = n.length,
            i = r > 1 ? n[r - 1] : undefined,
            s = r > 2 ? n[2] : undefined
          i = t.length > 3 && typeof i == "function" ? (r--, i) : undefined
          if (s && Mf(n[0], n[1], s)) {
            i = r < 3 ? undefined : i
            r = 1
          }
          e = Object(e)
          while (++o < r) {
            var a = n[o]
            if (a) {
              t(e, a, o, i)
            }
          }
          return e
        })
      }
      const zf = If
      var Nf = zf(function (t, e, n) {
        uf(t, e, n)
      })
      const Ff = Nf
      function Vf(t, e, n, o) {
        if (!ot(t)) {
          return t
        }
        e = Ru(e, t)
        var r = -1,
          i = e.length,
          s = i - 1,
          a = t
        while (a != null && ++r < i) {
          var c = Nu(e[r]),
            l = n
          if (c === "__proto__" || c === "constructor" || c === "prototype") {
            return t
          }
          if (r != s) {
            var d = a[c]
            l = o ? o(d, c, a) : undefined
            if (l === undefined) {
              l = ot(d) ? d : Fo(e[r + 1]) ? [] : {}
            }
          }
          fo(a, c, l)
          a = a[c]
        }
        return t
      }
      const Lf = Vf
      function jf(t, e, n) {
        return t == null ? t : Lf(t, e, n)
      }
      const Hf = jf
      class Wf {
        constructor(t) {
          this._styles = {}
          this._styleProcessor = t
        }
        get isEmpty() {
          const t = Object.entries(this._styles)
          const e = Array.from(t)
          return !e.length
        }
        get size() {
          if (this.isEmpty) {
            return 0
          }
          return this.getStyleNames().length
        }
        setTo(t) {
          this.clear()
          const e = Array.from($f(t).entries())
          for (const [t, n] of e) {
            this._styleProcessor.toNormalizedForm(t, n, this._styles)
          }
        }
        has(t) {
          if (this.isEmpty) {
            return false
          }
          const e = this._styleProcessor.getReducedForm(t, this._styles)
          const n = e.find(([e]) => e === t)
          return Array.isArray(n)
        }
        set(t, e) {
          if (ot(t)) {
            for (const [e, n] of Object.entries(t)) {
              this._styleProcessor.toNormalizedForm(e, n, this._styles)
            }
          } else {
            this._styleProcessor.toNormalizedForm(t, e, this._styles)
          }
        }
        remove(t) {
          const e = Kf(t)
          Gu(this._styles, e)
          delete this._styles[t]
          this._cleanEmptyObjectsOnPath(e)
        }
        getNormalized(t) {
          return this._styleProcessor.getNormalized(t, this._styles)
        }
        toString() {
          if (this.isEmpty) {
            return ""
          }
          return (
            this._getStylesEntries()
              .map((t) => t.join(":"))
              .sort()
              .join(";") + ";"
          )
        }
        getAsString(t) {
          if (this.isEmpty) {
            return
          }
          if (this._styles[t] && !ot(this._styles[t])) {
            return this._styles[t]
          }
          const e = this._styleProcessor.getReducedForm(t, this._styles)
          const n = e.find(([e]) => e === t)
          if (Array.isArray(n)) {
            return n[1]
          }
        }
        getStyleNames(t = false) {
          if (this.isEmpty) {
            return []
          }
          if (t) {
            return this._styleProcessor.getStyleNames(this._styles)
          }
          const e = this._getStylesEntries()
          return e.map(([t]) => t)
        }
        clear() {
          this._styles = {}
        }
        _getStylesEntries() {
          const t = []
          const e = Object.keys(this._styles)
          for (const n of e) {
            t.push(...this._styleProcessor.getReducedForm(n, this._styles))
          }
          return t
        }
        _cleanEmptyObjectsOnPath(t) {
          const e = t.split(".")
          const n = e.length > 1
          if (!n) {
            return
          }
          const o = e.splice(0, e.length - 1).join(".")
          const r = Ju(this._styles, o)
          if (!r) {
            return
          }
          const i = !Array.from(Object.keys(r)).length
          if (i) {
            this.remove(o)
          }
        }
      }
      class qf {
        constructor() {
          this._normalizers = new Map()
          this._extractors = new Map()
          this._reducers = new Map()
          this._consumables = new Map()
        }
        toNormalizedForm(t, e, n) {
          if (ot(e)) {
            Gf(n, Kf(t), e)
            return
          }
          if (this._normalizers.has(t)) {
            const o = this._normalizers.get(t)
            const { path: r, value: i } = o(e)
            Gf(n, r, i)
          } else {
            Gf(n, t, e)
          }
        }
        getNormalized(t, e) {
          if (!t) {
            return Ff({}, e)
          }
          if (e[t] !== undefined) {
            return e[t]
          }
          if (this._extractors.has(t)) {
            const n = this._extractors.get(t)
            if (typeof n === "string") {
              return Ju(e, n)
            }
            const o = n(t, e)
            if (o) {
              return o
            }
          }
          return Ju(e, Kf(t))
        }
        getReducedForm(t, e) {
          const n = this.getNormalized(t, e)
          if (n === undefined) {
            return []
          }
          if (this._reducers.has(t)) {
            const e = this._reducers.get(t)
            return e(n)
          }
          return [[t, n]]
        }
        getStyleNames(t) {
          const e = Array.from(this._consumables.keys()).filter((e) => {
            const n = this.getNormalized(e, t)
            if (n && typeof n == "object") {
              return Object.keys(n).length
            }
            return n
          })
          const n = new Set([...e, ...Object.keys(t)])
          return Array.from(n.values())
        }
        getRelatedStyles(t) {
          return this._consumables.get(t) || []
        }
        setNormalizer(t, e) {
          this._normalizers.set(t, e)
        }
        setExtractor(t, e) {
          this._extractors.set(t, e)
        }
        setReducer(t, e) {
          this._reducers.set(t, e)
        }
        setStyleRelation(t, e) {
          this._mapStyleNames(t, e)
          for (const n of e) {
            this._mapStyleNames(n, [t])
          }
        }
        _mapStyleNames(t, e) {
          if (!this._consumables.has(t)) {
            this._consumables.set(t, [])
          }
          this._consumables.get(t).push(...e)
        }
      }
      function $f(t) {
        let e = null
        let n = 0
        let o = 0
        let r = null
        const i = new Map()
        if (t === "") {
          return i
        }
        if (t.charAt(t.length - 1) != ";") {
          t = t + ";"
        }
        for (let s = 0; s < t.length; s++) {
          const a = t.charAt(s)
          if (e === null) {
            switch (a) {
              case ":":
                if (!r) {
                  r = t.substr(n, s - n)
                  o = s + 1
                }
                break
              case '"':
              case "'":
                e = a
                break
              case ";": {
                const e = t.substr(o, s - o)
                if (r) {
                  i.set(r.trim(), e.trim())
                }
                r = null
                n = s + 1
                break
              }
            }
          } else if (a === e) {
            e = null
          }
        }
        return i
      }
      function Kf(t) {
        return t.replace("-", ".")
      }
      function Gf(t, e, n) {
        let o = n
        if (ot(n)) {
          o = Ff({}, Ju(t, e), n)
        }
        Hf(t, e, o)
      }
      class Uf extends Kh {
        constructor(t, e, n, o) {
          super(t)
          this._unsafeAttributesToRender = []
          this._customProperties = new Map()
          this.name = e
          this._attrs = Jf(n)
          this._children = []
          if (o) {
            this._insertChild(0, o)
          }
          this._classes = new Set()
          if (this._attrs.has("class")) {
            const t = this._attrs.get("class")
            Zf(this._classes, t)
            this._attrs.delete("class")
          }
          this._styles = new Wf(this.document.stylesProcessor)
          if (this._attrs.has("style")) {
            this._styles.setTo(this._attrs.get("style"))
            this._attrs.delete("style")
          }
        }
        get childCount() {
          return this._children.length
        }
        get isEmpty() {
          return this._children.length === 0
        }
        getChild(t) {
          return this._children[t]
        }
        getChildIndex(t) {
          return this._children.indexOf(t)
        }
        getChildren() {
          return this._children[Symbol.iterator]()
        }
        *getAttributeKeys() {
          if (this._classes.size > 0) {
            yield "class"
          }
          if (!this._styles.isEmpty) {
            yield "style"
          }
          yield* this._attrs.keys()
        }
        *getAttributes() {
          yield* this._attrs.entries()
          if (this._classes.size > 0) {
            yield ["class", this.getAttribute("class")]
          }
          if (!this._styles.isEmpty) {
            yield ["style", this.getAttribute("style")]
          }
        }
        getAttribute(t) {
          if (t == "class") {
            if (this._classes.size > 0) {
              return [...this._classes].join(" ")
            }
            return undefined
          }
          if (t == "style") {
            const t = this._styles.toString()
            return t == "" ? undefined : t
          }
          return this._attrs.get(t)
        }
        hasAttribute(t) {
          if (t == "class") {
            return this._classes.size > 0
          }
          if (t == "style") {
            return !this._styles.isEmpty
          }
          return this._attrs.has(t)
        }
        isSimilar(t) {
          if (!(t instanceof Uf)) {
            return false
          }
          if (this === t) {
            return true
          }
          if (this.name != t.name) {
            return false
          }
          if (
            this._attrs.size !== t._attrs.size ||
            this._classes.size !== t._classes.size ||
            this._styles.size !== t._styles.size
          ) {
            return false
          }
          for (const [e, n] of this._attrs) {
            if (!t._attrs.has(e) || t._attrs.get(e) !== n) {
              return false
            }
          }
          for (const e of this._classes) {
            if (!t._classes.has(e)) {
              return false
            }
          }
          for (const e of this._styles.getStyleNames()) {
            if (!t._styles.has(e) || t._styles.getAsString(e) !== this._styles.getAsString(e)) {
              return false
            }
          }
          return true
        }
        hasClass(...t) {
          for (const e of t) {
            if (!this._classes.has(e)) {
              return false
            }
          }
          return true
        }
        getClassNames() {
          return this._classes.keys()
        }
        getStyle(t) {
          return this._styles.getAsString(t)
        }
        getNormalizedStyle(t) {
          return this._styles.getNormalized(t)
        }
        getStyleNames(t) {
          return this._styles.getStyleNames(t)
        }
        hasStyle(...t) {
          for (const e of t) {
            if (!this._styles.has(e)) {
              return false
            }
          }
          return true
        }
        findAncestor(...t) {
          const e = new Jh(...t)
          let n = this.parent
          while (n && !n.is("documentFragment")) {
            if (e.match(n)) {
              return n
            }
            n = n.parent
          }
          return null
        }
        getCustomProperty(t) {
          return this._customProperties.get(t)
        }
        *getCustomProperties() {
          yield* this._customProperties.entries()
        }
        getIdentity() {
          const t = Array.from(this._classes).sort().join(",")
          const e = this._styles.toString()
          const n = Array.from(this._attrs)
            .map((t) => `${t[0]}="${t[1]}"`)
            .sort()
            .join(" ")
          return (
            this.name +
            (t == "" ? "" : ` class="${t}"`) +
            (!e ? "" : ` style="${e}"`) +
            (n == "" ? "" : ` ${n}`)
          )
        }
        shouldRenderUnsafeAttribute(t) {
          return this._unsafeAttributesToRender.includes(t)
        }
        _clone(t = false) {
          const e = []
          if (t) {
            for (const n of this.getChildren()) {
              e.push(n._clone(t))
            }
          }
          const n = new this.constructor(this.document, this.name, this._attrs, e)
          n._classes = new Set(this._classes)
          n._styles.set(this._styles.getNormalized())
          n._customProperties = new Map(this._customProperties)
          n.getFillerOffset = this.getFillerOffset
          n._unsafeAttributesToRender = this._unsafeAttributesToRender
          return n
        }
        _appendChild(t) {
          return this._insertChild(this.childCount, t)
        }
        _insertChild(t, e) {
          this._fireChange("children", this)
          let n = 0
          const o = Yf(this.document, e)
          for (const e of o) {
            if (e.parent !== null) {
              e._remove()
            }
            e.parent = this
            e.document = this.document
            this._children.splice(t, 0, e)
            t++
            n++
          }
          return n
        }
        _removeChildren(t, e = 1) {
          this._fireChange("children", this)
          for (let n = t; n < t + e; n++) {
            this._children[n].parent = null
          }
          return this._children.splice(t, e)
        }
        _setAttribute(t, e) {
          const n = String(e)
          this._fireChange("attributes", this)
          if (t == "class") {
            Zf(this._classes, n)
          } else if (t == "style") {
            this._styles.setTo(n)
          } else {
            this._attrs.set(t, n)
          }
        }
        _removeAttribute(t) {
          this._fireChange("attributes", this)
          if (t == "class") {
            if (this._classes.size > 0) {
              this._classes.clear()
              return true
            }
            return false
          }
          if (t == "style") {
            if (!this._styles.isEmpty) {
              this._styles.clear()
              return true
            }
            return false
          }
          return this._attrs.delete(t)
        }
        _addClass(t) {
          this._fireChange("attributes", this)
          for (const e of tl(t)) {
            this._classes.add(e)
          }
        }
        _removeClass(t) {
          this._fireChange("attributes", this)
          for (const e of tl(t)) {
            this._classes.delete(e)
          }
        }
        _setStyle(t, e) {
          this._fireChange("attributes", this)
          if (typeof t != "string") {
            this._styles.set(t)
          } else {
            this._styles.set(t, e)
          }
        }
        _removeStyle(t) {
          this._fireChange("attributes", this)
          for (const e of tl(t)) {
            this._styles.remove(e)
          }
        }
        _setCustomProperty(t, e) {
          this._customProperties.set(t, e)
        }
        _removeCustomProperty(t) {
          return this._customProperties.delete(t)
        }
      }
      Uf.prototype.is = function (t, e) {
        if (!e) {
          return t === "element" || t === "view:element" || t === "node" || t === "view:node"
        } else {
          return e === this.name && (t === "element" || t === "view:element")
        }
      }
      function Jf(t) {
        const e = gl(t)
        for (const [t, n] of e) {
          if (n === null) {
            e.delete(t)
          } else if (typeof n != "string") {
            e.set(t, String(n))
          }
        }
        return e
      }
      function Zf(t, e) {
        const n = e.split(/\s+/)
        t.clear()
        n.forEach((e) => t.add(e))
      }
      function Yf(t, e) {
        if (typeof e == "string") {
          return [new Gh(t, e)]
        }
        if (!yt(e)) {
          e = [e]
        }
        return Array.from(e).map((e) => {
          if (typeof e == "string") {
            return new Gh(t, e)
          }
          if (e instanceof Uh) {
            return new Gh(t, e.data)
          }
          return e
        })
      }
      class Qf extends Uf {
        constructor(t, e, n, o) {
          super(t, e, n, o)
          this.getFillerOffset = Xf
        }
      }
      Qf.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "containerElement" ||
            t === "view:containerElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          )
        } else {
          return (
            e === this.name &&
            (t === "containerElement" ||
              t === "view:containerElement" ||
              t === "element" ||
              t === "view:element")
          )
        }
      }
      function Xf() {
        const t = [...this.getChildren()]
        const e = t[this.childCount - 1]
        if (e && e.is("element", "br")) {
          return this.childCount
        }
        for (const e of t) {
          if (!e.is("uiElement")) {
            return null
          }
        }
        return this.childCount
      }
      class tp extends dt(Qf) {
        constructor(t, e, n, o) {
          super(t, e, n, o)
          this.set("isReadOnly", false)
          this.set("isFocused", false)
          this.bind("isReadOnly").to(t)
          this.bind("isFocused").to(t, "isFocused", (e) => e && t.selection.editableElement == this)
          this.listenTo(t.selection, "change", () => {
            this.isFocused = t.isFocused && t.selection.editableElement == this
          })
        }
        destroy() {
          this.stopListening()
        }
      }
      tp.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "editableElement" ||
            t === "view:editableElement" ||
            t === "containerElement" ||
            t === "view:containerElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          )
        } else {
          return (
            e === this.name &&
            (t === "editableElement" ||
              t === "view:editableElement" ||
              t === "containerElement" ||
              t === "view:containerElement" ||
              t === "element" ||
              t === "view:element")
          )
        }
      }
      const ep = Symbol("rootName")
      class np extends tp {
        constructor(t, e) {
          super(t, e)
          this.rootName = "main"
        }
        get rootName() {
          return this.getCustomProperty(ep)
        }
        set rootName(t) {
          this._setCustomProperty(ep, t)
        }
        set _name(t) {
          this.name = t
        }
      }
      np.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "rootElement" ||
            t === "view:rootElement" ||
            t === "editableElement" ||
            t === "view:editableElement" ||
            t === "containerElement" ||
            t === "view:containerElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          )
        } else {
          return (
            e === this.name &&
            (t === "rootElement" ||
              t === "view:rootElement" ||
              t === "editableElement" ||
              t === "view:editableElement" ||
              t === "containerElement" ||
              t === "view:containerElement" ||
              t === "element" ||
              t === "view:element")
          )
        }
      }
      class op {
        constructor(t = {}) {
          if (!t.boundaries && !t.startPosition) {
            throw new P("view-tree-walker-no-start-position", null)
          }
          if (t.direction && t.direction != "forward" && t.direction != "backward") {
            throw new P("view-tree-walker-unknown-direction", t.startPosition, {
              direction: t.direction,
            })
          }
          this.boundaries = t.boundaries || null
          if (t.startPosition) {
            this._position = rp._createAt(t.startPosition)
          } else {
            this._position = rp._createAt(t.boundaries[t.direction == "backward" ? "end" : "start"])
          }
          this.direction = t.direction || "forward"
          this.singleCharacters = !!t.singleCharacters
          this.shallow = !!t.shallow
          this.ignoreElementEnd = !!t.ignoreElementEnd
          this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null
          this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null
        }
        [Symbol.iterator]() {
          return this
        }
        get position() {
          return this._position
        }
        skip(t) {
          let e
          let n
          do {
            n = this.position
            e = this.next()
          } while (!e.done && t(e.value))
          if (!e.done) {
            this._position = n
          }
        }
        next() {
          if (this.direction == "forward") {
            return this._next()
          } else {
            return this._previous()
          }
        }
        _next() {
          let t = this.position.clone()
          const e = this.position
          const n = t.parent
          if (n.parent === null && t.offset === n.childCount) {
            return { done: true, value: undefined }
          }
          if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset) {
            return { done: true, value: undefined }
          }
          let o
          if (n instanceof Gh) {
            if (t.isAtEnd) {
              this._position = rp._createAfter(n)
              return this._next()
            }
            o = n.data[t.offset]
          } else {
            o = n.getChild(t.offset)
          }
          if (o instanceof Uf) {
            if (!this.shallow) {
              t = new rp(o, 0)
            } else {
              if (this.boundaries && this.boundaries.end.isBefore(t)) {
                return { done: true, value: undefined }
              }
              t.offset++
            }
            this._position = t
            return this._formatReturnValue("elementStart", o, e, t, 1)
          }
          if (o instanceof Gh) {
            if (this.singleCharacters) {
              t = new rp(o, 0)
              this._position = t
              return this._next()
            }
            let n = o.data.length
            let r
            if (o == this._boundaryEndParent) {
              n = this.boundaries.end.offset
              r = new Uh(o, 0, n)
              t = rp._createAfter(r)
            } else {
              r = new Uh(o, 0, o.data.length)
              t.offset++
            }
            this._position = t
            return this._formatReturnValue("text", r, e, t, n)
          }
          if (typeof o == "string") {
            let o
            if (this.singleCharacters) {
              o = 1
            } else {
              const e = n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length
              o = e - t.offset
            }
            const r = new Uh(n, t.offset, o)
            t.offset += o
            this._position = t
            return this._formatReturnValue("text", r, e, t, o)
          }
          t = rp._createAfter(n)
          this._position = t
          if (this.ignoreElementEnd) {
            return this._next()
          }
          return this._formatReturnValue("elementEnd", n, e, t)
        }
        _previous() {
          let t = this.position.clone()
          const e = this.position
          const n = t.parent
          if (n.parent === null && t.offset === 0) {
            return { done: true, value: undefined }
          }
          if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset) {
            return { done: true, value: undefined }
          }
          let o
          if (n instanceof Gh) {
            if (t.isAtStart) {
              this._position = rp._createBefore(n)
              return this._previous()
            }
            o = n.data[t.offset - 1]
          } else {
            o = n.getChild(t.offset - 1)
          }
          if (o instanceof Uf) {
            if (this.shallow) {
              t.offset--
              this._position = t
              return this._formatReturnValue("elementStart", o, e, t, 1)
            }
            t = new rp(o, o.childCount)
            this._position = t
            if (this.ignoreElementEnd) {
              return this._previous()
            }
            return this._formatReturnValue("elementEnd", o, e, t)
          }
          if (o instanceof Gh) {
            if (this.singleCharacters) {
              t = new rp(o, o.data.length)
              this._position = t
              return this._previous()
            }
            let n = o.data.length
            let r
            if (o == this._boundaryStartParent) {
              const e = this.boundaries.start.offset
              r = new Uh(o, e, o.data.length - e)
              n = r.data.length
              t = rp._createBefore(r)
            } else {
              r = new Uh(o, 0, o.data.length)
              t.offset--
            }
            this._position = t
            return this._formatReturnValue("text", r, e, t, n)
          }
          if (typeof o == "string") {
            let o
            if (!this.singleCharacters) {
              const e = n === this._boundaryStartParent ? this.boundaries.start.offset : 0
              o = t.offset - e
            } else {
              o = 1
            }
            t.offset -= o
            const r = new Uh(n, t.offset, o)
            this._position = t
            return this._formatReturnValue("text", r, e, t, o)
          }
          t = rp._createBefore(n)
          this._position = t
          return this._formatReturnValue("elementStart", n, e, t, 1)
        }
        _formatReturnValue(t, e, n, o, r) {
          if (e instanceof Uh) {
            if (e.offsetInText + e.data.length == e.textNode.data.length) {
              if (
                this.direction == "forward" &&
                !(this.boundaries && this.boundaries.end.isEqual(this.position))
              ) {
                o = rp._createAfter(e.textNode)
                this._position = o
              } else {
                n = rp._createAfter(e.textNode)
              }
            }
            if (e.offsetInText === 0) {
              if (
                this.direction == "backward" &&
                !(this.boundaries && this.boundaries.start.isEqual(this.position))
              ) {
                o = rp._createBefore(e.textNode)
                this._position = o
              } else {
                n = rp._createBefore(e.textNode)
              }
            }
          }
          return {
            done: false,
            value: { type: t, item: e, previousPosition: n, nextPosition: o, length: r },
          }
        }
      }
      class rp extends Hh {
        constructor(t, e) {
          super()
          this.parent = t
          this.offset = e
        }
        get nodeAfter() {
          if (this.parent.is("$text")) {
            return null
          }
          return this.parent.getChild(this.offset) || null
        }
        get nodeBefore() {
          if (this.parent.is("$text")) {
            return null
          }
          return this.parent.getChild(this.offset - 1) || null
        }
        get isAtStart() {
          return this.offset === 0
        }
        get isAtEnd() {
          const t = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount
          return this.offset === t
        }
        get root() {
          return this.parent.root
        }
        get editableElement() {
          let t = this.parent
          while (!(t instanceof tp)) {
            if (t.parent) {
              t = t.parent
            } else {
              return null
            }
          }
          return t
        }
        getShiftedBy(t) {
          const e = rp._createAt(this)
          const n = e.offset + t
          e.offset = n < 0 ? 0 : n
          return e
        }
        getLastMatchingPosition(t, e = {}) {
          e.startPosition = this
          const n = new op(e)
          n.skip(t)
          return n.position
        }
        getAncestors() {
          if (this.parent.is("documentFragment")) {
            return [this.parent]
          } else {
            return this.parent.getAncestors({ includeSelf: true })
          }
        }
        getCommonAncestor(t) {
          const e = this.getAncestors()
          const n = t.getAncestors()
          let o = 0
          while (e[o] == n[o] && e[o]) {
            o++
          }
          return o === 0 ? null : e[o - 1]
        }
        isEqual(t) {
          return this.parent == t.parent && this.offset == t.offset
        }
        isBefore(t) {
          return this.compareWith(t) == "before"
        }
        isAfter(t) {
          return this.compareWith(t) == "after"
        }
        compareWith(t) {
          if (this.root !== t.root) {
            return "different"
          }
          if (this.isEqual(t)) {
            return "same"
          }
          const e = this.parent.is("node") ? this.parent.getPath() : []
          const n = t.parent.is("node") ? t.parent.getPath() : []
          e.push(this.offset)
          n.push(t.offset)
          const o = Ct(e, n)
          switch (o) {
            case "prefix":
              return "before"
            case "extension":
              return "after"
            default:
              return e[o] < n[o] ? "before" : "after"
          }
        }
        getWalker(t = {}) {
          t.startPosition = this
          return new op(t)
        }
        clone() {
          return new rp(this.parent, this.offset)
        }
        static _createAt(t, e) {
          if (t instanceof rp) {
            return new this(t.parent, t.offset)
          } else {
            const n = t
            if (e == "end") {
              e = n.is("$text") ? n.data.length : n.childCount
            } else if (e == "before") {
              return this._createBefore(n)
            } else if (e == "after") {
              return this._createAfter(n)
            } else if (e !== 0 && !e) {
              throw new P("view-createpositionat-offset-required", n)
            }
            return new rp(n, e)
          }
        }
        static _createAfter(t) {
          if (t.is("$textProxy")) {
            return new rp(t.textNode, t.offsetInText + t.data.length)
          }
          if (!t.parent) {
            throw new P("view-position-after-root", t, { root: t })
          }
          return new rp(t.parent, t.index + 1)
        }
        static _createBefore(t) {
          if (t.is("$textProxy")) {
            return new rp(t.textNode, t.offsetInText)
          }
          if (!t.parent) {
            throw new P("view-position-before-root", t, { root: t })
          }
          return new rp(t.parent, t.index)
        }
      }
      rp.prototype.is = function (t) {
        return t === "position" || t === "view:position"
      }
      class ip extends Hh {
        constructor(t, e = null) {
          super()
          this.start = t.clone()
          this.end = e ? e.clone() : t.clone()
        }
        *[Symbol.iterator]() {
          yield* new op({ boundaries: this, ignoreElementEnd: true })
        }
        get isCollapsed() {
          return this.start.isEqual(this.end)
        }
        get isFlat() {
          return this.start.parent === this.end.parent
        }
        get root() {
          return this.start.root
        }
        getEnlarged() {
          let t = this.start.getLastMatchingPosition(sp, { direction: "backward" })
          let e = this.end.getLastMatchingPosition(sp)
          if (t.parent.is("$text") && t.isAtStart) {
            t = rp._createBefore(t.parent)
          }
          if (e.parent.is("$text") && e.isAtEnd) {
            e = rp._createAfter(e.parent)
          }
          return new ip(t, e)
        }
        getTrimmed() {
          let t = this.start.getLastMatchingPosition(sp)
          if (t.isAfter(this.end) || t.isEqual(this.end)) {
            return new ip(t, t)
          }
          let e = this.end.getLastMatchingPosition(sp, { direction: "backward" })
          const n = t.nodeAfter
          const o = e.nodeBefore
          if (n && n.is("$text")) {
            t = new rp(n, 0)
          }
          if (o && o.is("$text")) {
            e = new rp(o, o.data.length)
          }
          return new ip(t, e)
        }
        isEqual(t) {
          return this == t || (this.start.isEqual(t.start) && this.end.isEqual(t.end))
        }
        containsPosition(t) {
          return t.isAfter(this.start) && t.isBefore(this.end)
        }
        containsRange(t, e = false) {
          if (t.isCollapsed) {
            e = false
          }
          const n = this.containsPosition(t.start) || (e && this.start.isEqual(t.start))
          const o = this.containsPosition(t.end) || (e && this.end.isEqual(t.end))
          return n && o
        }
        getDifference(t) {
          const e = []
          if (this.isIntersecting(t)) {
            if (this.containsPosition(t.start)) {
              e.push(new ip(this.start, t.start))
            }
            if (this.containsPosition(t.end)) {
              e.push(new ip(t.end, this.end))
            }
          } else {
            e.push(this.clone())
          }
          return e
        }
        getIntersection(t) {
          if (this.isIntersecting(t)) {
            let e = this.start
            let n = this.end
            if (this.containsPosition(t.start)) {
              e = t.start
            }
            if (this.containsPosition(t.end)) {
              n = t.end
            }
            return new ip(e, n)
          }
          return null
        }
        getWalker(t = {}) {
          t.boundaries = this
          return new op(t)
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end)
        }
        getContainedElement() {
          if (this.isCollapsed) {
            return null
          }
          let t = this.start.nodeAfter
          let e = this.end.nodeBefore
          if (
            this.start.parent.is("$text") &&
            this.start.isAtEnd &&
            this.start.parent.nextSibling
          ) {
            t = this.start.parent.nextSibling
          }
          if (
            this.end.parent.is("$text") &&
            this.end.isAtStart &&
            this.end.parent.previousSibling
          ) {
            e = this.end.parent.previousSibling
          }
          if (t && t.is("element") && t === e) {
            return t
          }
          return null
        }
        clone() {
          return new ip(this.start, this.end)
        }
        *getItems(t = {}) {
          t.boundaries = this
          t.ignoreElementEnd = true
          const e = new op(t)
          for (const t of e) {
            yield t.item
          }
        }
        *getPositions(t = {}) {
          t.boundaries = this
          const e = new op(t)
          yield e.position
          for (const t of e) {
            yield t.nextPosition
          }
        }
        isIntersecting(t) {
          return this.start.isBefore(t.end) && this.end.isAfter(t.start)
        }
        static _createFromParentsAndOffsets(t, e, n, o) {
          return new this(new rp(t, e), new rp(n, o))
        }
        static _createFromPositionAndShift(t, e) {
          const n = t
          const o = t.getShiftedBy(e)
          return e > 0 ? new this(n, o) : new this(o, n)
        }
        static _createIn(t) {
          return this._createFromParentsAndOffsets(t, 0, t, t.childCount)
        }
        static _createOn(t) {
          const e = t.is("$textProxy") ? t.offsetSize : 1
          return this._createFromPositionAndShift(rp._createBefore(t), e)
        }
      }
      ip.prototype.is = function (t) {
        return t === "range" || t === "view:range"
      }
      function sp(t) {
        if (t.item.is("attributeElement") || t.item.is("uiElement")) {
          return true
        }
        return false
      }
      class ap extends q(Hh) {
        constructor(...t) {
          super()
          this._ranges = []
          this._lastRangeBackward = false
          this._isFake = false
          this._fakeSelectionLabel = ""
          if (t.length) {
            this.setTo(...t)
          }
        }
        get isFake() {
          return this._isFake
        }
        get fakeSelectionLabel() {
          return this._fakeSelectionLabel
        }
        get anchor() {
          if (!this._ranges.length) {
            return null
          }
          const t = this._ranges[this._ranges.length - 1]
          const e = this._lastRangeBackward ? t.end : t.start
          return e.clone()
        }
        get focus() {
          if (!this._ranges.length) {
            return null
          }
          const t = this._ranges[this._ranges.length - 1]
          const e = this._lastRangeBackward ? t.start : t.end
          return e.clone()
        }
        get isCollapsed() {
          return this.rangeCount === 1 && this._ranges[0].isCollapsed
        }
        get rangeCount() {
          return this._ranges.length
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward
        }
        get editableElement() {
          if (this.anchor) {
            return this.anchor.editableElement
          }
          return null
        }
        *getRanges() {
          for (const t of this._ranges) {
            yield t.clone()
          }
        }
        getFirstRange() {
          let t = null
          for (const e of this._ranges) {
            if (!t || e.start.isBefore(t.start)) {
              t = e
            }
          }
          return t ? t.clone() : null
        }
        getLastRange() {
          let t = null
          for (const e of this._ranges) {
            if (!t || e.end.isAfter(t.end)) {
              t = e
            }
          }
          return t ? t.clone() : null
        }
        getFirstPosition() {
          const t = this.getFirstRange()
          return t ? t.start.clone() : null
        }
        getLastPosition() {
          const t = this.getLastRange()
          return t ? t.end.clone() : null
        }
        isEqual(t) {
          if (this.isFake != t.isFake) {
            return false
          }
          if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel) {
            return false
          }
          if (this.rangeCount != t.rangeCount) {
            return false
          } else if (this.rangeCount === 0) {
            return true
          }
          if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
            return false
          }
          for (const e of this._ranges) {
            let n = false
            for (const o of t._ranges) {
              if (e.isEqual(o)) {
                n = true
                break
              }
            }
            if (!n) {
              return false
            }
          }
          return true
        }
        isSimilar(t) {
          if (this.isBackward != t.isBackward) {
            return false
          }
          const e = At(this.getRanges())
          const n = At(t.getRanges())
          if (e != n) {
            return false
          }
          if (e == 0) {
            return true
          }
          for (let e of this.getRanges()) {
            e = e.getTrimmed()
            let n = false
            for (let o of t.getRanges()) {
              o = o.getTrimmed()
              if (e.start.isEqual(o.start) && e.end.isEqual(o.end)) {
                n = true
                break
              }
            }
            if (!n) {
              return false
            }
          }
          return true
        }
        getSelectedElement() {
          if (this.rangeCount !== 1) {
            return null
          }
          return this.getFirstRange().getContainedElement()
        }
        setTo(...t) {
          let [e, n, o] = t
          if (typeof n == "object") {
            o = n
            n = undefined
          }
          if (e === null) {
            this._setRanges([])
            this._setFakeOptions(o)
          } else if (e instanceof ap || e instanceof cp) {
            this._setRanges(e.getRanges(), e.isBackward)
            this._setFakeOptions({ fake: e.isFake, label: e.fakeSelectionLabel })
          } else if (e instanceof ip) {
            this._setRanges([e], o && o.backward)
            this._setFakeOptions(o)
          } else if (e instanceof rp) {
            this._setRanges([new ip(e)])
            this._setFakeOptions(o)
          } else if (e instanceof Kh) {
            const t = !!o && !!o.backward
            let r
            if (n === undefined) {
              throw new P("view-selection-setto-required-second-parameter", this)
            } else if (n == "in") {
              r = ip._createIn(e)
            } else if (n == "on") {
              r = ip._createOn(e)
            } else {
              r = new ip(rp._createAt(e, n))
            }
            this._setRanges([r], t)
            this._setFakeOptions(o)
          } else if (yt(e)) {
            this._setRanges(e, o && o.backward)
            this._setFakeOptions(o)
          } else {
            throw new P("view-selection-setto-not-selectable", this)
          }
          this.fire("change")
        }
        setFocus(t, e) {
          if (this.anchor === null) {
            throw new P("view-selection-setfocus-no-ranges", this)
          }
          const n = rp._createAt(t, e)
          if (n.compareWith(this.focus) == "same") {
            return
          }
          const o = this.anchor
          this._ranges.pop()
          if (n.compareWith(o) == "before") {
            this._addRange(new ip(n, o), true)
          } else {
            this._addRange(new ip(o, n))
          }
          this.fire("change")
        }
        _setRanges(t, e = false) {
          t = Array.from(t)
          this._ranges = []
          for (const e of t) {
            this._addRange(e)
          }
          this._lastRangeBackward = !!e
        }
        _setFakeOptions(t = {}) {
          this._isFake = !!t.fake
          this._fakeSelectionLabel = t.fake ? t.label || "" : ""
        }
        _addRange(t, e = false) {
          if (!(t instanceof ip)) {
            throw new P("view-selection-add-range-not-range", this)
          }
          this._pushRange(t)
          this._lastRangeBackward = !!e
        }
        _pushRange(t) {
          for (const e of this._ranges) {
            if (t.isIntersecting(e)) {
              throw new P("view-selection-range-intersects", this, {
                addedRange: t,
                intersectingRange: e,
              })
            }
          }
          this._ranges.push(new ip(t.start, t.end))
        }
      }
      ap.prototype.is = function (t) {
        return t === "selection" || t === "view:selection"
      }
      class cp extends q(Hh) {
        constructor(...t) {
          super()
          this._selection = new ap()
          this._selection.delegate("change").to(this)
          if (t.length) {
            this._selection.setTo(...t)
          }
        }
        get isFake() {
          return this._selection.isFake
        }
        get fakeSelectionLabel() {
          return this._selection.fakeSelectionLabel
        }
        get anchor() {
          return this._selection.anchor
        }
        get focus() {
          return this._selection.focus
        }
        get isCollapsed() {
          return this._selection.isCollapsed
        }
        get rangeCount() {
          return this._selection.rangeCount
        }
        get isBackward() {
          return this._selection.isBackward
        }
        get editableElement() {
          return this._selection.editableElement
        }
        get _ranges() {
          return this._selection._ranges
        }
        *getRanges() {
          yield* this._selection.getRanges()
        }
        getFirstRange() {
          return this._selection.getFirstRange()
        }
        getLastRange() {
          return this._selection.getLastRange()
        }
        getFirstPosition() {
          return this._selection.getFirstPosition()
        }
        getLastPosition() {
          return this._selection.getLastPosition()
        }
        getSelectedElement() {
          return this._selection.getSelectedElement()
        }
        isEqual(t) {
          return this._selection.isEqual(t)
        }
        isSimilar(t) {
          return this._selection.isSimilar(t)
        }
        _setTo(...t) {
          this._selection.setTo(...t)
        }
        _setFocus(t, e) {
          this._selection.setFocus(t, e)
        }
      }
      cp.prototype.is = function (t) {
        return (
          t === "selection" ||
          t == "documentSelection" ||
          t == "view:selection" ||
          t == "view:documentSelection"
        )
      }
      class lp extends C {
        constructor(t, e, n) {
          super(t, e)
          this.startRange = n
          this._eventPhase = "none"
          this._currentTarget = null
        }
        get eventPhase() {
          return this._eventPhase
        }
        get currentTarget() {
          return this._currentTarget
        }
      }
      const dp = Symbol("bubbling contexts")
      function hp(t) {
        class e extends t {
          fire(t, ...e) {
            try {
              const n = t instanceof C ? t : new C(this, t)
              const o = gp(this)
              if (!o.size) {
                return
              }
              up(n, "capturing", this)
              if (fp(o, "$capture", n, ...e)) {
                return n.return
              }
              const r = n.startRange || this.selection.getFirstRange()
              const i = r ? r.getContainedElement() : null
              const s = i ? Boolean(pp(o, i)) : false
              let a = i || mp(r)
              up(n, "atTarget", a)
              if (!s) {
                if (fp(o, "$text", n, ...e)) {
                  return n.return
                }
                up(n, "bubbling", a)
              }
              while (a) {
                if (a.is("rootElement")) {
                  if (fp(o, "$root", n, ...e)) {
                    return n.return
                  }
                } else if (a.is("element")) {
                  if (fp(o, a.name, n, ...e)) {
                    return n.return
                  }
                }
                if (fp(o, a, n, ...e)) {
                  return n.return
                }
                a = a.parent
                up(n, "bubbling", a)
              }
              up(n, "bubbling", this)
              fp(o, "$document", n, ...e)
              return n.return
            } catch (t) {
              P.rethrowUnexpectedError(t, this)
            }
          }
          _addEventListener(t, e, n) {
            const o = tl(n.context || "$document")
            const r = gp(this)
            for (const i of o) {
              let o = r.get(i)
              if (!o) {
                o = new (q())()
                r.set(i, o)
              }
              this.listenTo(o, t, e, n)
            }
          }
          _removeEventListener(t, e) {
            const n = gp(this)
            for (const o of n.values()) {
              this.stopListening(o, t, e)
            }
          }
        }
        return e
      }
      {
        const t = hp(Object)
        ;["fire", "_addEventListener", "_removeEventListener"].forEach((e) => {
          hp[e] = t.prototype[e]
        })
      }
      function up(t, e, n) {
        if (t instanceof lp) {
          t._eventPhase = e
          t._currentTarget = n
        }
      }
      function fp(t, e, n, ...o) {
        const r = typeof e == "string" ? t.get(e) : pp(t, e)
        if (!r) {
          return false
        }
        r.fire(n, ...o)
        return n.stop.called
      }
      function pp(t, e) {
        for (const [n, o] of t) {
          if (typeof n == "function" && n(e)) {
            return o
          }
        }
        return null
      }
      function gp(t) {
        if (!t[dp]) {
          t[dp] = new Map()
        }
        return t[dp]
      }
      function mp(t) {
        if (!t) {
          return null
        }
        const e = t.start.parent
        const n = t.end.parent
        const o = e.getPath()
        const r = n.getPath()
        return o.length > r.length ? e : n
      }
      class kp extends hp(dt()) {
        constructor(t) {
          super()
          this._postFixers = new Set()
          this.selection = new cp()
          this.roots = new dl({ idProperty: "rootName" })
          this.stylesProcessor = t
          this.set("isReadOnly", false)
          this.set("isFocused", false)
          this.set("isSelecting", false)
          this.set("isComposing", false)
        }
        getRoot(t = "main") {
          return this.roots.get(t)
        }
        registerPostFixer(t) {
          this._postFixers.add(t)
        }
        destroy() {
          this.roots.map((t) => t.destroy())
          this.stopListening()
        }
        _callPostFixers(t) {
          let e = false
          do {
            for (const n of this._postFixers) {
              e = n(t)
              if (e) {
                break
              }
            }
          } while (e)
        }
      }
      const bp = 10
      class wp extends Uf {
        constructor(t, e, n, o) {
          super(t, e, n, o)
          this._priority = bp
          this._id = null
          this._clonesGroup = null
          this.getFillerOffset = _p
        }
        get priority() {
          return this._priority
        }
        get id() {
          return this._id
        }
        getElementsWithSameId() {
          if (this.id === null) {
            throw new P("attribute-element-get-elements-with-same-id-no-id", this)
          }
          return new Set(this._clonesGroup)
        }
        isSimilar(t) {
          if (this.id !== null || t.id !== null) {
            return this.id === t.id
          }
          return super.isSimilar(t) && this.priority == t.priority
        }
        _clone(t = false) {
          const e = super._clone(t)
          e._priority = this._priority
          e._id = this._id
          return e
        }
      }
      wp.DEFAULT_PRIORITY = bp
      wp.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "attributeElement" ||
            t === "view:attributeElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          )
        } else {
          return (
            e === this.name &&
            (t === "attributeElement" ||
              t === "view:attributeElement" ||
              t === "element" ||
              t === "view:element")
          )
        }
      }
      function _p() {
        if (vp(this)) {
          return null
        }
        let t = this.parent
        while (t && t.is("attributeElement")) {
          if (vp(t) > 1) {
            return null
          }
          t = t.parent
        }
        if (!t || vp(t) > 1) {
          return null
        }
        return this.childCount
      }
      function vp(t) {
        return Array.from(t.getChildren()).filter((t) => !t.is("uiElement")).length
      }
      class Ap extends Uf {
        constructor(t, e, n, o) {
          super(t, e, n, o)
          this.getFillerOffset = Cp
        }
        _insertChild(t, e) {
          if (e && (e instanceof Kh || Array.from(e).length > 0)) {
            throw new P("view-emptyelement-cannot-add", [this, e])
          }
          return 0
        }
      }
      Ap.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "emptyElement" ||
            t === "view:emptyElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          )
        } else {
          return (
            e === this.name &&
            (t === "emptyElement" ||
              t === "view:emptyElement" ||
              t === "element" ||
              t === "view:element")
          )
        }
      }
      function Cp() {
        return null
      }
      class yp extends Uf {
        constructor(t, e, n, o) {
          super(t, e, n, o)
          this.getFillerOffset = Ep
        }
        _insertChild(t, e) {
          if (e && (e instanceof Kh || Array.from(e).length > 0)) {
            throw new P("view-uielement-cannot-add", [this, e])
          }
          return 0
        }
        render(t, e) {
          return this.toDomElement(t)
        }
        toDomElement(t) {
          const e = t.createElement(this.name)
          for (const t of this.getAttributeKeys()) {
            e.setAttribute(t, this.getAttribute(t))
          }
          return e
        }
      }
      yp.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "uiElement" ||
            t === "view:uiElement" ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          )
        } else {
          return (
            e === this.name &&
            (t === "uiElement" || t === "view:uiElement" || t === "element" || t === "view:element")
          )
        }
      }
      function xp(t) {
        t.document.on("arrowKey", (e, n) => Dp(e, n, t.domConverter), { priority: "low" })
      }
      function Ep() {
        return null
      }
      function Dp(t, e, n) {
        if (e.keyCode == Wc.arrowright) {
          const t = e.domTarget.ownerDocument.defaultView.getSelection()
          const o = t.rangeCount == 1 && t.getRangeAt(0).collapsed
          if (o || e.shiftKey) {
            const e = t.focusNode
            const r = t.focusOffset
            const i = n.domPositionToView(e, r)
            if (i === null) {
              return
            }
            let s = false
            const a = i.getLastMatchingPosition((t) => {
              if (t.item.is("uiElement")) {
                s = true
              }
              if (t.item.is("uiElement") || t.item.is("attributeElement")) {
                return true
              }
              return false
            })
            if (s) {
              const e = n.viewPositionToDom(a)
              if (o) {
                t.collapse(e.parent, e.offset)
              } else {
                t.extend(e.parent, e.offset)
              }
            }
          }
        }
      }
      class Sp extends Uf {
        constructor(t, e, n, o) {
          super(t, e, n, o)
          this.getFillerOffset = Tp
        }
        _insertChild(t, e) {
          if (e && (e instanceof Kh || Array.from(e).length > 0)) {
            throw new P("view-rawelement-cannot-add", [this, e])
          }
          return 0
        }
        render(t, e) {}
      }
      Sp.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "rawElement" ||
            t === "view:rawElement" ||
            t === this.name ||
            t === "view:" + this.name ||
            t === "element" ||
            t === "view:element" ||
            t === "node" ||
            t === "view:node"
          )
        } else {
          return (
            e === this.name &&
            (t === "rawElement" ||
              t === "view:rawElement" ||
              t === "element" ||
              t === "view:element")
          )
        }
      }
      function Tp() {
        return null
      }
      class Pp extends q(Hh) {
        constructor(t, e) {
          super()
          this._children = []
          this._customProperties = new Map()
          this.document = t
          if (e) {
            this._insertChild(0, e)
          }
        }
        [Symbol.iterator]() {
          return this._children[Symbol.iterator]()
        }
        get childCount() {
          return this._children.length
        }
        get isEmpty() {
          return this.childCount === 0
        }
        get root() {
          return this
        }
        get parent() {
          return null
        }
        get name() {
          return undefined
        }
        getCustomProperty(t) {
          return this._customProperties.get(t)
        }
        *getCustomProperties() {
          yield* this._customProperties.entries()
        }
        _appendChild(t) {
          return this._insertChild(this.childCount, t)
        }
        getChild(t) {
          return this._children[t]
        }
        getChildIndex(t) {
          return this._children.indexOf(t)
        }
        getChildren() {
          return this._children[Symbol.iterator]()
        }
        _insertChild(t, e) {
          this._fireChange("children", this)
          let n = 0
          const o = Bp(this.document, e)
          for (const e of o) {
            if (e.parent !== null) {
              e._remove()
            }
            e.parent = this
            this._children.splice(t, 0, e)
            t++
            n++
          }
          return n
        }
        _removeChildren(t, e = 1) {
          this._fireChange("children", this)
          for (let n = t; n < t + e; n++) {
            this._children[n].parent = null
          }
          return this._children.splice(t, e)
        }
        _fireChange(t, e) {
          this.fire("change:" + t, e)
        }
        _setCustomProperty(t, e) {
          this._customProperties.set(t, e)
        }
        _removeCustomProperty(t) {
          return this._customProperties.delete(t)
        }
      }
      Pp.prototype.is = function (t) {
        return t === "documentFragment" || t === "view:documentFragment"
      }
      function Bp(t, e) {
        if (typeof e == "string") {
          return [new Gh(t, e)]
        }
        if (!yt(e)) {
          e = [e]
        }
        return Array.from(e).map((e) => {
          if (typeof e == "string") {
            return new Gh(t, e)
          }
          if (e instanceof Uh) {
            return new Gh(t, e.data)
          }
          return e
        })
      }
      class Rp {
        constructor(t) {
          this._cloneGroups = new Map()
          this._slotFactory = null
          this.document = t
        }
        setSelection(...t) {
          this.document.selection._setTo(...t)
        }
        setSelectionFocus(t, e) {
          this.document.selection._setFocus(t, e)
        }
        createDocumentFragment(t) {
          return new Pp(this.document, t)
        }
        createText(t) {
          return new Gh(this.document, t)
        }
        createAttributeElement(t, e, n = {}) {
          const o = new wp(this.document, t, e)
          if (typeof n.priority === "number") {
            o._priority = n.priority
          }
          if (n.id) {
            o._id = n.id
          }
          if (n.renderUnsafeAttributes) {
            o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes)
          }
          return o
        }
        createContainerElement(t, e, n = {}, o = {}) {
          let r = null
          if (ue(n)) {
            o = n
          } else {
            r = n
          }
          const i = new Qf(this.document, t, e, r)
          if (o.renderUnsafeAttributes) {
            i._unsafeAttributesToRender.push(...o.renderUnsafeAttributes)
          }
          return i
        }
        createEditableElement(t, e, n = {}) {
          const o = new tp(this.document, t, e)
          if (n.renderUnsafeAttributes) {
            o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes)
          }
          return o
        }
        createEmptyElement(t, e, n = {}) {
          const o = new Ap(this.document, t, e)
          if (n.renderUnsafeAttributes) {
            o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes)
          }
          return o
        }
        createUIElement(t, e, n) {
          const o = new yp(this.document, t, e)
          if (n) {
            o.render = n
          }
          return o
        }
        createRawElement(t, e, n, o = {}) {
          const r = new Sp(this.document, t, e)
          if (n) {
            r.render = n
          }
          if (o.renderUnsafeAttributes) {
            r._unsafeAttributesToRender.push(...o.renderUnsafeAttributes)
          }
          return r
        }
        setAttribute(t, e, n) {
          n._setAttribute(t, e)
        }
        removeAttribute(t, e) {
          e._removeAttribute(t)
        }
        addClass(t, e) {
          e._addClass(t)
        }
        removeClass(t, e) {
          e._removeClass(t)
        }
        setStyle(t, e, n) {
          if (ue(t) && n === undefined) {
            e._setStyle(t)
          } else {
            n._setStyle(t, e)
          }
        }
        removeStyle(t, e) {
          e._removeStyle(t)
        }
        setCustomProperty(t, e, n) {
          n._setCustomProperty(t, e)
        }
        removeCustomProperty(t, e) {
          return e._removeCustomProperty(t)
        }
        breakAttributes(t) {
          if (t instanceof rp) {
            return this._breakAttributes(t)
          } else {
            return this._breakAttributesRange(t)
          }
        }
        breakContainer(t) {
          const e = t.parent
          if (!e.is("containerElement")) {
            throw new P("view-writer-break-non-container-element", this.document)
          }
          if (!e.parent) {
            throw new P("view-writer-break-root", this.document)
          }
          if (t.isAtStart) {
            return rp._createBefore(e)
          } else if (!t.isAtEnd) {
            const n = e._clone(false)
            this.insert(rp._createAfter(e), n)
            const o = new ip(t, rp._createAt(e, "end"))
            const r = new rp(n, 0)
            this.move(o, r)
          }
          return rp._createAfter(e)
        }
        mergeAttributes(t) {
          const e = t.offset
          const n = t.parent
          if (n.is("$text")) {
            return t
          }
          if (n.is("attributeElement") && n.childCount === 0) {
            const t = n.parent
            const e = n.index
            n._remove()
            this._removeFromClonedElementsGroup(n)
            return this.mergeAttributes(new rp(t, e))
          }
          const o = n.getChild(e - 1)
          const r = n.getChild(e)
          if (!o || !r) {
            return t
          }
          if (o.is("$text") && r.is("$text")) {
            return Fp(o, r)
          } else if (o.is("attributeElement") && r.is("attributeElement") && o.isSimilar(r)) {
            const t = o.childCount
            o._appendChild(r.getChildren())
            r._remove()
            this._removeFromClonedElementsGroup(r)
            return this.mergeAttributes(new rp(o, t))
          }
          return t
        }
        mergeContainers(t) {
          const e = t.nodeBefore
          const n = t.nodeAfter
          if (!e || !n || !e.is("containerElement") || !n.is("containerElement")) {
            throw new P("view-writer-merge-containers-invalid-position", this.document)
          }
          const o = e.getChild(e.childCount - 1)
          const r = o instanceof Gh ? rp._createAt(o, "end") : rp._createAt(e, "end")
          this.move(ip._createIn(n), rp._createAt(e, "end"))
          this.remove(ip._createOn(n))
          return r
        }
        insert(t, e) {
          e = yt(e) ? [...e] : [e]
          Lp(e, this.document)
          const n = e.reduce((t, e) => {
            const n = t[t.length - 1]
            const o = !e.is("uiElement")
            if (!n || n.breakAttributes != o) {
              t.push({ breakAttributes: o, nodes: [e] })
            } else {
              n.nodes.push(e)
            }
            return t
          }, [])
          let o = null
          let r = t
          for (const { nodes: t, breakAttributes: e } of n) {
            const n = this._insertNodes(r, t, e)
            if (!o) {
              o = n.start
            }
            r = n.end
          }
          if (!o) {
            return new ip(t)
          }
          return new ip(o, r)
        }
        remove(t) {
          const e = t instanceof ip ? t : ip._createOn(t)
          Hp(e, this.document)
          if (e.isCollapsed) {
            return new Pp(this.document)
          }
          const { start: n, end: o } = this._breakAttributesRange(e, true)
          const r = n.parent
          const i = o.offset - n.offset
          const s = r._removeChildren(n.offset, i)
          for (const t of s) {
            this._removeFromClonedElementsGroup(t)
          }
          const a = this.mergeAttributes(n)
          e.start = a
          e.end = a.clone()
          return new Pp(this.document, s)
        }
        clear(t, e) {
          Hp(t, this.document)
          const n = t.getWalker({ direction: "backward", ignoreElementEnd: true })
          for (const o of n) {
            const n = o.item
            let r
            if (n.is("element") && e.isSimilar(n)) {
              r = ip._createOn(n)
            } else if (!o.nextPosition.isAfter(t.start) && n.is("$textProxy")) {
              const t = n.getAncestors().find((t) => t.is("element") && e.isSimilar(t))
              if (t) {
                r = ip._createIn(t)
              }
            }
            if (r) {
              if (r.end.isAfter(t.end)) {
                r.end = t.end
              }
              if (r.start.isBefore(t.start)) {
                r.start = t.start
              }
              this.remove(r)
            }
          }
        }
        move(t, e) {
          let n
          if (e.isAfter(t.end)) {
            e = this._breakAttributes(e, true)
            const o = e.parent
            const r = o.childCount
            t = this._breakAttributesRange(t, true)
            n = this.remove(t)
            e.offset += o.childCount - r
          } else {
            n = this.remove(t)
          }
          return this.insert(e, n)
        }
        wrap(t, e) {
          if (!(e instanceof wp)) {
            throw new P("view-writer-wrap-invalid-attribute", this.document)
          }
          Hp(t, this.document)
          if (!t.isCollapsed) {
            return this._wrapRange(t, e)
          } else {
            let n = t.start
            if (n.parent.is("element") && !Op(n.parent)) {
              n = n.getLastMatchingPosition((t) => t.item.is("uiElement"))
            }
            n = this._wrapPosition(n, e)
            const o = this.document.selection
            if (o.isCollapsed && o.getFirstPosition().isEqual(t.start)) {
              this.setSelection(n)
            }
            return new ip(n)
          }
        }
        unwrap(t, e) {
          if (!(e instanceof wp)) {
            throw new P("view-writer-unwrap-invalid-attribute", this.document)
          }
          Hp(t, this.document)
          if (t.isCollapsed) {
            return t
          }
          const { start: n, end: o } = this._breakAttributesRange(t, true)
          const r = n.parent
          const i = this._unwrapChildren(r, n.offset, o.offset, e)
          const s = this.mergeAttributes(i.start)
          if (!s.isEqual(i.start)) {
            i.end.offset--
          }
          const a = this.mergeAttributes(i.end)
          return new ip(s, a)
        }
        rename(t, e) {
          const n = new Qf(this.document, t, e.getAttributes())
          this.insert(rp._createAfter(e), n)
          this.move(ip._createIn(e), rp._createAt(n, 0))
          this.remove(ip._createOn(e))
          return n
        }
        clearClonedElementsGroup(t) {
          this._cloneGroups.delete(t)
        }
        createPositionAt(t, e) {
          return rp._createAt(t, e)
        }
        createPositionAfter(t) {
          return rp._createAfter(t)
        }
        createPositionBefore(t) {
          return rp._createBefore(t)
        }
        createRange(t, e) {
          return new ip(t, e)
        }
        createRangeOn(t) {
          return ip._createOn(t)
        }
        createRangeIn(t) {
          return ip._createIn(t)
        }
        createSelection(...t) {
          return new ap(...t)
        }
        createSlot(t = "children") {
          if (!this._slotFactory) {
            throw new P("view-writer-invalid-create-slot-context", this.document)
          }
          return this._slotFactory(this, t)
        }
        _registerSlotFactory(t) {
          this._slotFactory = t
        }
        _clearSlotFactory() {
          this._slotFactory = null
        }
        _insertNodes(t, e, n) {
          let o
          if (n) {
            o = Mp(t)
          } else {
            o = t.parent.is("$text") ? t.parent.parent : t.parent
          }
          if (!o) {
            throw new P("view-writer-invalid-position-container", this.document)
          }
          let r
          if (n) {
            r = this._breakAttributes(t, true)
          } else {
            r = t.parent.is("$text") ? Np(t) : t
          }
          const i = o._insertChild(r.offset, e)
          for (const t of e) {
            this._addToClonedElementsGroup(t)
          }
          const s = r.getShiftedBy(i)
          const a = this.mergeAttributes(r)
          if (!a.isEqual(r)) {
            s.offset--
          }
          const c = this.mergeAttributes(s)
          return new ip(a, c)
        }
        _wrapChildren(t, e, n, o) {
          let r = e
          const i = []
          while (r < n) {
            const e = t.getChild(r)
            const n = e.is("$text")
            const s = e.is("attributeElement")
            if (s && this._wrapAttributeElement(o, e)) {
              i.push(new rp(t, r))
            } else if (n || !s || Ip(o, e)) {
              const n = o._clone()
              e._remove()
              n._appendChild(e)
              t._insertChild(r, n)
              this._addToClonedElementsGroup(n)
              i.push(new rp(t, r))
            } else {
              this._wrapChildren(e, 0, e.childCount, o)
            }
            r++
          }
          let s = 0
          for (const t of i) {
            t.offset -= s
            if (t.offset == e) {
              continue
            }
            const o = this.mergeAttributes(t)
            if (!o.isEqual(t)) {
              s++
              n--
            }
          }
          return ip._createFromParentsAndOffsets(t, e, t, n)
        }
        _unwrapChildren(t, e, n, o) {
          let r = e
          const i = []
          while (r < n) {
            const e = t.getChild(r)
            if (!e.is("attributeElement")) {
              r++
              continue
            }
            if (e.isSimilar(o)) {
              const o = e.getChildren()
              const s = e.childCount
              e._remove()
              t._insertChild(r, o)
              this._removeFromClonedElementsGroup(e)
              i.push(new rp(t, r), new rp(t, r + s))
              r += s
              n += s - 1
              continue
            }
            if (this._unwrapAttributeElement(o, e)) {
              i.push(new rp(t, r), new rp(t, r + 1))
              r++
              continue
            }
            this._unwrapChildren(e, 0, e.childCount, o)
            r++
          }
          let s = 0
          for (const t of i) {
            t.offset -= s
            if (t.offset == e || t.offset == n) {
              continue
            }
            const o = this.mergeAttributes(t)
            if (!o.isEqual(t)) {
              s++
              n--
            }
          }
          return ip._createFromParentsAndOffsets(t, e, t, n)
        }
        _wrapRange(t, e) {
          const { start: n, end: o } = this._breakAttributesRange(t, true)
          const r = n.parent
          const i = this._wrapChildren(r, n.offset, o.offset, e)
          const s = this.mergeAttributes(i.start)
          if (!s.isEqual(i.start)) {
            i.end.offset--
          }
          const a = this.mergeAttributes(i.end)
          return new ip(s, a)
        }
        _wrapPosition(t, e) {
          if (e.isSimilar(t.parent)) {
            return zp(t.clone())
          }
          if (t.parent.is("$text")) {
            t = Np(t)
          }
          const n = this.createAttributeElement("_wrapPosition-fake-element")
          n._priority = Number.POSITIVE_INFINITY
          n.isSimilar = () => false
          t.parent._insertChild(t.offset, n)
          const o = new ip(t, t.getShiftedBy(1))
          this.wrap(o, e)
          const r = new rp(n.parent, n.index)
          n._remove()
          const i = r.nodeBefore
          const s = r.nodeAfter
          if (i instanceof Gh && s instanceof Gh) {
            return Fp(i, s)
          }
          return zp(r)
        }
        _wrapAttributeElement(t, e) {
          if (!Wp(t, e)) {
            return false
          }
          if (t.name !== e.name || t.priority !== e.priority) {
            return false
          }
          for (const n of t.getAttributeKeys()) {
            if (n === "class" || n === "style") {
              continue
            }
            if (e.hasAttribute(n) && e.getAttribute(n) !== t.getAttribute(n)) {
              return false
            }
          }
          for (const n of t.getStyleNames()) {
            if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) {
              return false
            }
          }
          for (const n of t.getAttributeKeys()) {
            if (n === "class" || n === "style") {
              continue
            }
            if (!e.hasAttribute(n)) {
              this.setAttribute(n, t.getAttribute(n), e)
            }
          }
          for (const n of t.getStyleNames()) {
            if (!e.hasStyle(n)) {
              this.setStyle(n, t.getStyle(n), e)
            }
          }
          for (const n of t.getClassNames()) {
            if (!e.hasClass(n)) {
              this.addClass(n, e)
            }
          }
          return true
        }
        _unwrapAttributeElement(t, e) {
          if (!Wp(t, e)) {
            return false
          }
          if (t.name !== e.name || t.priority !== e.priority) {
            return false
          }
          for (const n of t.getAttributeKeys()) {
            if (n === "class" || n === "style") {
              continue
            }
            if (!e.hasAttribute(n) || e.getAttribute(n) !== t.getAttribute(n)) {
              return false
            }
          }
          if (!e.hasClass(...t.getClassNames())) {
            return false
          }
          for (const n of t.getStyleNames()) {
            if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) {
              return false
            }
          }
          for (const n of t.getAttributeKeys()) {
            if (n === "class" || n === "style") {
              continue
            }
            this.removeAttribute(n, e)
          }
          this.removeClass(Array.from(t.getClassNames()), e)
          this.removeStyle(Array.from(t.getStyleNames()), e)
          return true
        }
        _breakAttributesRange(t, e = false) {
          const n = t.start
          const o = t.end
          Hp(t, this.document)
          if (t.isCollapsed) {
            const n = this._breakAttributes(t.start, e)
            return new ip(n, n)
          }
          const r = this._breakAttributes(o, e)
          const i = r.parent.childCount
          const s = this._breakAttributes(n, e)
          r.offset += r.parent.childCount - i
          return new ip(s, r)
        }
        _breakAttributes(t, e = false) {
          const n = t.offset
          const o = t.parent
          if (t.parent.is("emptyElement")) {
            throw new P("view-writer-cannot-break-empty-element", this.document)
          }
          if (t.parent.is("uiElement")) {
            throw new P("view-writer-cannot-break-ui-element", this.document)
          }
          if (t.parent.is("rawElement")) {
            throw new P("view-writer-cannot-break-raw-element", this.document)
          }
          if (!e && o.is("$text") && jp(o.parent)) {
            return t.clone()
          }
          if (jp(o)) {
            return t.clone()
          }
          if (o.is("$text")) {
            return this._breakAttributes(Np(t), e)
          }
          const r = o.childCount
          if (n == r) {
            const t = new rp(o.parent, o.index + 1)
            return this._breakAttributes(t, e)
          } else {
            if (n === 0) {
              const t = new rp(o.parent, o.index)
              return this._breakAttributes(t, e)
            } else {
              const t = o.index + 1
              const r = o._clone()
              o.parent._insertChild(t, r)
              this._addToClonedElementsGroup(r)
              const i = o.childCount - n
              const s = o._removeChildren(n, i)
              r._appendChild(s)
              const a = new rp(o.parent, t)
              return this._breakAttributes(a, e)
            }
          }
        }
        _addToClonedElementsGroup(t) {
          if (!t.root.is("rootElement")) {
            return
          }
          if (t.is("element")) {
            for (const e of t.getChildren()) {
              this._addToClonedElementsGroup(e)
            }
          }
          const e = t.id
          if (!e) {
            return
          }
          let n = this._cloneGroups.get(e)
          if (!n) {
            n = new Set()
            this._cloneGroups.set(e, n)
          }
          n.add(t)
          t._clonesGroup = n
        }
        _removeFromClonedElementsGroup(t) {
          if (t.is("element")) {
            for (const e of t.getChildren()) {
              this._removeFromClonedElementsGroup(e)
            }
          }
          const e = t.id
          if (!e) {
            return
          }
          const n = this._cloneGroups.get(e)
          if (!n) {
            return
          }
          n.delete(t)
        }
      }
      function Op(t) {
        return Array.from(t.getChildren()).some((t) => !t.is("uiElement"))
      }
      function Mp(t) {
        let e = t.parent
        while (!jp(e)) {
          if (!e) {
            return undefined
          }
          e = e.parent
        }
        return e
      }
      function Ip(t, e) {
        if (t.priority < e.priority) {
          return true
        } else if (t.priority > e.priority) {
          return false
        }
        return t.getIdentity() < e.getIdentity()
      }
      function zp(t) {
        const e = t.nodeBefore
        if (e && e.is("$text")) {
          return new rp(e, e.data.length)
        }
        const n = t.nodeAfter
        if (n && n.is("$text")) {
          return new rp(n, 0)
        }
        return t
      }
      function Np(t) {
        if (t.offset == t.parent.data.length) {
          return new rp(t.parent.parent, t.parent.index + 1)
        }
        if (t.offset === 0) {
          return new rp(t.parent.parent, t.parent.index)
        }
        const e = t.parent.data.slice(t.offset)
        t.parent._data = t.parent.data.slice(0, t.offset)
        t.parent.parent._insertChild(t.parent.index + 1, new Gh(t.root.document, e))
        return new rp(t.parent.parent, t.parent.index + 1)
      }
      function Fp(t, e) {
        const n = t.data.length
        t._data += e.data
        e._remove()
        return new rp(t, n)
      }
      const Vp = [Gh, wp, Qf, Ap, Sp, yp]
      function Lp(t, e) {
        for (const n of t) {
          if (!Vp.some((t) => n instanceof t)) {
            throw new P("view-writer-insert-invalid-node-type", e)
          }
          if (!n.is("$text")) {
            Lp(n.getChildren(), e)
          }
        }
      }
      function jp(t) {
        return t && (t.is("containerElement") || t.is("documentFragment"))
      }
      function Hp(t, e) {
        const n = Mp(t.start)
        const o = Mp(t.end)
        if (!n || !o || n !== o) {
          throw new P("view-writer-invalid-range-container", e)
        }
      }
      function Wp(t, e) {
        return t.id === null && e.id === null
      }
      const qp = (t) => t.createTextNode(" ")
      const $p = (t) => {
        const e = t.createElement("span")
        e.dataset.ckeFiller = "true"
        e.innerText = " "
        return e
      }
      const Kp = (t) => {
        const e = t.createElement("br")
        e.dataset.ckeFiller = "true"
        return e
      }
      const Gp = 7
      const Up = "⁠".repeat(Gp)
      function Jp(t) {
        return oc(t) && t.data.substr(0, Gp) === Up
      }
      function Zp(t) {
        return t.data.length == Gp && Jp(t)
      }
      function Yp(t) {
        if (Jp(t)) {
          return t.data.slice(Gp)
        } else {
          return t.data
        }
      }
      function Qp(t) {
        t.document.on("arrowKey", Xp, { priority: "low" })
      }
      function Xp(t, e) {
        if (e.keyCode == Wc.arrowleft) {
          const t = e.domTarget.ownerDocument.defaultView.getSelection()
          if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
            const e = t.getRangeAt(0).startContainer
            const n = t.getRangeAt(0).startOffset
            if (Jp(e) && n <= Gp) {
              t.collapse(e, 0)
            }
          }
        }
      }
      var tg = n(401)
      var eg = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      eg.insert = "head"
      eg.singleton = true
      var ng = Bl()(tg.Z, eg)
      const og = tg.Z.locals || {}
      class rg extends dt() {
        constructor(t, e) {
          super()
          this.domDocuments = new Set()
          this.markedAttributes = new Set()
          this.markedChildren = new Set()
          this.markedTexts = new Set()
          this._inlineFiller = null
          this._fakeSelectionContainer = null
          this.domConverter = t
          this.selection = e
          this.set("isFocused", false)
          this.set("isSelecting", false)
          if (i.isBlink && !i.isAndroid) {
            this.on("change:isSelecting", () => {
              if (!this.isSelecting) {
                this.render()
              }
            })
          }
          this.set("isComposing", false)
          this.on("change:isComposing", () => {
            if (!this.isComposing) {
              this.render()
            }
          })
        }
        markToSync(t, e) {
          if (t === "text") {
            if (this.domConverter.mapViewToDom(e.parent)) {
              this.markedTexts.add(e)
            }
          } else {
            if (!this.domConverter.mapViewToDom(e)) {
              return
            }
            if (t === "attributes") {
              this.markedAttributes.add(e)
            } else if (t === "children") {
              this.markedChildren.add(e)
            } else {
              const e = t
              throw new P("view-renderer-unknown-type", this)
            }
          }
        }
        render() {
          if (this.isComposing && !i.isAndroid) {
            return
          }
          let t = null
          const e = i.isBlink && !i.isAndroid ? !this.isSelecting : true
          for (const t of this.markedChildren) {
            this._updateChildrenMappings(t)
          }
          if (e) {
            if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
              this._removeInlineFiller()
            }
            if (this._inlineFiller) {
              t = this._getInlineFillerPosition()
            } else if (this._needsInlineFillerAtSelection()) {
              t = this.selection.getFirstPosition()
              this.markedChildren.add(t.parent)
            }
          } else if (this._inlineFiller && this._inlineFiller.parentNode) {
            t = this.domConverter.domPositionToView(this._inlineFiller)
            if (t && t.parent.is("$text")) {
              t = rp._createBefore(t.parent)
            }
          }
          for (const t of this.markedAttributes) {
            this._updateAttrs(t)
          }
          for (const e of this.markedChildren) {
            this._updateChildren(e, { inlineFillerPosition: t })
          }
          for (const e of this.markedTexts) {
            if (!this.markedChildren.has(e.parent) && this.domConverter.mapViewToDom(e.parent)) {
              this._updateText(e, { inlineFillerPosition: t })
            }
          }
          if (e) {
            if (t) {
              const e = this.domConverter.viewPositionToDom(t)
              const n = e.parent.ownerDocument
              if (!Jp(e.parent)) {
                this._inlineFiller = sg(n, e.parent, e.offset)
              } else {
                this._inlineFiller = e.parent
              }
            } else {
              this._inlineFiller = null
            }
          }
          this._updateFocus()
          this._updateSelection()
          this.markedTexts.clear()
          this.markedAttributes.clear()
          this.markedChildren.clear()
        }
        _updateChildrenMappings(t) {
          const e = this.domConverter.mapViewToDom(t)
          if (!e) {
            return
          }
          const n = Array.from(this.domConverter.mapViewToDom(t).childNodes)
          const o = Array.from(this.domConverter.viewChildrenToDom(t, { withChildren: false }))
          const r = this._diffNodeLists(n, o)
          const i = this._findUpdateActions(r, n, o, ag)
          if (i.indexOf("update") !== -1) {
            const e = { equal: 0, insert: 0, delete: 0 }
            for (const r of i) {
              if (r === "update") {
                const r = e.equal + e.insert
                const i = e.equal + e.delete
                const s = t.getChild(r)
                if (s && !(s.is("uiElement") || s.is("rawElement"))) {
                  this._updateElementMappings(s, n[i])
                }
                Sc(o[r])
                e.equal++
              } else {
                e[r]++
              }
            }
          }
        }
        _updateElementMappings(t, e) {
          this.domConverter.unbindDomElement(e)
          this.domConverter.bindElements(e, t)
          this.markedChildren.add(t)
          this.markedAttributes.add(t)
        }
        _getInlineFillerPosition() {
          const t = this.selection.getFirstPosition()
          if (t.parent.is("$text")) {
            return rp._createBefore(t.parent)
          } else {
            return t
          }
        }
        _isSelectionInInlineFiller() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
            return false
          }
          const t = this.selection.getFirstPosition()
          const e = this.domConverter.viewPositionToDom(t)
          if (e && oc(e.parent) && Jp(e.parent)) {
            return true
          }
          return false
        }
        _removeInlineFiller() {
          const t = this._inlineFiller
          if (!Jp(t)) {
            throw new P("view-renderer-filler-was-lost", this)
          }
          if (Zp(t)) {
            t.remove()
          } else {
            t.data = t.data.substr(Gp)
          }
          this._inlineFiller = null
        }
        _needsInlineFillerAtSelection() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
            return false
          }
          const t = this.selection.getFirstPosition()
          const e = t.parent
          const n = t.offset
          if (!this.domConverter.mapViewToDom(e.root)) {
            return false
          }
          if (!e.is("element")) {
            return false
          }
          if (!ig(e)) {
            return false
          }
          if (n === e.getFillerOffset()) {
            return false
          }
          const o = t.nodeBefore
          const r = t.nodeAfter
          if (o instanceof Gh || r instanceof Gh) {
            return false
          }
          if (i.isAndroid && (o || r)) {
            return false
          }
          return true
        }
        _updateText(t, e) {
          const n = this.domConverter.findCorrespondingDomText(t)
          const o = this.domConverter.viewToDom(t)
          let r = o.data
          const i = e.inlineFillerPosition
          if (i && i.parent == t.parent && i.offset == t.index) {
            r = Up + r
          }
          fg(n, r)
        }
        _updateAttrs(t) {
          const e = this.domConverter.mapViewToDom(t)
          if (!e) {
            return
          }
          const n = Array.from(e.attributes).map((t) => t.name)
          const o = t.getAttributeKeys()
          for (const n of o) {
            this.domConverter.setDomElementAttribute(e, n, t.getAttribute(n), t)
          }
          for (const o of n) {
            if (!t.hasAttribute(o)) {
              this.domConverter.removeDomElementAttribute(e, o)
            }
          }
        }
        _updateChildren(t, e) {
          const n = this.domConverter.mapViewToDom(t)
          if (!n) {
            return
          }
          if (i.isAndroid) {
            let t = null
            for (const e of Array.from(n.childNodes)) {
              if (t && oc(t) && oc(e)) {
                n.normalize()
                break
              }
              t = e
            }
          }
          const o = e.inlineFillerPosition
          const r = n.childNodes
          const s = Array.from(this.domConverter.viewChildrenToDom(t, { bind: true }))
          if (o && o.parent === t) {
            sg(n.ownerDocument, s, o.offset)
          }
          const a = this._diffNodeLists(r, s)
          const c = this._findUpdateActions(a, r, s, cg)
          let l = 0
          const d = new Set()
          for (const t of c) {
            if (t === "delete") {
              d.add(r[l])
              Sc(r[l])
            } else if (t === "equal" || t === "update") {
              l++
            }
          }
          l = 0
          for (const t of c) {
            if (t === "insert") {
              kc(n, l, s[l])
              l++
            } else if (t === "update") {
              fg(r[l], s[l].data)
              l++
            } else if (t === "equal") {
              this._markDescendantTextToSync(this.domConverter.domToView(s[l]))
              l++
            }
          }
          for (const t of d) {
            if (!t.parentNode) {
              this.domConverter.unbindDomElement(t)
            }
          }
        }
        _diffNodeLists(t, e) {
          t = hg(t, this._fakeSelectionContainer)
          return _(t, e, lg.bind(null, this.domConverter))
        }
        _findUpdateActions(t, e, n, o) {
          if (t.indexOf("insert") === -1 || t.indexOf("delete") === -1) {
            return t
          }
          let r = []
          let i = []
          let s = []
          const a = { equal: 0, insert: 0, delete: 0 }
          for (const c of t) {
            if (c === "insert") {
              s.push(n[a.equal + a.insert])
            } else if (c === "delete") {
              i.push(e[a.equal + a.delete])
            } else {
              r = r.concat(_(i, s, o).map((t) => (t === "equal" ? "update" : t)))
              r.push("equal")
              i = []
              s = []
            }
            a[c]++
          }
          return r.concat(_(i, s, o).map((t) => (t === "equal" ? "update" : t)))
        }
        _markDescendantTextToSync(t) {
          if (!t) {
            return
          }
          if (t.is("$text")) {
            this.markedTexts.add(t)
          } else if (t.is("element")) {
            for (const e of t.getChildren()) {
              this._markDescendantTextToSync(e)
            }
          }
        }
        _updateSelection() {
          if (i.isBlink && !i.isAndroid && this.isSelecting && !this.markedChildren.size) {
            return
          }
          if (this.selection.rangeCount === 0) {
            this._removeDomSelection()
            this._removeFakeSelection()
            return
          }
          const t = this.domConverter.mapViewToDom(this.selection.editableElement)
          if (!this.isFocused || !t) {
            return
          }
          if (this.selection.isFake) {
            this._updateFakeSelection(t)
          } else if (this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected) {
            this._removeFakeSelection()
            this._updateDomSelection(t)
          } else if (!(this.isComposing && i.isAndroid)) {
            this._updateDomSelection(t)
          }
        }
        _updateFakeSelection(t) {
          const e = t.ownerDocument
          if (!this._fakeSelectionContainer) {
            this._fakeSelectionContainer = ug(e)
          }
          const n = this._fakeSelectionContainer
          this.domConverter.bindFakeSelection(n, this.selection)
          if (!this._fakeSelectionNeedsUpdate(t)) {
            return
          }
          if (!n.parentElement || n.parentElement != t) {
            t.appendChild(n)
          }
          n.textContent = this.selection.fakeSelectionLabel || " "
          const o = e.getSelection()
          const r = e.createRange()
          o.removeAllRanges()
          r.selectNodeContents(n)
          o.addRange(r)
        }
        _updateDomSelection(t) {
          const e = t.ownerDocument.defaultView.getSelection()
          if (!this._domSelectionNeedsUpdate(e)) {
            return
          }
          const n = this.domConverter.viewPositionToDom(this.selection.anchor)
          const o = this.domConverter.viewPositionToDom(this.selection.focus)
          e.collapse(n.parent, n.offset)
          e.extend(o.parent, o.offset)
          if (i.isGecko) {
            dg(o, e)
          }
        }
        _domSelectionNeedsUpdate(t) {
          if (!this.domConverter.isDomSelectionCorrect(t)) {
            return true
          }
          const e = t && this.domConverter.domSelectionToView(t)
          if (e && this.selection.isEqual(e)) {
            return false
          }
          if (!this.selection.isCollapsed && this.selection.isSimilar(e)) {
            return false
          }
          return true
        }
        _fakeSelectionNeedsUpdate(t) {
          const e = this._fakeSelectionContainer
          const n = t.ownerDocument.getSelection()
          if (!e || e.parentElement !== t) {
            return true
          }
          if (n.anchorNode !== e && !e.contains(n.anchorNode)) {
            return true
          }
          return e.textContent !== this.selection.fakeSelectionLabel
        }
        _removeDomSelection() {
          for (const t of this.domDocuments) {
            const e = t.getSelection()
            if (e.rangeCount) {
              const n = t.activeElement
              const o = this.domConverter.mapDomToView(n)
              if (n && o) {
                e.removeAllRanges()
              }
            }
          }
        }
        _removeFakeSelection() {
          const t = this._fakeSelectionContainer
          if (t) {
            t.remove()
          }
        }
        _updateFocus() {
          if (this.isFocused) {
            const t = this.selection.editableElement
            if (t) {
              this.domConverter.focus(t)
            }
          }
        }
      }
      function ig(t) {
        if (t.getAttribute("contenteditable") == "false") {
          return false
        }
        const e = t.findAncestor((t) => t.hasAttribute("contenteditable"))
        return !e || e.getAttribute("contenteditable") == "true"
      }
      function sg(t, e, n) {
        const o = e instanceof Array ? e : e.childNodes
        const r = o[n]
        if (oc(r)) {
          r.data = Up + r.data
          return r
        } else {
          const r = t.createTextNode(Up)
          if (Array.isArray(e)) {
            o.splice(n, 0, r)
          } else {
            kc(e, n, r)
          }
          return r
        }
      }
      function ag(t, e) {
        return (
          $a(t) &&
          $a(e) &&
          !oc(t) &&
          !oc(e) &&
          !bc(t) &&
          !bc(e) &&
          t.tagName.toLowerCase() === e.tagName.toLowerCase()
        )
      }
      function cg(t, e) {
        return $a(t) && $a(e) && oc(t) && oc(e)
      }
      function lg(t, e, n) {
        if (e === n) {
          return true
        } else if (oc(e) && oc(n)) {
          return e.data === n.data
        } else if (t.isBlockFiller(e) && t.isBlockFiller(n)) {
          return true
        }
        return false
      }
      function dg(t, e) {
        const n = t.parent
        if (n.nodeType != Node.ELEMENT_NODE || t.offset != n.childNodes.length - 1) {
          return
        }
        const o = n.childNodes[t.offset]
        if (o && o.tagName == "BR") {
          e.addRange(e.getRangeAt(0))
        }
      }
      function hg(t, e) {
        const n = Array.from(t)
        if (n.length == 0 || !e) {
          return n
        }
        const o = n[n.length - 1]
        if (o == e) {
          n.pop()
        }
        return n
      }
      function ug(t) {
        const e = t.createElement("div")
        e.className = "ck-fake-selection-container"
        Object.assign(e.style, { position: "fixed", top: 0, left: "-9999px", width: "42px" })
        e.textContent = " "
        return e
      }
      function fg(t, e) {
        const n = t.data
        if (n == e) {
          return
        }
        const o = p(n, e)
        for (const e of o) {
          if (e.type === "insert") {
            t.insertData(e.index, e.values.join(""))
          } else {
            t.deleteData(e.index, e.howMany)
          }
        }
      }
      const pg = Kp(Xa.document)
      const gg = qp(Xa.document)
      const mg = $p(Xa.document)
      const kg = "data-ck-unsafe-attribute-"
      const bg = "data-ck-unsafe-element"
      class wg {
        constructor(t, { blockFillerMode: e, renderingMode: n = "editing" } = {}) {
          this._domToViewMapping = new WeakMap()
          this._viewToDomMapping = new WeakMap()
          this._fakeSelectionMapping = new WeakMap()
          this._rawContentElementMatcher = new Jh()
          this._encounteredRawContentDomNodes = new WeakSet()
          this.document = t
          this.renderingMode = n
          this.blockFillerMode = e || (n === "editing" ? "br" : "nbsp")
          this.preElements = ["pre"]
          this.blockElements = [
            "address",
            "article",
            "aside",
            "blockquote",
            "caption",
            "center",
            "dd",
            "details",
            "dir",
            "div",
            "dl",
            "dt",
            "fieldset",
            "figcaption",
            "figure",
            "footer",
            "form",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "header",
            "hgroup",
            "legend",
            "li",
            "main",
            "menu",
            "nav",
            "ol",
            "p",
            "pre",
            "section",
            "summary",
            "table",
            "tbody",
            "td",
            "tfoot",
            "th",
            "thead",
            "tr",
            "ul",
          ]
          this.inlineObjectElements = [
            "object",
            "iframe",
            "input",
            "button",
            "textarea",
            "select",
            "option",
            "video",
            "embed",
            "audio",
            "img",
            "canvas",
          ]
          this.unsafeElements = ["script", "style"]
          this._domDocument =
            this.renderingMode === "editing"
              ? Xa.document
              : Xa.document.implementation.createHTMLDocument("")
        }
        bindFakeSelection(t, e) {
          this._fakeSelectionMapping.set(t, new ap(e))
        }
        fakeSelectionToView(t) {
          return this._fakeSelectionMapping.get(t)
        }
        bindElements(t, e) {
          this._domToViewMapping.set(t, e)
          this._viewToDomMapping.set(e, t)
        }
        unbindDomElement(t) {
          const e = this._domToViewMapping.get(t)
          if (e) {
            this._domToViewMapping.delete(t)
            this._viewToDomMapping.delete(e)
            for (const e of Array.from(t.children)) {
              this.unbindDomElement(e)
            }
          }
        }
        bindDocumentFragments(t, e) {
          this._domToViewMapping.set(t, e)
          this._viewToDomMapping.set(e, t)
        }
        shouldRenderAttribute(t, e, n) {
          if (this.renderingMode === "data") {
            return true
          }
          t = t.toLowerCase()
          if (t.startsWith("on")) {
            return false
          }
          if (t === "srcdoc" && e.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) {
            return false
          }
          if (n === "img" && (t === "src" || t === "srcset")) {
            return true
          }
          if (n === "source" && t === "srcset") {
            return true
          }
          if (e.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i)) {
            return false
          }
          return true
        }
        setContentOf(t, e) {
          if (this.renderingMode === "data") {
            t.innerHTML = e
            return
          }
          const n = new DOMParser().parseFromString(e, "text/html")
          const o = n.createDocumentFragment()
          const r = n.body.childNodes
          while (r.length > 0) {
            o.appendChild(r[0])
          }
          const i = n.createTreeWalker(o, NodeFilter.SHOW_ELEMENT)
          const s = []
          let a
          while ((a = i.nextNode())) {
            s.push(a)
          }
          for (const t of s) {
            for (const e of t.getAttributeNames()) {
              this.setDomElementAttribute(t, e, t.getAttribute(e))
            }
            const e = t.tagName.toLowerCase()
            if (this._shouldRenameElement(e)) {
              yg(e)
              t.replaceWith(this._createReplacementDomElement(e, t))
            }
          }
          while (t.firstChild) {
            t.firstChild.remove()
          }
          t.append(o)
        }
        viewToDom(t, e = {}) {
          if (t.is("$text")) {
            const e = this._processDataFromViewText(t)
            return this._domDocument.createTextNode(e)
          } else {
            if (this.mapViewToDom(t)) {
              return this.mapViewToDom(t)
            }
            let n
            if (t.is("documentFragment")) {
              n = this._domDocument.createDocumentFragment()
              if (e.bind) {
                this.bindDocumentFragments(n, t)
              }
            } else if (t.is("uiElement")) {
              if (t.name === "$comment") {
                n = this._domDocument.createComment(t.getCustomProperty("$rawContent"))
              } else {
                n = t.render(this._domDocument, this)
              }
              if (e.bind) {
                this.bindElements(n, t)
              }
              return n
            } else {
              if (this._shouldRenameElement(t.name)) {
                yg(t.name)
                n = this._createReplacementDomElement(t.name)
              } else if (t.hasAttribute("xmlns")) {
                n = this._domDocument.createElementNS(t.getAttribute("xmlns"), t.name)
              } else {
                n = this._domDocument.createElement(t.name)
              }
              if (t.is("rawElement")) {
                t.render(n, this)
              }
              if (e.bind) {
                this.bindElements(n, t)
              }
              for (const e of t.getAttributeKeys()) {
                this.setDomElementAttribute(n, e, t.getAttribute(e), t)
              }
            }
            if (e.withChildren !== false) {
              for (const o of this.viewChildrenToDom(t, e)) {
                n.appendChild(o)
              }
            }
            return n
          }
        }
        setDomElementAttribute(t, e, n, o) {
          const r =
            this.shouldRenderAttribute(e, n, t.tagName.toLowerCase()) ||
            (o && o.shouldRenderUnsafeAttribute(e))
          if (!r) {
            B("domconverter-unsafe-attribute-detected", { domElement: t, key: e, value: n })
          }
          if (!wc(e)) {
            B("domconverter-invalid-attribute-detected", { domElement: t, key: e, value: n })
            return
          }
          if (t.hasAttribute(e) && !r) {
            t.removeAttribute(e)
          } else if (t.hasAttribute(kg + e) && r) {
            t.removeAttribute(kg + e)
          }
          t.setAttribute(r ? e : kg + e, n)
        }
        removeDomElementAttribute(t, e) {
          if (e == bg) {
            return
          }
          t.removeAttribute(e)
          t.removeAttribute(kg + e)
        }
        *viewChildrenToDom(t, e = {}) {
          const n = t.getFillerOffset && t.getFillerOffset()
          let o = 0
          for (const r of t.getChildren()) {
            if (n === o) {
              yield this._getBlockFiller()
            }
            const t =
              r.is("element") &&
              !!r.getCustomProperty("dataPipeline:transparentRendering") &&
              !hl(r.getAttributes())
            if (t && this.renderingMode == "data") {
              yield* this.viewChildrenToDom(r, e)
            } else {
              if (t) {
                B("domconverter-transparent-rendering-unsupported-in-editing-pipeline", {
                  viewElement: r,
                })
              }
              yield this.viewToDom(r, e)
            }
            o++
          }
          if (n === o) {
            yield this._getBlockFiller()
          }
        }
        viewRangeToDom(t) {
          const e = this.viewPositionToDom(t.start)
          const n = this.viewPositionToDom(t.end)
          const o = this._domDocument.createRange()
          o.setStart(e.parent, e.offset)
          o.setEnd(n.parent, n.offset)
          return o
        }
        viewPositionToDom(t) {
          const e = t.parent
          if (e.is("$text")) {
            const n = this.findCorrespondingDomText(e)
            if (!n) {
              return null
            }
            let o = t.offset
            if (Jp(n)) {
              o += Gp
            }
            return { parent: n, offset: o }
          } else {
            let n, o, r
            if (t.offset === 0) {
              n = this.mapViewToDom(e)
              if (!n) {
                return null
              }
              r = n.childNodes[0]
            } else {
              const e = t.nodeBefore
              o = e.is("$text") ? this.findCorrespondingDomText(e) : this.mapViewToDom(e)
              if (!o) {
                return null
              }
              n = o.parentNode
              r = o.nextSibling
            }
            if (oc(r) && Jp(r)) {
              return { parent: r, offset: Gp }
            }
            const i = o ? mc(o) + 1 : 0
            return { parent: n, offset: i }
          }
        }
        domToView(t, e = {}) {
          if (this.isBlockFiller(t)) {
            return null
          }
          const n = this.getHostViewElement(t)
          if (n) {
            return n
          }
          if (bc(t) && e.skipComments) {
            return null
          }
          if (oc(t)) {
            if (Zp(t)) {
              return null
            } else {
              const e = this._processDataFromDomText(t)
              return e === "" ? null : new Gh(this.document, e)
            }
          } else {
            if (this.mapDomToView(t)) {
              return this.mapDomToView(t)
            }
            let n
            if (this.isDocumentFragment(t)) {
              n = new Pp(this.document)
              if (e.bind) {
                this.bindDocumentFragments(t, n)
              }
            } else {
              n = this._createViewElement(t, e)
              if (e.bind) {
                this.bindElements(t, n)
              }
              const o = t.attributes
              if (o) {
                for (let t = o.length, e = 0; e < t; e++) {
                  n._setAttribute(o[e].name, o[e].value)
                }
              }
              if (this._isViewElementWithRawContent(n, e) || bc(t)) {
                const e = bc(t) ? t.data : t.innerHTML
                n._setCustomProperty("$rawContent", e)
                this._encounteredRawContentDomNodes.add(t)
                return n
              }
            }
            if (e.withChildren !== false) {
              for (const o of this.domChildrenToView(t, e)) {
                n._appendChild(o)
              }
            }
            return n
          }
        }
        *domChildrenToView(t, e) {
          for (let n = 0; n < t.childNodes.length; n++) {
            const o = t.childNodes[n]
            const r = this.domToView(o, e)
            if (r !== null) {
              yield r
            }
          }
        }
        domSelectionToView(t) {
          if (t.rangeCount === 1) {
            let e = t.getRangeAt(0).startContainer
            if (oc(e)) {
              e = e.parentNode
            }
            const n = this.fakeSelectionToView(e)
            if (n) {
              return n
            }
          }
          const e = this.isDomSelectionBackward(t)
          const n = []
          for (let e = 0; e < t.rangeCount; e++) {
            const o = t.getRangeAt(e)
            const r = this.domRangeToView(o)
            if (r) {
              n.push(r)
            }
          }
          return new ap(n, { backward: e })
        }
        domRangeToView(t) {
          const e = this.domPositionToView(t.startContainer, t.startOffset)
          const n = this.domPositionToView(t.endContainer, t.endOffset)
          if (e && n) {
            return new ip(e, n)
          }
          return null
        }
        domPositionToView(t, e = 0) {
          if (this.isBlockFiller(t)) {
            return this.domPositionToView(t.parentNode, mc(t))
          }
          const n = this.mapDomToView(t)
          if (n && (n.is("uiElement") || n.is("rawElement"))) {
            return rp._createBefore(n)
          }
          if (oc(t)) {
            if (Zp(t)) {
              return this.domPositionToView(t.parentNode, mc(t))
            }
            const n = this.findCorrespondingViewText(t)
            let o = e
            if (!n) {
              return null
            }
            if (Jp(t)) {
              o -= Gp
              o = o < 0 ? 0 : o
            }
            return new rp(n, o)
          } else {
            if (e === 0) {
              const e = this.mapDomToView(t)
              if (e) {
                return new rp(e, 0)
              }
            } else {
              const n = t.childNodes[e - 1]
              if ((oc(n) && Zp(n)) || (n && this.isBlockFiller(n))) {
                return this.domPositionToView(n.parentNode, mc(n))
              }
              const o = oc(n) ? this.findCorrespondingViewText(n) : this.mapDomToView(n)
              if (o && o.parent) {
                return new rp(o.parent, o.index + 1)
              }
            }
            return null
          }
        }
        mapDomToView(t) {
          const e = this.getHostViewElement(t)
          return e || this._domToViewMapping.get(t)
        }
        findCorrespondingViewText(t) {
          if (Zp(t)) {
            return null
          }
          const e = this.getHostViewElement(t)
          if (e) {
            return e
          }
          const n = t.previousSibling
          if (n) {
            if (!this.isElement(n)) {
              return null
            }
            const t = this.mapDomToView(n)
            if (t) {
              const e = t.nextSibling
              if (e instanceof Gh) {
                return e
              } else {
                return null
              }
            }
          } else {
            const e = this.mapDomToView(t.parentNode)
            if (e) {
              const t = e.getChild(0)
              if (t instanceof Gh) {
                return t
              } else {
                return null
              }
            }
          }
          return null
        }
        mapViewToDom(t) {
          return this._viewToDomMapping.get(t)
        }
        findCorrespondingDomText(t) {
          const e = t.previousSibling
          if (e && this.mapViewToDom(e)) {
            return this.mapViewToDom(e).nextSibling
          }
          if (!e && t.parent && this.mapViewToDom(t.parent)) {
            return this.mapViewToDom(t.parent).childNodes[0]
          }
          return null
        }
        focus(t) {
          const e = this.mapViewToDom(t)
          if (e && e.ownerDocument.activeElement !== e) {
            const { scrollX: t, scrollY: n } = Xa.window
            const o = []
            vg(e, (t) => {
              const { scrollLeft: e, scrollTop: n } = t
              o.push([e, n])
            })
            e.focus()
            vg(e, (t) => {
              const [e, n] = o.shift()
              t.scrollLeft = e
              t.scrollTop = n
            })
            Xa.window.scrollTo(t, n)
          }
        }
        isElement(t) {
          return t && t.nodeType == Node.ELEMENT_NODE
        }
        isDocumentFragment(t) {
          return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE
        }
        isBlockFiller(t) {
          if (this.blockFillerMode == "br") {
            return t.isEqualNode(pg)
          }
          if (
            t.tagName === "BR" &&
            Cg(t, this.blockElements) &&
            t.parentNode.childNodes.length === 1
          ) {
            return true
          }
          return t.isEqualNode(mg) || Ag(t, this.blockElements)
        }
        isDomSelectionBackward(t) {
          if (t.isCollapsed) {
            return false
          }
          const e = this._domDocument.createRange()
          try {
            e.setStart(t.anchorNode, t.anchorOffset)
            e.setEnd(t.focusNode, t.focusOffset)
          } catch (t) {
            return false
          }
          const n = e.collapsed
          e.detach()
          return n
        }
        getHostViewElement(t) {
          const e = ec(t)
          e.pop()
          while (e.length) {
            const t = e.pop()
            const n = this._domToViewMapping.get(t)
            if (n && (n.is("uiElement") || n.is("rawElement"))) {
              return n
            }
          }
          return null
        }
        isDomSelectionCorrect(t) {
          return (
            this._isDomSelectionPositionCorrect(t.anchorNode, t.anchorOffset) &&
            this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset)
          )
        }
        registerRawContentMatcher(t) {
          this._rawContentElementMatcher.add(t)
        }
        _getBlockFiller() {
          switch (this.blockFillerMode) {
            case "nbsp":
              return qp(this._domDocument)
            case "markedNbsp":
              return $p(this._domDocument)
            case "br":
              return Kp(this._domDocument)
          }
        }
        _isDomSelectionPositionCorrect(t, e) {
          if (oc(t) && Jp(t) && e < Gp) {
            return false
          }
          if (this.isElement(t) && Jp(t.childNodes[e])) {
            return false
          }
          const n = this.mapDomToView(t)
          if (n && (n.is("uiElement") || n.is("rawElement"))) {
            return false
          }
          return true
        }
        _processDataFromViewText(t) {
          let e = t.data
          if (t.getAncestors().some((t) => this.preElements.includes(t.name))) {
            return e
          }
          if (e.charAt(0) == " ") {
            const n = this._getTouchingInlineViewNode(t, false)
            const o = n && n.is("$textProxy") && this._nodeEndsWithSpace(n)
            if (o || !n) {
              e = " " + e.substr(1)
            }
          }
          if (e.charAt(e.length - 1) == " ") {
            const n = this._getTouchingInlineViewNode(t, true)
            const o = n && n.is("$textProxy") && n.data.charAt(0) == " "
            if (e.charAt(e.length - 2) == " " || !n || o) {
              e = e.substr(0, e.length - 1) + " "
            }
          }
          return e.replace(/ {2}/g, "  ")
        }
        _nodeEndsWithSpace(t) {
          if (t.getAncestors().some((t) => this.preElements.includes(t.name))) {
            return false
          }
          const e = this._processDataFromViewText(t)
          return e.charAt(e.length - 1) == " "
        }
        _processDataFromDomText(t) {
          let e = t.data
          if (_g(t, this.preElements)) {
            return Yp(t)
          }
          e = e.replace(/[ \n\t\r]{1,}/g, " ")
          const n = this._getTouchingInlineDomNode(t, false)
          const o = this._getTouchingInlineDomNode(t, true)
          const r = this._checkShouldLeftTrimDomText(t, n)
          const i = this._checkShouldRightTrimDomText(t, o)
          if (r) {
            e = e.replace(/^ /, "")
          }
          if (i) {
            e = e.replace(/ $/, "")
          }
          e = Yp(new Text(e))
          e = e.replace(/ \u00A0/g, "  ")
          const s = o && this.isElement(o) && o.tagName != "BR"
          const a = o && oc(o) && o.data.charAt(0) == " "
          if (/( |\u00A0)\u00A0$/.test(e) || !o || s || a) {
            e = e.replace(/\u00A0$/, " ")
          }
          if (r || (n && this.isElement(n) && n.tagName != "BR")) {
            e = e.replace(/^\u00A0/, " ")
          }
          return e
        }
        _checkShouldLeftTrimDomText(t, e) {
          if (!e) {
            return true
          }
          if (this.isElement(e)) {
            return e.tagName === "BR"
          }
          if (this._encounteredRawContentDomNodes.has(t.previousSibling)) {
            return false
          }
          return /[^\S\u00A0]/.test(e.data.charAt(e.data.length - 1))
        }
        _checkShouldRightTrimDomText(t, e) {
          if (e) {
            return false
          }
          return !Jp(t)
        }
        _getTouchingInlineViewNode(t, e) {
          const n = new op({
            startPosition: e ? rp._createAfter(t) : rp._createBefore(t),
            direction: e ? "forward" : "backward",
          })
          for (const t of n) {
            if (t.item.is("element") && this.inlineObjectElements.includes(t.item.name)) {
              return t.item
            } else if (t.item.is("containerElement")) {
              return null
            } else if (t.item.is("element", "br")) {
              return null
            } else if (t.item.is("$textProxy")) {
              return t.item
            }
          }
          return null
        }
        _getTouchingInlineDomNode(t, e) {
          if (!t.parentNode) {
            return null
          }
          const n = e ? "firstChild" : "lastChild"
          const o = e ? "nextSibling" : "previousSibling"
          let r = true
          let i = t
          do {
            if (!r && i[n]) {
              i = i[n]
            } else if (i[o]) {
              i = i[o]
              r = false
            } else {
              i = i.parentNode
              r = true
            }
            if (!i || this._isBlockElement(i)) {
              return null
            }
          } while (!(oc(i) || i.tagName == "BR" || this._isInlineObjectElement(i)))
          return i
        }
        _isBlockElement(t) {
          return this.isElement(t) && this.blockElements.includes(t.tagName.toLowerCase())
        }
        _isInlineObjectElement(t) {
          return this.isElement(t) && this.inlineObjectElements.includes(t.tagName.toLowerCase())
        }
        _createViewElement(t, e) {
          if (bc(t)) {
            return new yp(this.document, "$comment")
          }
          const n = e.keepOriginalCase ? t.tagName : t.tagName.toLowerCase()
          return new Uf(this.document, n)
        }
        _isViewElementWithRawContent(t, e) {
          return e.withChildren !== false && !!this._rawContentElementMatcher.match(t)
        }
        _shouldRenameElement(t) {
          const e = t.toLowerCase()
          return this.renderingMode === "editing" && this.unsafeElements.includes(e)
        }
        _createReplacementDomElement(t, e) {
          const n = this._domDocument.createElement("span")
          n.setAttribute(bg, t)
          if (e) {
            while (e.firstChild) {
              n.appendChild(e.firstChild)
            }
            for (const t of e.getAttributeNames()) {
              n.setAttribute(t, e.getAttribute(t))
            }
          }
          return n
        }
      }
      function _g(t, e) {
        const n = ec(t)
        return n.some((t) => t.tagName && e.includes(t.tagName.toLowerCase()))
      }
      function vg(t, e) {
        let n = t
        while (n) {
          e(n)
          n = n.parentElement
        }
      }
      function Ag(t, e) {
        const n = t.isEqualNode(gg)
        return n && Cg(t, e) && t.parentNode.childNodes.length === 1
      }
      function Cg(t, e) {
        const n = t.parentNode
        return !!n && !!n.tagName && e.includes(n.tagName.toLowerCase())
      }
      function yg(t) {
        if (t === "script") {
          B("domconverter-unsafe-script-element-detected")
        }
        if (t === "style") {
          B("domconverter-unsafe-style-element-detected")
        }
      }
      class xg extends Ua() {
        constructor(t) {
          super()
          this._isEnabled = false
          this.view = t
          this.document = t.document
        }
        get isEnabled() {
          return this._isEnabled
        }
        enable() {
          this._isEnabled = true
        }
        disable() {
          this._isEnabled = false
        }
        destroy() {
          this.disable()
          this.stopListening()
        }
        checkShouldIgnoreEventFromTarget(t) {
          if (t && t.nodeType === 3) {
            t = t.parentNode
          }
          if (!t || t.nodeType !== 1) {
            return false
          }
          return t.matches("[data-cke-ignore-events], [data-cke-ignore-events] *")
        }
      }
      var Eg = zf(function (t, e) {
        go(e, Qr(e), t)
      })
      const Dg = Eg
      class Sg {
        constructor(t, e, n) {
          this.view = t
          this.document = t.document
          this.domEvent = e
          this.domTarget = e.target
          Dg(this, n)
        }
        get target() {
          return this.view.domConverter.mapDomToView(this.domTarget)
        }
        preventDefault() {
          this.domEvent.preventDefault()
        }
        stopPropagation() {
          this.domEvent.stopPropagation()
        }
      }
      class Tg extends xg {
        constructor() {
          super(...arguments)
          this.useCapture = false
        }
        observe(t) {
          const e = typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType
          e.forEach((e) => {
            this.listenTo(
              t,
              e,
              (t, e) => {
                if (this.isEnabled && !this.checkShouldIgnoreEventFromTarget(e.target)) {
                  this.onDomEvent(e)
                }
              },
              { useCapture: this.useCapture }
            )
          })
        }
        stopObserving(t) {
          this.stopListening(t)
        }
        fire(t, e, n) {
          if (this.isEnabled) {
            this.document.fire(t, new Sg(this.view, e, n))
          }
        }
      }
      class Pg extends Tg {
        constructor() {
          super(...arguments)
          this.domEventType = ["keydown", "keyup"]
        }
        onDomEvent(t) {
          const e = {
            keyCode: t.keyCode,
            altKey: t.altKey,
            ctrlKey: t.ctrlKey,
            shiftKey: t.shiftKey,
            metaKey: t.metaKey,
            get keystroke() {
              return $c(this)
            },
          }
          this.fire(t.type, t, e)
        }
      }
      var Bg = function () {
        return Tt.Date.now()
      }
      const Rg = Bg
      var Og = /\s/
      function Mg(t) {
        var e = t.length
        while (e-- && Og.test(t.charAt(e))) {}
        return e
      }
      const Ig = Mg
      var zg = /^\s+/
      function Ng(t) {
        return t ? t.slice(0, Ig(t) + 1).replace(zg, "") : t
      }
      const Fg = Ng
      var Vg = 0 / 0
      var Lg = /^[-+]0x[0-9a-f]+$/i
      var jg = /^0b[01]+$/i
      var Hg = /^0o[0-7]+$/i
      var Wg = parseInt
      function qg(t) {
        if (typeof t == "number") {
          return t
        }
        if (au(t)) {
          return Vg
        }
        if (ot(t)) {
          var e = typeof t.valueOf == "function" ? t.valueOf() : t
          t = ot(e) ? e + "" : e
        }
        if (typeof t != "string") {
          return t === 0 ? t : +t
        }
        t = Fg(t)
        var n = jg.test(t)
        return n || Hg.test(t) ? Wg(t.slice(2), n ? 2 : 8) : Lg.test(t) ? Vg : +t
      }
      const $g = qg
      var Kg = "Expected a function"
      var Gg = Math.max,
        Ug = Math.min
      function Jg(t, e, n) {
        var o,
          r,
          i,
          s,
          a,
          c,
          l = 0,
          d = false,
          h = false,
          u = true
        if (typeof t != "function") {
          throw new TypeError(Kg)
        }
        e = $g(e) || 0
        if (ot(n)) {
          d = !!n.leading
          h = "maxWait" in n
          i = h ? Gg($g(n.maxWait) || 0, e) : i
          u = "trailing" in n ? !!n.trailing : u
        }
        function f(e) {
          var n = o,
            i = r
          o = r = undefined
          l = e
          s = t.apply(i, n)
          return s
        }
        function p(t) {
          l = t
          a = setTimeout(k, e)
          return d ? f(t) : s
        }
        function g(t) {
          var n = t - c,
            o = t - l,
            r = e - n
          return h ? Ug(r, i - o) : r
        }
        function m(t) {
          var n = t - c,
            o = t - l
          return c === undefined || n >= e || n < 0 || (h && o >= i)
        }
        function k() {
          var t = Rg()
          if (m(t)) {
            return b(t)
          }
          a = setTimeout(k, g(t))
        }
        function b(t) {
          a = undefined
          if (u && o) {
            return f(t)
          }
          o = r = undefined
          return s
        }
        function w() {
          if (a !== undefined) {
            clearTimeout(a)
          }
          l = 0
          o = c = r = a = undefined
        }
        function _() {
          return a === undefined ? s : b(Rg())
        }
        function v() {
          var t = Rg(),
            n = m(t)
          o = arguments
          r = this
          c = t
          if (n) {
            if (a === undefined) {
              return p(c)
            }
            if (h) {
              clearTimeout(a)
              a = setTimeout(k, e)
              return f(c)
            }
          }
          if (a === undefined) {
            a = setTimeout(k, e)
          }
          return s
        }
        v.cancel = w
        v.flush = _
        return v
      }
      const Zg = Jg
      class Yg extends xg {
        constructor(t) {
          super(t)
          this._fireSelectionChangeDoneDebounced = Zg((t) => {
            this.document.fire("selectionChangeDone", t)
          }, 200)
        }
        observe() {
          const t = this.document
          t.on(
            "arrowKey",
            (e, n) => {
              const o = t.selection
              if (o.isFake && this.isEnabled) {
                n.preventDefault()
              }
            },
            { context: "$capture" }
          )
          t.on(
            "arrowKey",
            (e, n) => {
              const o = t.selection
              if (o.isFake && this.isEnabled) {
                this._handleSelectionMove(n.keyCode)
              }
            },
            { priority: "lowest" }
          )
        }
        stopObserving() {}
        destroy() {
          super.destroy()
          this._fireSelectionChangeDoneDebounced.cancel()
        }
        _handleSelectionMove(t) {
          const e = this.document.selection
          const n = new ap(e.getRanges(), { backward: e.isBackward, fake: false })
          if (t == Wc.arrowleft || t == Wc.arrowup) {
            n.setTo(n.getFirstPosition())
          }
          if (t == Wc.arrowright || t == Wc.arrowdown) {
            n.setTo(n.getLastPosition())
          }
          const o = { oldSelection: e, newSelection: n, domSelection: null }
          this.document.fire("selectionChange", o)
          this._fireSelectionChangeDoneDebounced(o)
        }
      }
      var Qg = "__lodash_hash_undefined__"
      function Xg(t) {
        this.__data__.set(t, Qg)
        return this
      }
      const tm = Xg
      function em(t) {
        return this.__data__.has(t)
      }
      const nm = em
      function om(t) {
        var e = -1,
          n = t == null ? 0 : t.length
        this.__data__ = new Yn()
        while (++e < n) {
          this.add(t[e])
        }
      }
      om.prototype.add = om.prototype.push = tm
      om.prototype.has = nm
      const rm = om
      function im(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length
        while (++n < o) {
          if (e(t[n], n, t)) {
            return true
          }
        }
        return false
      }
      const sm = im
      function am(t, e) {
        return t.has(e)
      }
      const cm = am
      var lm = 1,
        dm = 2
      function hm(t, e, n, o, r, i) {
        var s = n & lm,
          a = t.length,
          c = e.length
        if (a != c && !(s && c > a)) {
          return false
        }
        var l = i.get(t)
        var d = i.get(e)
        if (l && d) {
          return l == e && d == t
        }
        var h = -1,
          u = true,
          f = n & dm ? new rm() : undefined
        i.set(t, e)
        i.set(e, t)
        while (++h < a) {
          var p = t[h],
            g = e[h]
          if (o) {
            var m = s ? o(g, p, h, e, t, i) : o(p, g, h, t, e, i)
          }
          if (m !== undefined) {
            if (m) {
              continue
            }
            u = false
            break
          }
          if (f) {
            if (
              !sm(e, function (t, e) {
                if (!cm(f, e) && (p === t || r(p, t, n, o, i))) {
                  return f.push(e)
                }
              })
            ) {
              u = false
              break
            }
          } else if (!(p === g || r(p, g, n, o, i))) {
            u = false
            break
          }
        }
        i["delete"](t)
        i["delete"](e)
        return u
      }
      const um = hm
      function fm(t) {
        var e = -1,
          n = Array(t.size)
        t.forEach(function (t, o) {
          n[++e] = [o, t]
        })
        return n
      }
      const pm = fm
      function gm(t) {
        var e = -1,
          n = Array(t.size)
        t.forEach(function (t) {
          n[++e] = t
        })
        return n
      }
      const mm = gm
      var km = 1,
        bm = 2
      var wm = "[object Boolean]",
        _m = "[object Date]",
        vm = "[object Error]",
        Am = "[object Map]",
        Cm = "[object Number]",
        ym = "[object RegExp]",
        xm = "[object Set]",
        Em = "[object String]",
        Dm = "[object Symbol]"
      var Sm = "[object ArrayBuffer]",
        Tm = "[object DataView]"
      var Pm = Bt ? Bt.prototype : undefined,
        Bm = Pm ? Pm.valueOf : undefined
      function Rm(t, e, n, o, r, i, s) {
        switch (n) {
          case Tm:
            if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) {
              return false
            }
            t = t.buffer
            e = e.buffer
          case Sm:
            if (t.byteLength != e.byteLength || !i(new ss(t), new ss(e))) {
              return false
            }
            return true
          case wm:
          case _m:
          case Cm:
            return me(+t, +e)
          case vm:
            return t.name == e.name && t.message == e.message
          case ym:
          case Em:
            return t == e + ""
          case Am:
            var a = pm
          case xm:
            var c = o & km
            a || (a = mm)
            if (t.size != e.size && !c) {
              return false
            }
            var l = s.get(t)
            if (l) {
              return l == e
            }
            o |= bm
            s.set(t, e)
            var d = um(a(t), a(e), o, r, i, s)
            s["delete"](t)
            return d
          case Dm:
            if (Bm) {
              return Bm.call(t) == Bm.call(e)
            }
        }
        return false
      }
      const Om = Rm
      var Mm = 1
      var Im = Object.prototype
      var zm = Im.hasOwnProperty
      function Nm(t, e, n, o, r, i) {
        var s = n & Mm,
          a = Bi(t),
          c = a.length,
          l = Bi(e),
          d = l.length
        if (c != d && !s) {
          return false
        }
        var h = c
        while (h--) {
          var u = a[h]
          if (!(s ? u in e : zm.call(e, u))) {
            return false
          }
        }
        var f = i.get(t)
        var p = i.get(e)
        if (f && p) {
          return f == e && p == t
        }
        var g = true
        i.set(t, e)
        i.set(e, t)
        var m = s
        while (++h < c) {
          u = a[h]
          var k = t[u],
            b = e[u]
          if (o) {
            var w = s ? o(b, k, u, e, t, i) : o(k, b, u, t, e, i)
          }
          if (!(w === undefined ? k === b || r(k, b, n, o, i) : w)) {
            g = false
            break
          }
          m || (m = u == "constructor")
        }
        if (g && !m) {
          var _ = t.constructor,
            v = e.constructor
          if (
            _ != v &&
            "constructor" in t &&
            "constructor" in e &&
            !(typeof _ == "function" && _ instanceof _ && typeof v == "function" && v instanceof v)
          ) {
            g = false
          }
        }
        i["delete"](t)
        i["delete"](e)
        return g
      }
      const Fm = Nm
      var Vm = 1
      var Lm = "[object Arguments]",
        jm = "[object Array]",
        Hm = "[object Object]"
      var Wm = Object.prototype
      var qm = Wm.hasOwnProperty
      function $m(t, e, n, o, r, i) {
        var s = Ut(t),
          a = Ut(e),
          c = s ? jm : ts(t),
          l = a ? jm : ts(e)
        c = c == Lm ? Hm : c
        l = l == Lm ? Hm : l
        var d = c == Hm,
          h = l == Hm,
          u = c == l
        if (u && Mo(t)) {
          if (!Mo(e)) {
            return false
          }
          s = true
          d = false
        }
        if (u && !d) {
          i || (i = new no())
          return s || xr(t) ? um(t, e, n, o, r, i) : Om(t, e, c, n, o, r, i)
        }
        if (!(n & Vm)) {
          var f = d && qm.call(t, "__wrapped__"),
            p = h && qm.call(e, "__wrapped__")
          if (f || p) {
            var g = f ? t.value() : t,
              m = p ? e.value() : e
            i || (i = new no())
            return r(g, m, n, o, i)
          }
        }
        if (!u) {
          return false
        }
        i || (i = new no())
        return Fm(t, e, n, o, r, i)
      }
      const Km = $m
      function Gm(t, e, n, o, r) {
        if (t === e) {
          return true
        }
        if (t == null || e == null || (!Zt(t) && !Zt(e))) {
          return t !== t && e !== e
        }
        return Km(t, e, n, o, Gm, r)
      }
      const Um = Gm
      function Jm(t, e, n) {
        n = typeof n == "function" ? n : undefined
        var o = n ? n(t, e) : undefined
        return o === undefined ? Um(t, e, undefined, n) : !!o
      }
      const Zm = Jm
      class Ym extends xg {
        constructor(t) {
          super(t)
          this._config = { childList: true, characterData: true, subtree: true }
          this.domConverter = t.domConverter
          this.renderer = t._renderer
          this._domElements = new Set()
          this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this))
        }
        flush() {
          this._onMutations(this._mutationObserver.takeRecords())
        }
        observe(t) {
          this._domElements.add(t)
          if (this.isEnabled) {
            this._mutationObserver.observe(t, this._config)
          }
        }
        stopObserving(t) {
          this._domElements.delete(t)
          if (this.isEnabled) {
            this._mutationObserver.disconnect()
            for (const t of this._domElements) {
              this._mutationObserver.observe(t, this._config)
            }
          }
        }
        enable() {
          super.enable()
          for (const t of this._domElements) {
            this._mutationObserver.observe(t, this._config)
          }
        }
        disable() {
          super.disable()
          this._mutationObserver.disconnect()
        }
        destroy() {
          super.destroy()
          this._mutationObserver.disconnect()
        }
        _onMutations(t) {
          if (t.length === 0) {
            return
          }
          const e = this.domConverter
          const n = new Set()
          const o = new Set()
          for (const n of t) {
            const t = e.mapDomToView(n.target)
            if (!t) {
              continue
            }
            if (t.is("uiElement") || t.is("rawElement")) {
              continue
            }
            if (n.type === "childList" && !this._isBogusBrMutation(n)) {
              o.add(t)
            }
          }
          for (const r of t) {
            const t = e.mapDomToView(r.target)
            if (t && (t.is("uiElement") || t.is("rawElement"))) {
              continue
            }
            if (r.type === "characterData") {
              const t = e.findCorrespondingViewText(r.target)
              if (t && !o.has(t.parent)) {
                n.add(t)
              } else if (!t && Jp(r.target)) {
                o.add(e.mapDomToView(r.target.parentNode))
              }
            }
          }
          let r = false
          for (const t of n) {
            r = true
            this.renderer.markToSync("text", t)
          }
          for (const t of o) {
            const n = e.mapViewToDom(t)
            const o = Array.from(t.getChildren())
            const i = Array.from(e.domChildrenToView(n, { withChildren: false }))
            if (!Zm(o, i, Qm)) {
              r = true
              this.renderer.markToSync("children", t)
            }
          }
          if (r) {
            this.view.forceRender()
          }
        }
        _isBogusBrMutation(t) {
          let e = null
          if (t.nextSibling === null && t.removedNodes.length === 0 && t.addedNodes.length == 1) {
            e = this.domConverter.domToView(t.addedNodes[0], { withChildren: false })
          }
          return e && e.is("element", "br")
        }
      }
      function Qm(t, e) {
        if (Array.isArray(t)) {
          return
        }
        if (t === e) {
          return true
        } else if (t.is("$text") && e.is("$text")) {
          return t.data === e.data
        }
        return false
      }
      class Xm extends Tg {
        constructor(t) {
          super(t)
          this._isFocusChanging = false
          this.domEventType = ["focus", "blur"]
          this.useCapture = true
          const e = this.document
          e.on("focus", () => {
            this._isFocusChanging = true
            this._renderTimeoutId = setTimeout(() => {
              this.flush()
              t.change(() => {})
            }, 50)
          })
          e.on("blur", (n, o) => {
            const r = e.selection.editableElement
            if (r === null || r === o.target) {
              e.isFocused = false
              this._isFocusChanging = false
              t.change(() => {})
            }
          })
        }
        flush() {
          if (this._isFocusChanging) {
            this._isFocusChanging = false
            this.document.isFocused = true
          }
        }
        onDomEvent(t) {
          this.fire(t.type, t)
        }
        destroy() {
          if (this._renderTimeoutId) {
            clearTimeout(this._renderTimeoutId)
          }
          super.destroy()
        }
      }
      class tk extends xg {
        constructor(t) {
          super(t)
          this.mutationObserver = t.getObserver(Ym)
          this.focusObserver = t.getObserver(Xm)
          this.selection = this.document.selection
          this.domConverter = t.domConverter
          this._documents = new WeakSet()
          this._fireSelectionChangeDoneDebounced = Zg((t) => {
            this.document.fire("selectionChangeDone", t)
          }, 200)
          this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3)
          this._documentIsSelectingInactivityTimeoutDebounced = Zg(
            () => (this.document.isSelecting = false),
            5e3
          )
          this._loopbackCounter = 0
        }
        observe(t) {
          const e = t.ownerDocument
          const n = () => {
            this.document.isSelecting = true
            this._documentIsSelectingInactivityTimeoutDebounced()
          }
          const o = () => {
            if (!this.document.isSelecting) {
              return
            }
            this._handleSelectionChange(null, e)
            this.document.isSelecting = false
            this._documentIsSelectingInactivityTimeoutDebounced.cancel()
          }
          this.listenTo(t, "selectstart", n, { priority: "highest" })
          this.listenTo(t, "keydown", o, { priority: "highest", useCapture: true })
          this.listenTo(t, "keyup", o, { priority: "highest", useCapture: true })
          if (this._documents.has(e)) {
            return
          }
          this.listenTo(e, "mouseup", o, { priority: "highest", useCapture: true })
          this.listenTo(e, "selectionchange", (t, n) => {
            if (this.document.isComposing && !i.isAndroid) {
              return
            }
            this._handleSelectionChange(n, e)
            this._documentIsSelectingInactivityTimeoutDebounced()
          })
          this._documents.add(e)
        }
        stopObserving(t) {
          this.stopListening(t)
        }
        destroy() {
          super.destroy()
          clearInterval(this._clearInfiniteLoopInterval)
          this._fireSelectionChangeDoneDebounced.cancel()
          this._documentIsSelectingInactivityTimeoutDebounced.cancel()
        }
        _reportInfiniteLoop() {}
        _handleSelectionChange(t, e) {
          if (!this.isEnabled) {
            return
          }
          const n = e.defaultView.getSelection()
          if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) {
            return
          }
          this.mutationObserver.flush()
          const o = this.domConverter.domSelectionToView(n)
          if (o.rangeCount == 0) {
            this.view.hasDomSelection = false
            return
          }
          this.view.hasDomSelection = true
          if (this.selection.isEqual(o) && this.domConverter.isDomSelectionCorrect(n)) {
            return
          }
          if (++this._loopbackCounter > 60) {
            this._reportInfiniteLoop()
            return
          }
          this.focusObserver.flush()
          if (this.selection.isSimilar(o)) {
            this.view.forceRender()
          } else {
            const t = { oldSelection: this.selection, newSelection: o, domSelection: n }
            this.document.fire("selectionChange", t)
            this._fireSelectionChangeDoneDebounced(t)
          }
        }
        _clearInfiniteLoop() {
          this._loopbackCounter = 0
        }
      }
      class ek extends Tg {
        constructor(t) {
          super(t)
          this.domEventType = ["compositionstart", "compositionupdate", "compositionend"]
          const e = this.document
          e.on(
            "compositionstart",
            () => {
              e.isComposing = true
            },
            { priority: "low" }
          )
          e.on(
            "compositionend",
            () => {
              e.isComposing = false
            },
            { priority: "low" }
          )
        }
        onDomEvent(t) {
          this.fire(t.type, t, { data: t.data })
        }
      }
      class nk {
        constructor(t, e = {}) {
          this._files = e.cacheFiles ? ok(t) : null
          this._native = t
        }
        get files() {
          if (!this._files) {
            this._files = ok(this._native)
          }
          return this._files
        }
        get types() {
          return this._native.types
        }
        getData(t) {
          return this._native.getData(t)
        }
        setData(t, e) {
          this._native.setData(t, e)
        }
        set effectAllowed(t) {
          this._native.effectAllowed = t
        }
        get effectAllowed() {
          return this._native.effectAllowed
        }
        set dropEffect(t) {
          this._native.dropEffect = t
        }
        get dropEffect() {
          return this._native.dropEffect
        }
        setDragImage(t, e, n) {
          this._native.setDragImage(t, e, n)
        }
        get isCanceled() {
          return this._native.dropEffect == "none" || !!this._native.mozUserCancelled
        }
      }
      function ok(t) {
        const e = Array.from(t.files || [])
        const n = Array.from(t.items || [])
        if (e.length) {
          return e
        }
        return n.filter((t) => t.kind === "file").map((t) => t.getAsFile())
      }
      class rk extends Tg {
        constructor() {
          super(...arguments)
          this.domEventType = "beforeinput"
        }
        onDomEvent(t) {
          const e = t.getTargetRanges()
          const n = this.view
          const o = n.document
          let r = null
          let s = null
          let a = []
          if (t.dataTransfer) {
            r = new nk(t.dataTransfer)
          }
          if (t.data !== null) {
            s = t.data
          } else if (r) {
            s = r.getData("text/plain")
          }
          if (o.selection.isFake) {
            a = Array.from(o.selection.getRanges())
          } else if (e.length) {
            a = e
              .map((t) => {
                const e = n.domConverter.domPositionToView(t.startContainer, t.startOffset)
                const o = n.domConverter.domPositionToView(t.endContainer, t.endOffset)
                if (e) {
                  return n.createRange(e, o)
                } else if (o) {
                  return n.createRange(o)
                }
              })
              .filter((t) => !!t)
          } else if (i.isAndroid) {
            const e = t.target.ownerDocument.defaultView.getSelection()
            a = Array.from(n.domConverter.domSelectionToView(e).getRanges())
          }
          if (i.isAndroid && t.inputType == "insertCompositionText" && s && s.endsWith("\n")) {
            this.fire(t.type, t, {
              inputType: "insertParagraph",
              targetRanges: [n.createRange(a[0].end)],
            })
            return
          }
          if (t.inputType == "insertText" && s && s.includes("\n")) {
            const e = s.split(/\n{1,2}/g)
            let n = a
            for (let i = 0; i < e.length; i++) {
              const s = e[i]
              if (s != "") {
                this.fire(t.type, t, {
                  data: s,
                  dataTransfer: r,
                  targetRanges: n,
                  inputType: t.inputType,
                  isComposing: t.isComposing,
                })
                n = [o.selection.getFirstRange()]
              }
              if (i + 1 < e.length) {
                this.fire(t.type, t, { inputType: "insertParagraph", targetRanges: n })
                n = [o.selection.getFirstRange()]
              }
            }
            return
          }
          this.fire(t.type, t, {
            data: s,
            dataTransfer: r,
            targetRanges: a,
            inputType: t.inputType,
            isComposing: t.isComposing,
          })
        }
      }
      class ik extends xg {
        constructor(t) {
          super(t)
          this.document.on("keydown", (t, e) => {
            if (this.isEnabled && Uc(e.keyCode)) {
              const n = new lp(this.document, "arrowKey", this.document.selection.getFirstRange())
              this.document.fire(n, e)
              if (n.stop.called) {
                t.stop()
              }
            }
          })
        }
        observe() {}
        stopObserving() {}
      }
      class sk extends xg {
        constructor(t) {
          super(t)
          const e = this.document
          e.on("keydown", (t, n) => {
            if (!this.isEnabled || n.keyCode != Wc.tab || n.ctrlKey) {
              return
            }
            const o = new lp(e, "tab", e.selection.getFirstRange())
            e.fire(o, n)
            if (o.stop.called) {
              t.stop()
            }
          })
        }
        observe() {}
        stopObserving() {}
      }
      var ak = 1,
        ck = 4
      function lk(t) {
        return Ia(t, ak | ck)
      }
      const dk = lk
      class hk extends dt() {
        constructor(t) {
          super()
          this.domRoots = new Map()
          this._initialDomRootAttributes = new WeakMap()
          this._observers = new Map()
          this._ongoingChange = false
          this._postFixersInProgress = false
          this._renderingDisabled = false
          this._hasChangedSinceTheLastRendering = false
          this.document = new kp(t)
          this.domConverter = new wg(this.document)
          this.set("isRenderingInProgress", false)
          this.set("hasDomSelection", false)
          this._renderer = new rg(this.domConverter, this.document.selection)
          this._renderer
            .bind("isFocused", "isSelecting", "isComposing")
            .to(this.document, "isFocused", "isSelecting", "isComposing")
          this._writer = new Rp(this.document)
          this.addObserver(Ym)
          this.addObserver(Xm)
          this.addObserver(tk)
          this.addObserver(Pg)
          this.addObserver(Yg)
          this.addObserver(ek)
          this.addObserver(ik)
          this.addObserver(rk)
          this.addObserver(sk)
          Qp(this)
          xp(this)
          this.on("render", () => {
            this._render()
            this.document.fire("layoutChanged")
            this._hasChangedSinceTheLastRendering = false
          })
          this.listenTo(this.document.selection, "change", () => {
            this._hasChangedSinceTheLastRendering = true
          })
          this.listenTo(this.document, "change:isFocused", () => {
            this._hasChangedSinceTheLastRendering = true
          })
        }
        attachDomRoot(t, e = "main") {
          const n = this.document.getRoot(e)
          n._name = t.tagName.toLowerCase()
          const o = {}
          for (const { name: e, value: r } of Array.from(t.attributes)) {
            o[e] = r
            if (e === "class") {
              this._writer.addClass(r.split(" "), n)
            } else {
              this._writer.setAttribute(e, r, n)
            }
          }
          this._initialDomRootAttributes.set(t, o)
          const r = () => {
            this._writer.setAttribute("contenteditable", (!n.isReadOnly).toString(), n)
            if (n.isReadOnly) {
              this._writer.addClass("ck-read-only", n)
            } else {
              this._writer.removeClass("ck-read-only", n)
            }
          }
          r()
          this.domRoots.set(e, t)
          this.domConverter.bindElements(t, n)
          this._renderer.markToSync("children", n)
          this._renderer.markToSync("attributes", n)
          this._renderer.domDocuments.add(t.ownerDocument)
          n.on("change:children", (t, e) => this._renderer.markToSync("children", e))
          n.on("change:attributes", (t, e) => this._renderer.markToSync("attributes", e))
          n.on("change:text", (t, e) => this._renderer.markToSync("text", e))
          n.on("change:isReadOnly", () => this.change(r))
          n.on("change", () => {
            this._hasChangedSinceTheLastRendering = true
          })
          for (const n of this._observers.values()) {
            n.observe(t, e)
          }
        }
        detachDomRoot(t) {
          const e = this.domRoots.get(t)
          Array.from(e.attributes).forEach(({ name: t }) => e.removeAttribute(t))
          const n = this._initialDomRootAttributes.get(e)
          for (const t in n) {
            e.setAttribute(t, n[t])
          }
          this.domRoots.delete(t)
          this.domConverter.unbindDomElement(e)
          for (const t of this._observers.values()) {
            t.stopObserving(e)
          }
        }
        getDomRoot(t = "main") {
          return this.domRoots.get(t)
        }
        addObserver(t) {
          let e = this._observers.get(t)
          if (e) {
            return e
          }
          e = new t(this)
          this._observers.set(t, e)
          for (const [t, n] of this.domRoots) {
            e.observe(n, t)
          }
          e.enable()
          return e
        }
        getObserver(t) {
          return this._observers.get(t)
        }
        disableObservers() {
          for (const t of this._observers.values()) {
            t.disable()
          }
        }
        enableObservers() {
          for (const t of this._observers.values()) {
            t.enable()
          }
        }
        scrollToTheSelection({
          alignToTop: t,
          forceScroll: e,
          viewportOffset: n = 20,
          ancestorOffset: o = 20,
        } = {}) {
          const r = this.document.selection.getFirstRange()
          if (!r) {
            return
          }
          const i = dk({ alignToTop: t, forceScroll: e, viewportOffset: n, ancestorOffset: o })
          if (typeof n === "number") {
            n = { top: n, bottom: n, left: n, right: n }
          }
          const s = {
            target: this.domConverter.viewRangeToDom(r),
            viewportOffset: n,
            ancestorOffset: o,
            alignToTop: t,
            forceScroll: e,
          }
          this.fire("scrollToTheSelection", s, i)
          Tc(s)
        }
        focus() {
          if (!this.document.isFocused) {
            const t = this.document.selection.editableElement
            if (t) {
              this.domConverter.focus(t)
              this.forceRender()
            } else {
            }
          }
        }
        change(t) {
          if (this.isRenderingInProgress || this._postFixersInProgress) {
            throw new P("cannot-change-view-tree", this)
          }
          try {
            if (this._ongoingChange) {
              return t(this._writer)
            }
            this._ongoingChange = true
            const e = t(this._writer)
            this._ongoingChange = false
            if (!this._renderingDisabled && this._hasChangedSinceTheLastRendering) {
              this._postFixersInProgress = true
              this.document._callPostFixers(this._writer)
              this._postFixersInProgress = false
              this.fire("render")
            }
            return e
          } catch (t) {
            P.rethrowUnexpectedError(t, this)
          }
        }
        forceRender() {
          this._hasChangedSinceTheLastRendering = true
          this.getObserver(Xm).flush()
          this.change(() => {})
        }
        destroy() {
          for (const t of this._observers.values()) {
            t.destroy()
          }
          this.document.destroy()
          this.stopListening()
        }
        createPositionAt(t, e) {
          return rp._createAt(t, e)
        }
        createPositionAfter(t) {
          return rp._createAfter(t)
        }
        createPositionBefore(t) {
          return rp._createBefore(t)
        }
        createRange(t, e) {
          return new ip(t, e)
        }
        createRangeOn(t) {
          return ip._createOn(t)
        }
        createRangeIn(t) {
          return ip._createIn(t)
        }
        createSelection(...t) {
          return new ap(...t)
        }
        _disableRendering(t) {
          this._renderingDisabled = t
          if (t == false) {
            this.change(() => {})
          }
        }
        _render() {
          this.isRenderingInProgress = true
          this.disableObservers()
          this._renderer.render()
          this.enableObservers()
          this.isRenderingInProgress = false
        }
      }
      class uk {
        is() {
          throw new Error("is() method is abstract")
        }
      }
      class fk extends uk {
        constructor(t) {
          super()
          this.parent = null
          this._attrs = gl(t)
        }
        get document() {
          return null
        }
        get index() {
          let t
          if (!this.parent) {
            return null
          }
          if ((t = this.parent.getChildIndex(this)) === null) {
            throw new P("model-node-not-found-in-parent", this)
          }
          return t
        }
        get startOffset() {
          let t
          if (!this.parent) {
            return null
          }
          if ((t = this.parent.getChildStartOffset(this)) === null) {
            throw new P("model-node-not-found-in-parent", this)
          }
          return t
        }
        get offsetSize() {
          return 1
        }
        get endOffset() {
          if (!this.parent) {
            return null
          }
          return this.startOffset + this.offsetSize
        }
        get nextSibling() {
          const t = this.index
          return (t !== null && this.parent.getChild(t + 1)) || null
        }
        get previousSibling() {
          const t = this.index
          return (t !== null && this.parent.getChild(t - 1)) || null
        }
        get root() {
          let t = this
          while (t.parent) {
            t = t.parent
          }
          return t
        }
        isAttached() {
          return this.parent === null ? false : this.root.isAttached()
        }
        getPath() {
          const t = []
          let e = this
          while (e.parent) {
            t.unshift(e.startOffset)
            e = e.parent
          }
          return t
        }
        getAncestors(t = {}) {
          const e = []
          let n = t.includeSelf ? this : this.parent
          while (n) {
            e[t.parentFirst ? "push" : "unshift"](n)
            n = n.parent
          }
          return e
        }
        getCommonAncestor(t, e = {}) {
          const n = this.getAncestors(e)
          const o = t.getAncestors(e)
          let r = 0
          while (n[r] == o[r] && n[r]) {
            r++
          }
          return r === 0 ? null : n[r - 1]
        }
        isBefore(t) {
          if (this == t) {
            return false
          }
          if (this.root !== t.root) {
            return false
          }
          const e = this.getPath()
          const n = t.getPath()
          const o = Ct(e, n)
          switch (o) {
            case "prefix":
              return true
            case "extension":
              return false
            default:
              return e[o] < n[o]
          }
        }
        isAfter(t) {
          if (this == t) {
            return false
          }
          if (this.root !== t.root) {
            return false
          }
          return !this.isBefore(t)
        }
        hasAttribute(t) {
          return this._attrs.has(t)
        }
        getAttribute(t) {
          return this._attrs.get(t)
        }
        getAttributes() {
          return this._attrs.entries()
        }
        getAttributeKeys() {
          return this._attrs.keys()
        }
        toJSON() {
          const t = {}
          if (this._attrs.size) {
            t.attributes = Array.from(this._attrs).reduce((t, e) => {
              t[e[0]] = e[1]
              return t
            }, {})
          }
          return t
        }
        _clone(t) {
          return new this.constructor(this._attrs)
        }
        _remove() {
          this.parent._removeChildren(this.index)
        }
        _setAttribute(t, e) {
          this._attrs.set(t, e)
        }
        _setAttributesTo(t) {
          this._attrs = gl(t)
        }
        _removeAttribute(t) {
          return this._attrs.delete(t)
        }
        _clearAttributes() {
          this._attrs.clear()
        }
      }
      fk.prototype.is = function (t) {
        return t === "node" || t === "model:node"
      }
      class pk {
        constructor(t) {
          this._nodes = []
          if (t) {
            this._insertNodes(0, t)
          }
        }
        [Symbol.iterator]() {
          return this._nodes[Symbol.iterator]()
        }
        get length() {
          return this._nodes.length
        }
        get maxOffset() {
          return this._nodes.reduce((t, e) => t + e.offsetSize, 0)
        }
        getNode(t) {
          return this._nodes[t] || null
        }
        getNodeIndex(t) {
          const e = this._nodes.indexOf(t)
          return e == -1 ? null : e
        }
        getNodeStartOffset(t) {
          const e = this.getNodeIndex(t)
          return e === null ? null : this._nodes.slice(0, e).reduce((t, e) => t + e.offsetSize, 0)
        }
        indexToOffset(t) {
          if (t == this._nodes.length) {
            return this.maxOffset
          }
          const e = this._nodes[t]
          if (!e) {
            throw new P("model-nodelist-index-out-of-bounds", this)
          }
          return this.getNodeStartOffset(e)
        }
        offsetToIndex(t) {
          let e = 0
          for (const n of this._nodes) {
            if (t >= e && t < e + n.offsetSize) {
              return this.getNodeIndex(n)
            }
            e += n.offsetSize
          }
          if (e != t) {
            throw new P("model-nodelist-offset-out-of-bounds", this, { offset: t, nodeList: this })
          }
          return this.length
        }
        _insertNodes(t, e) {
          for (const t of e) {
            if (!(t instanceof fk)) {
              throw new P("model-nodelist-insertnodes-not-node", this)
            }
          }
          this._nodes = kl(this._nodes, Array.from(e), t, 0)
        }
        _removeNodes(t, e = 1) {
          return this._nodes.splice(t, e)
        }
        toJSON() {
          return this._nodes.map((t) => t.toJSON())
        }
      }
      class gk extends fk {
        constructor(t, e) {
          super(e)
          this._data = t || ""
        }
        get offsetSize() {
          return this.data.length
        }
        get data() {
          return this._data
        }
        toJSON() {
          const t = super.toJSON()
          t.data = this.data
          return t
        }
        _clone() {
          return new gk(this.data, this.getAttributes())
        }
        static fromJSON(t) {
          return new gk(t.data, t.attributes)
        }
      }
      gk.prototype.is = function (t) {
        return (
          t === "$text" ||
          t === "model:$text" ||
          t === "text" ||
          t === "model:text" ||
          t === "node" ||
          t === "model:node"
        )
      }
      class mk extends uk {
        constructor(t, e, n) {
          super()
          this.textNode = t
          if (e < 0 || e > t.offsetSize) {
            throw new P("model-textproxy-wrong-offsetintext", this)
          }
          if (n < 0 || e + n > t.offsetSize) {
            throw new P("model-textproxy-wrong-length", this)
          }
          this.data = t.data.substring(e, e + n)
          this.offsetInText = e
        }
        get startOffset() {
          return this.textNode.startOffset !== null
            ? this.textNode.startOffset + this.offsetInText
            : null
        }
        get offsetSize() {
          return this.data.length
        }
        get endOffset() {
          return this.startOffset !== null ? this.startOffset + this.offsetSize : null
        }
        get isPartial() {
          return this.offsetSize !== this.textNode.offsetSize
        }
        get parent() {
          return this.textNode.parent
        }
        get root() {
          return this.textNode.root
        }
        getPath() {
          const t = this.textNode.getPath()
          if (t.length > 0) {
            t[t.length - 1] += this.offsetInText
          }
          return t
        }
        getAncestors(t = {}) {
          const e = []
          let n = t.includeSelf ? this : this.parent
          while (n) {
            e[t.parentFirst ? "push" : "unshift"](n)
            n = n.parent
          }
          return e
        }
        hasAttribute(t) {
          return this.textNode.hasAttribute(t)
        }
        getAttribute(t) {
          return this.textNode.getAttribute(t)
        }
        getAttributes() {
          return this.textNode.getAttributes()
        }
        getAttributeKeys() {
          return this.textNode.getAttributeKeys()
        }
      }
      mk.prototype.is = function (t) {
        return (
          t === "$textProxy" ||
          t === "model:$textProxy" ||
          t === "textProxy" ||
          t === "model:textProxy"
        )
      }
      class kk extends fk {
        constructor(t, e, n) {
          super(e)
          this._children = new pk()
          this.name = t
          if (n) {
            this._insertChild(0, n)
          }
        }
        get childCount() {
          return this._children.length
        }
        get maxOffset() {
          return this._children.maxOffset
        }
        get isEmpty() {
          return this.childCount === 0
        }
        getChild(t) {
          return this._children.getNode(t)
        }
        getChildren() {
          return this._children[Symbol.iterator]()
        }
        getChildIndex(t) {
          return this._children.getNodeIndex(t)
        }
        getChildStartOffset(t) {
          return this._children.getNodeStartOffset(t)
        }
        offsetToIndex(t) {
          return this._children.offsetToIndex(t)
        }
        getNodeByPath(t) {
          let e = this
          for (const n of t) {
            e = e.getChild(e.offsetToIndex(n))
          }
          return e
        }
        findAncestor(t, e = {}) {
          let n = e.includeSelf ? this : this.parent
          while (n) {
            if (n.name === t) {
              return n
            }
            n = n.parent
          }
          return null
        }
        toJSON() {
          const t = super.toJSON()
          t.name = this.name
          if (this._children.length > 0) {
            t.children = []
            for (const e of this._children) {
              t.children.push(e.toJSON())
            }
          }
          return t
        }
        _clone(t = false) {
          const e = t ? Array.from(this._children).map((t) => t._clone(true)) : undefined
          return new kk(this.name, this.getAttributes(), e)
        }
        _appendChild(t) {
          this._insertChild(this.childCount, t)
        }
        _insertChild(t, e) {
          const n = bk(e)
          for (const t of n) {
            if (t.parent !== null) {
              t._remove()
            }
            t.parent = this
          }
          this._children._insertNodes(t, n)
        }
        _removeChildren(t, e = 1) {
          const n = this._children._removeNodes(t, e)
          for (const t of n) {
            t.parent = null
          }
          return n
        }
        static fromJSON(t) {
          let e
          if (t.children) {
            e = []
            for (const n of t.children) {
              if (n.name) {
                e.push(kk.fromJSON(n))
              } else {
                e.push(gk.fromJSON(n))
              }
            }
          }
          return new kk(t.name, t.attributes, e)
        }
      }
      kk.prototype.is = function (t, e) {
        if (!e) {
          return t === "element" || t === "model:element" || t === "node" || t === "model:node"
        }
        return e === this.name && (t === "element" || t === "model:element")
      }
      function bk(t) {
        if (typeof t == "string") {
          return [new gk(t)]
        }
        if (!yt(t)) {
          t = [t]
        }
        return Array.from(t).map((t) => {
          if (typeof t == "string") {
            return new gk(t)
          }
          if (t instanceof mk) {
            return new gk(t.data, t.getAttributes())
          }
          return t
        })
      }
      class wk {
        constructor(t) {
          if (!t || (!t.boundaries && !t.startPosition)) {
            throw new P("model-tree-walker-no-start-position", null)
          }
          const e = t.direction || "forward"
          if (e != "forward" && e != "backward") {
            throw new P("model-tree-walker-unknown-direction", t, { direction: e })
          }
          this.direction = e
          this.boundaries = t.boundaries || null
          if (t.startPosition) {
            this._position = t.startPosition.clone()
          } else {
            this._position = vk._createAt(
              this.boundaries[this.direction == "backward" ? "end" : "start"]
            )
          }
          this.position.stickiness = "toNone"
          this.singleCharacters = !!t.singleCharacters
          this.shallow = !!t.shallow
          this.ignoreElementEnd = !!t.ignoreElementEnd
          this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null
          this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null
          this._visitedParent = this.position.parent
        }
        [Symbol.iterator]() {
          return this
        }
        get position() {
          return this._position
        }
        skip(t) {
          let e, n, o, r
          do {
            o = this.position
            r = this._visitedParent
            ;({ done: e, value: n } = this.next())
          } while (!e && t(n))
          if (!e) {
            this._position = o
            this._visitedParent = r
          }
        }
        next() {
          if (this.direction == "forward") {
            return this._next()
          } else {
            return this._previous()
          }
        }
        _next() {
          const t = this.position
          const e = this.position.clone()
          const n = this._visitedParent
          if (n.parent === null && e.offset === n.maxOffset) {
            return { done: true, value: undefined }
          }
          if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset) {
            return { done: true, value: undefined }
          }
          const o = Ak(e, n)
          const r = o || Ck(e, n, o)
          if (r instanceof kk) {
            if (!this.shallow) {
              e.path.push(0)
              this._visitedParent = r
            } else {
              if (this.boundaries && this.boundaries.end.isBefore(e)) {
                return { done: true, value: undefined }
              }
              e.offset++
            }
            this._position = e
            return _k("elementStart", r, t, e, 1)
          }
          if (r instanceof gk) {
            let o
            if (this.singleCharacters) {
              o = 1
            } else {
              let t = r.endOffset
              if (this._boundaryEndParent == n && this.boundaries.end.offset < t) {
                t = this.boundaries.end.offset
              }
              o = t - e.offset
            }
            const i = e.offset - r.startOffset
            const s = new mk(r, i, o)
            e.offset += o
            this._position = e
            return _k("text", s, t, e, o)
          }
          e.path.pop()
          e.offset++
          this._position = e
          this._visitedParent = n.parent
          if (this.ignoreElementEnd) {
            return this._next()
          }
          return _k("elementEnd", n, t, e)
        }
        _previous() {
          const t = this.position
          const e = this.position.clone()
          const n = this._visitedParent
          if (n.parent === null && e.offset === 0) {
            return { done: true, value: undefined }
          }
          if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset) {
            return { done: true, value: undefined }
          }
          const o = e.parent
          const r = Ak(e, o)
          const i = r || yk(e, o, r)
          if (i instanceof kk) {
            e.offset--
            if (this.shallow) {
              this._position = e
              return _k("elementStart", i, t, e, 1)
            }
            e.path.push(i.maxOffset)
            this._position = e
            this._visitedParent = i
            if (this.ignoreElementEnd) {
              return this._previous()
            }
            return _k("elementEnd", i, t, e)
          }
          if (i instanceof gk) {
            let o
            if (this.singleCharacters) {
              o = 1
            } else {
              let t = i.startOffset
              if (this._boundaryStartParent == n && this.boundaries.start.offset > t) {
                t = this.boundaries.start.offset
              }
              o = e.offset - t
            }
            const r = e.offset - i.startOffset
            const s = new mk(i, r - o, o)
            e.offset -= o
            this._position = e
            return _k("text", s, t, e, o)
          }
          e.path.pop()
          this._position = e
          this._visitedParent = n.parent
          return _k("elementStart", n, t, e, 1)
        }
      }
      function _k(t, e, n, o, r) {
        return {
          done: false,
          value: { type: t, item: e, previousPosition: n, nextPosition: o, length: r },
        }
      }
      class vk extends uk {
        constructor(t, e, n = "toNone") {
          super()
          if (!t.is("element") && !t.is("documentFragment")) {
            throw new P("model-position-root-invalid", t)
          }
          if (!(e instanceof Array) || e.length === 0) {
            throw new P("model-position-path-incorrect-format", t, { path: e })
          }
          if (t.is("rootElement")) {
            e = e.slice()
          } else {
            e = [...t.getPath(), ...e]
            t = t.root
          }
          this.root = t
          this.path = e
          this.stickiness = n
        }
        get offset() {
          return this.path[this.path.length - 1]
        }
        set offset(t) {
          this.path[this.path.length - 1] = t
        }
        get parent() {
          let t = this.root
          for (let e = 0; e < this.path.length - 1; e++) {
            t = t.getChild(t.offsetToIndex(this.path[e]))
            if (!t) {
              throw new P("model-position-path-incorrect", this, { position: this })
            }
          }
          if (t.is("$text")) {
            throw new P("model-position-path-incorrect", this, { position: this })
          }
          return t
        }
        get index() {
          return this.parent.offsetToIndex(this.offset)
        }
        get textNode() {
          return Ak(this, this.parent)
        }
        get nodeAfter() {
          const t = this.parent
          return Ck(this, t, Ak(this, t))
        }
        get nodeBefore() {
          const t = this.parent
          return yk(this, t, Ak(this, t))
        }
        get isAtStart() {
          return this.offset === 0
        }
        get isAtEnd() {
          return this.offset == this.parent.maxOffset
        }
        compareWith(t) {
          if (this.root != t.root) {
            return "different"
          }
          const e = Ct(this.path, t.path)
          switch (e) {
            case "same":
              return "same"
            case "prefix":
              return "before"
            case "extension":
              return "after"
            default:
              return this.path[e] < t.path[e] ? "before" : "after"
          }
        }
        getLastMatchingPosition(t, e = {}) {
          e.startPosition = this
          const n = new wk(e)
          n.skip(t)
          return n.position
        }
        getParentPath() {
          return this.path.slice(0, -1)
        }
        getAncestors() {
          const t = this.parent
          if (t.is("documentFragment")) {
            return [t]
          } else {
            return t.getAncestors({ includeSelf: true })
          }
        }
        findAncestor(t) {
          const e = this.parent
          if (e.is("element")) {
            return e.findAncestor(t, { includeSelf: true })
          }
          return null
        }
        getCommonPath(t) {
          if (this.root != t.root) {
            return []
          }
          const e = Ct(this.path, t.path)
          const n = typeof e == "string" ? Math.min(this.path.length, t.path.length) : e
          return this.path.slice(0, n)
        }
        getCommonAncestor(t) {
          const e = this.getAncestors()
          const n = t.getAncestors()
          let o = 0
          while (e[o] == n[o] && e[o]) {
            o++
          }
          return o === 0 ? null : e[o - 1]
        }
        getShiftedBy(t) {
          const e = this.clone()
          const n = e.offset + t
          e.offset = n < 0 ? 0 : n
          return e
        }
        isAfter(t) {
          return this.compareWith(t) == "after"
        }
        isBefore(t) {
          return this.compareWith(t) == "before"
        }
        isEqual(t) {
          return this.compareWith(t) == "same"
        }
        isTouching(t) {
          if (this.root !== t.root) {
            return false
          }
          const e = Math.min(this.path.length, t.path.length)
          for (let n = 0; n < e; n++) {
            const e = this.path[n] - t.path[n]
            if (e < -1 || e > 1) {
              return false
            } else if (e === 1) {
              return xk(t, this, n)
            } else if (e === -1) {
              return xk(this, t, n)
            }
          }
          if (this.path.length === t.path.length) {
            return true
          } else if (this.path.length > t.path.length) {
            return Ek(this.path, e)
          } else {
            return Ek(t.path, e)
          }
        }
        hasSameParentAs(t) {
          if (this.root !== t.root) {
            return false
          }
          const e = this.getParentPath()
          const n = t.getParentPath()
          return Ct(e, n) == "same"
        }
        getTransformedByOperation(t) {
          let e
          switch (t.type) {
            case "insert":
              e = this._getTransformedByInsertOperation(t)
              break
            case "move":
            case "remove":
            case "reinsert":
              e = this._getTransformedByMoveOperation(t)
              break
            case "split":
              e = this._getTransformedBySplitOperation(t)
              break
            case "merge":
              e = this._getTransformedByMergeOperation(t)
              break
            default:
              e = vk._createAt(this)
              break
          }
          return e
        }
        _getTransformedByInsertOperation(t) {
          return this._getTransformedByInsertion(t.position, t.howMany)
        }
        _getTransformedByMoveOperation(t) {
          return this._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany)
        }
        _getTransformedBySplitOperation(t) {
          const e = t.movedRange
          const n =
            e.containsPosition(this) || (e.start.isEqual(this) && this.stickiness == "toNext")
          if (n) {
            return this._getCombined(t.splitPosition, t.moveTargetPosition)
          } else {
            if (t.graveyardPosition) {
              return this._getTransformedByMove(t.graveyardPosition, t.insertionPosition, 1)
            } else {
              return this._getTransformedByInsertion(t.insertionPosition, 1)
            }
          }
        }
        _getTransformedByMergeOperation(t) {
          const e = t.movedRange
          const n = e.containsPosition(this) || e.start.isEqual(this)
          let o
          if (n) {
            o = this._getCombined(t.sourcePosition, t.targetPosition)
            if (t.sourcePosition.isBefore(t.targetPosition)) {
              o = o._getTransformedByDeletion(t.deletionPosition, 1)
            }
          } else if (this.isEqual(t.deletionPosition)) {
            o = vk._createAt(t.deletionPosition)
          } else {
            o = this._getTransformedByMove(t.deletionPosition, t.graveyardPosition, 1)
          }
          return o
        }
        _getTransformedByDeletion(t, e) {
          const n = vk._createAt(this)
          if (this.root != t.root) {
            return n
          }
          if (Ct(t.getParentPath(), this.getParentPath()) == "same") {
            if (t.offset < this.offset) {
              if (t.offset + e > this.offset) {
                return null
              } else {
                n.offset -= e
              }
            }
          } else if (Ct(t.getParentPath(), this.getParentPath()) == "prefix") {
            const o = t.path.length - 1
            if (t.offset <= this.path[o]) {
              if (t.offset + e > this.path[o]) {
                return null
              } else {
                n.path[o] -= e
              }
            }
          }
          return n
        }
        _getTransformedByInsertion(t, e) {
          const n = vk._createAt(this)
          if (this.root != t.root) {
            return n
          }
          if (Ct(t.getParentPath(), this.getParentPath()) == "same") {
            if (
              t.offset < this.offset ||
              (t.offset == this.offset && this.stickiness != "toPrevious")
            ) {
              n.offset += e
            }
          } else if (Ct(t.getParentPath(), this.getParentPath()) == "prefix") {
            const o = t.path.length - 1
            if (t.offset <= this.path[o]) {
              n.path[o] += e
            }
          }
          return n
        }
        _getTransformedByMove(t, e, n) {
          e = e._getTransformedByDeletion(t, n)
          if (t.isEqual(e)) {
            return vk._createAt(this)
          }
          const o = this._getTransformedByDeletion(t, n)
          const r =
            o === null ||
            (t.isEqual(this) && this.stickiness == "toNext") ||
            (t.getShiftedBy(n).isEqual(this) && this.stickiness == "toPrevious")
          if (r) {
            return this._getCombined(t, e)
          } else {
            return o._getTransformedByInsertion(e, n)
          }
        }
        _getCombined(t, e) {
          const n = t.path.length - 1
          const o = vk._createAt(e)
          o.stickiness = this.stickiness
          o.offset = o.offset + this.path[n] - t.offset
          o.path = [...o.path, ...this.path.slice(n + 1)]
          return o
        }
        toJSON() {
          return {
            root: this.root.toJSON(),
            path: Array.from(this.path),
            stickiness: this.stickiness,
          }
        }
        clone() {
          return new this.constructor(this.root, this.path, this.stickiness)
        }
        static _createAt(t, e, n = "toNone") {
          if (t instanceof vk) {
            return new vk(t.root, t.path, t.stickiness)
          } else {
            const o = t
            if (e == "end") {
              e = o.maxOffset
            } else if (e == "before") {
              return this._createBefore(o, n)
            } else if (e == "after") {
              return this._createAfter(o, n)
            } else if (e !== 0 && !e) {
              throw new P("model-createpositionat-offset-required", [this, t])
            }
            if (!o.is("element") && !o.is("documentFragment")) {
              throw new P("model-position-parent-incorrect", [this, t])
            }
            const r = o.getPath()
            r.push(e)
            return new this(o.root, r, n)
          }
        }
        static _createAfter(t, e) {
          if (!t.parent) {
            throw new P("model-position-after-root", [this, t], { root: t })
          }
          return this._createAt(t.parent, t.endOffset, e)
        }
        static _createBefore(t, e) {
          if (!t.parent) {
            throw new P("model-position-before-root", t, { root: t })
          }
          return this._createAt(t.parent, t.startOffset, e)
        }
        static fromJSON(t, e) {
          if (t.root === "$graveyard") {
            const n = new vk(e.graveyard, t.path)
            n.stickiness = t.stickiness
            return n
          }
          if (!e.getRoot(t.root)) {
            throw new P("model-position-fromjson-no-root", e, { rootName: t.root })
          }
          return new vk(e.getRoot(t.root), t.path, t.stickiness)
        }
      }
      vk.prototype.is = function (t) {
        return t === "position" || t === "model:position"
      }
      function Ak(t, e) {
        const n = e.getChild(e.offsetToIndex(t.offset))
        if (n && n.is("$text") && n.startOffset < t.offset) {
          return n
        }
        return null
      }
      function Ck(t, e, n) {
        if (n !== null) {
          return null
        }
        return e.getChild(e.offsetToIndex(t.offset))
      }
      function yk(t, e, n) {
        if (n !== null) {
          return null
        }
        return e.getChild(e.offsetToIndex(t.offset) - 1)
      }
      function xk(t, e, n) {
        if (n + 1 === t.path.length) {
          return false
        }
        if (!Ek(e.path, n + 1)) {
          return false
        }
        if (!Dk(t, n + 1)) {
          return false
        }
        return true
      }
      function Ek(t, e) {
        while (e < t.length) {
          if (t[e] !== 0) {
            return false
          }
          e++
        }
        return true
      }
      function Dk(t, e) {
        let n = t.parent
        let o = t.path.length - 1
        let r = 0
        while (o >= e) {
          if (t.path[o] + r !== n.maxOffset) {
            return false
          }
          r = 1
          o--
          n = n.parent
        }
        return true
      }
      class Sk extends uk {
        constructor(t, e) {
          super()
          this.start = vk._createAt(t)
          this.end = e ? vk._createAt(e) : vk._createAt(t)
          this.start.stickiness = this.isCollapsed ? "toNone" : "toNext"
          this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious"
        }
        *[Symbol.iterator]() {
          yield* new wk({ boundaries: this, ignoreElementEnd: true })
        }
        get isCollapsed() {
          return this.start.isEqual(this.end)
        }
        get isFlat() {
          const t = this.start.getParentPath()
          const e = this.end.getParentPath()
          return Ct(t, e) == "same"
        }
        get root() {
          return this.start.root
        }
        containsPosition(t) {
          return t.isAfter(this.start) && t.isBefore(this.end)
        }
        containsRange(t, e = false) {
          if (t.isCollapsed) {
            e = false
          }
          const n = this.containsPosition(t.start) || (e && this.start.isEqual(t.start))
          const o = this.containsPosition(t.end) || (e && this.end.isEqual(t.end))
          return n && o
        }
        containsItem(t) {
          const e = vk._createBefore(t)
          return this.containsPosition(e) || this.start.isEqual(e)
        }
        isEqual(t) {
          return this.start.isEqual(t.start) && this.end.isEqual(t.end)
        }
        isIntersecting(t) {
          return this.start.isBefore(t.end) && this.end.isAfter(t.start)
        }
        getDifference(t) {
          const e = []
          if (this.isIntersecting(t)) {
            if (this.containsPosition(t.start)) {
              e.push(new Sk(this.start, t.start))
            }
            if (this.containsPosition(t.end)) {
              e.push(new Sk(t.end, this.end))
            }
          } else {
            e.push(new Sk(this.start, this.end))
          }
          return e
        }
        getIntersection(t) {
          if (this.isIntersecting(t)) {
            let e = this.start
            let n = this.end
            if (this.containsPosition(t.start)) {
              e = t.start
            }
            if (this.containsPosition(t.end)) {
              n = t.end
            }
            return new Sk(e, n)
          }
          return null
        }
        getJoined(t, e = false) {
          let n = this.isIntersecting(t)
          if (!n) {
            if (this.start.isBefore(t.start)) {
              n = e ? this.end.isTouching(t.start) : this.end.isEqual(t.start)
            } else {
              n = e ? t.end.isTouching(this.start) : t.end.isEqual(this.start)
            }
          }
          if (!n) {
            return null
          }
          let o = this.start
          let r = this.end
          if (t.start.isBefore(o)) {
            o = t.start
          }
          if (t.end.isAfter(r)) {
            r = t.end
          }
          return new Sk(o, r)
        }
        getMinimalFlatRanges() {
          const t = []
          const e = this.start.getCommonPath(this.end).length
          const n = vk._createAt(this.start)
          let o = n.parent
          while (n.path.length > e + 1) {
            const e = o.maxOffset - n.offset
            if (e !== 0) {
              t.push(new Sk(n, n.getShiftedBy(e)))
            }
            n.path = n.path.slice(0, -1)
            n.offset++
            o = o.parent
          }
          while (n.path.length <= this.end.path.length) {
            const e = this.end.path[n.path.length - 1]
            const o = e - n.offset
            if (o !== 0) {
              t.push(new Sk(n, n.getShiftedBy(o)))
            }
            n.offset = e
            n.path.push(0)
          }
          return t
        }
        getWalker(t = {}) {
          t.boundaries = this
          return new wk(t)
        }
        *getItems(t = {}) {
          t.boundaries = this
          t.ignoreElementEnd = true
          const e = new wk(t)
          for (const t of e) {
            yield t.item
          }
        }
        *getPositions(t = {}) {
          t.boundaries = this
          const e = new wk(t)
          yield e.position
          for (const t of e) {
            yield t.nextPosition
          }
        }
        getTransformedByOperation(t) {
          switch (t.type) {
            case "insert":
              return this._getTransformedByInsertOperation(t)
            case "move":
            case "remove":
            case "reinsert":
              return this._getTransformedByMoveOperation(t)
            case "split":
              return [this._getTransformedBySplitOperation(t)]
            case "merge":
              return [this._getTransformedByMergeOperation(t)]
          }
          return [new Sk(this.start, this.end)]
        }
        getTransformedByOperations(t) {
          const e = [new Sk(this.start, this.end)]
          for (const n of t) {
            for (let t = 0; t < e.length; t++) {
              const o = e[t].getTransformedByOperation(n)
              e.splice(t, 1, ...o)
              t += o.length - 1
            }
          }
          for (let t = 0; t < e.length; t++) {
            const n = e[t]
            for (let o = t + 1; o < e.length; o++) {
              const t = e[o]
              if (n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) {
                e.splice(o, 1)
              }
            }
          }
          return e
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end)
        }
        getContainedElement() {
          if (this.isCollapsed) {
            return null
          }
          const t = this.start.nodeAfter
          const e = this.end.nodeBefore
          if (t && t.is("element") && t === e) {
            return t
          }
          return null
        }
        toJSON() {
          return { start: this.start.toJSON(), end: this.end.toJSON() }
        }
        clone() {
          return new this.constructor(this.start, this.end)
        }
        _getTransformedByInsertOperation(t, e = false) {
          return this._getTransformedByInsertion(t.position, t.howMany, e)
        }
        _getTransformedByMoveOperation(t, e = false) {
          const n = t.sourcePosition
          const o = t.howMany
          const r = t.targetPosition
          return this._getTransformedByMove(n, r, o, e)
        }
        _getTransformedBySplitOperation(t) {
          const e = this.start._getTransformedBySplitOperation(t)
          let n = this.end._getTransformedBySplitOperation(t)
          if (this.end.isEqual(t.insertionPosition)) {
            n = this.end.getShiftedBy(1)
          }
          if (e.root != n.root) {
            n = this.end.getShiftedBy(-1)
          }
          return new Sk(e, n)
        }
        _getTransformedByMergeOperation(t) {
          if (this.start.isEqual(t.targetPosition) && this.end.isEqual(t.deletionPosition)) {
            return new Sk(this.start)
          }
          let e = this.start._getTransformedByMergeOperation(t)
          let n = this.end._getTransformedByMergeOperation(t)
          if (e.root != n.root) {
            n = this.end.getShiftedBy(-1)
          }
          if (e.isAfter(n)) {
            if (t.sourcePosition.isBefore(t.targetPosition)) {
              e = vk._createAt(n)
              e.offset = 0
            } else {
              if (!t.deletionPosition.isEqual(e)) {
                n = t.deletionPosition
              }
              e = t.targetPosition
            }
            return new Sk(e, n)
          }
          return new Sk(e, n)
        }
        _getTransformedByInsertion(t, e, n = false) {
          if (n && this.containsPosition(t)) {
            return [
              new Sk(this.start, t),
              new Sk(t.getShiftedBy(e), this.end._getTransformedByInsertion(t, e)),
            ]
          } else {
            const n = new Sk(this.start, this.end)
            n.start = n.start._getTransformedByInsertion(t, e)
            n.end = n.end._getTransformedByInsertion(t, e)
            return [n]
          }
        }
        _getTransformedByMove(t, e, n, o = false) {
          if (this.isCollapsed) {
            const o = this.start._getTransformedByMove(t, e, n)
            return [new Sk(o)]
          }
          const r = Sk._createFromPositionAndShift(t, n)
          const i = e._getTransformedByDeletion(t, n)
          if (this.containsPosition(e) && !o) {
            if (r.containsPosition(this.start) || r.containsPosition(this.end)) {
              const o = this.start._getTransformedByMove(t, e, n)
              const r = this.end._getTransformedByMove(t, e, n)
              return [new Sk(o, r)]
            }
          }
          let s
          const a = this.getDifference(r)
          let c = null
          const l = this.getIntersection(r)
          if (a.length == 1) {
            c = new Sk(
              a[0].start._getTransformedByDeletion(t, n),
              a[0].end._getTransformedByDeletion(t, n)
            )
          } else if (a.length == 2) {
            c = new Sk(this.start, this.end._getTransformedByDeletion(t, n))
          }
          if (c) {
            s = c._getTransformedByInsertion(i, n, l !== null || o)
          } else {
            s = []
          }
          if (l) {
            const t = new Sk(l.start._getCombined(r.start, i), l.end._getCombined(r.start, i))
            if (s.length == 2) {
              s.splice(1, 0, t)
            } else {
              s.push(t)
            }
          }
          return s
        }
        _getTransformedByDeletion(t, e) {
          let n = this.start._getTransformedByDeletion(t, e)
          let o = this.end._getTransformedByDeletion(t, e)
          if (n == null && o == null) {
            return null
          }
          if (n == null) {
            n = t
          }
          if (o == null) {
            o = t
          }
          return new Sk(n, o)
        }
        static _createFromPositionAndShift(t, e) {
          const n = t
          const o = t.getShiftedBy(e)
          return e > 0 ? new this(n, o) : new this(o, n)
        }
        static _createIn(t) {
          return new this(vk._createAt(t, 0), vk._createAt(t, t.maxOffset))
        }
        static _createOn(t) {
          return this._createFromPositionAndShift(vk._createBefore(t), t.offsetSize)
        }
        static _createFromRanges(t) {
          if (t.length === 0) {
            throw new P("range-create-from-ranges-empty-array", null)
          } else if (t.length == 1) {
            return t[0].clone()
          }
          const e = t[0]
          t.sort((t, e) => (t.start.isAfter(e.start) ? 1 : -1))
          const n = t.indexOf(e)
          const o = new this(e.start, e.end)
          if (n > 0) {
            for (let e = n - 1; true; e++) {
              if (t[e].end.isEqual(o.start)) {
                o.start = vk._createAt(t[e].start)
              } else {
                break
              }
            }
          }
          for (let e = n + 1; e < t.length; e++) {
            if (t[e].start.isEqual(o.end)) {
              o.end = vk._createAt(t[e].end)
            } else {
              break
            }
          }
          return o
        }
        static fromJSON(t, e) {
          return new this(vk.fromJSON(t.start, e), vk.fromJSON(t.end, e))
        }
      }
      Sk.prototype.is = function (t) {
        return t === "range" || t === "model:range"
      }
      class Tk extends q() {
        constructor() {
          super()
          this._modelToViewMapping = new WeakMap()
          this._viewToModelMapping = new WeakMap()
          this._viewToModelLengthCallbacks = new Map()
          this._markerNameToElements = new Map()
          this._elementToMarkerNames = new Map()
          this._deferredBindingRemovals = new Map()
          this._unboundMarkerNames = new Set()
          this.on(
            "modelToViewPosition",
            (t, e) => {
              if (e.viewPosition) {
                return
              }
              const n = this._modelToViewMapping.get(e.modelPosition.parent)
              if (!n) {
                throw new P("mapping-model-position-view-parent-not-found", this, {
                  modelPosition: e.modelPosition,
                })
              }
              e.viewPosition = this.findPositionIn(n, e.modelPosition.offset)
            },
            { priority: "low" }
          )
          this.on(
            "viewToModelPosition",
            (t, e) => {
              if (e.modelPosition) {
                return
              }
              const n = this.findMappedViewAncestor(e.viewPosition)
              const o = this._viewToModelMapping.get(n)
              const r = this._toModelOffset(e.viewPosition.parent, e.viewPosition.offset, n)
              e.modelPosition = vk._createAt(o, r)
            },
            { priority: "low" }
          )
        }
        bindElements(t, e) {
          this._modelToViewMapping.set(t, e)
          this._viewToModelMapping.set(e, t)
        }
        unbindViewElement(t, e = {}) {
          const n = this.toModelElement(t)
          if (this._elementToMarkerNames.has(t)) {
            for (const e of this._elementToMarkerNames.get(t)) {
              this._unboundMarkerNames.add(e)
            }
          }
          if (e.defer) {
            this._deferredBindingRemovals.set(t, t.root)
          } else {
            this._viewToModelMapping.delete(t)
            if (this._modelToViewMapping.get(n) == t) {
              this._modelToViewMapping.delete(n)
            }
          }
        }
        unbindModelElement(t) {
          const e = this.toViewElement(t)
          this._modelToViewMapping.delete(t)
          if (this._viewToModelMapping.get(e) == t) {
            this._viewToModelMapping.delete(e)
          }
        }
        bindElementToMarker(t, e) {
          const n = this._markerNameToElements.get(e) || new Set()
          n.add(t)
          const o = this._elementToMarkerNames.get(t) || new Set()
          o.add(e)
          this._markerNameToElements.set(e, n)
          this._elementToMarkerNames.set(t, o)
        }
        unbindElementFromMarkerName(t, e) {
          const n = this._markerNameToElements.get(e)
          if (n) {
            n.delete(t)
            if (n.size == 0) {
              this._markerNameToElements.delete(e)
            }
          }
          const o = this._elementToMarkerNames.get(t)
          if (o) {
            o.delete(e)
            if (o.size == 0) {
              this._elementToMarkerNames.delete(t)
            }
          }
        }
        flushUnboundMarkerNames() {
          const t = Array.from(this._unboundMarkerNames)
          this._unboundMarkerNames.clear()
          return t
        }
        flushDeferredBindings() {
          for (const [t, e] of this._deferredBindingRemovals) {
            if (t.root == e) {
              this.unbindViewElement(t)
            }
          }
          this._deferredBindingRemovals = new Map()
        }
        clearBindings() {
          this._modelToViewMapping = new WeakMap()
          this._viewToModelMapping = new WeakMap()
          this._markerNameToElements = new Map()
          this._elementToMarkerNames = new Map()
          this._unboundMarkerNames = new Set()
          this._deferredBindingRemovals = new Map()
        }
        toModelElement(t) {
          return this._viewToModelMapping.get(t)
        }
        toViewElement(t) {
          return this._modelToViewMapping.get(t)
        }
        toModelRange(t) {
          return new Sk(this.toModelPosition(t.start), this.toModelPosition(t.end))
        }
        toViewRange(t) {
          return new ip(this.toViewPosition(t.start), this.toViewPosition(t.end))
        }
        toModelPosition(t) {
          const e = { viewPosition: t, mapper: this }
          this.fire("viewToModelPosition", e)
          return e.modelPosition
        }
        toViewPosition(t, e = {}) {
          const n = { modelPosition: t, mapper: this, isPhantom: e.isPhantom }
          this.fire("modelToViewPosition", n)
          return n.viewPosition
        }
        markerNameToElements(t) {
          const e = this._markerNameToElements.get(t)
          if (!e) {
            return null
          }
          const n = new Set()
          for (const t of e) {
            if (t.is("attributeElement")) {
              for (const e of t.getElementsWithSameId()) {
                n.add(e)
              }
            } else {
              n.add(t)
            }
          }
          return n
        }
        registerViewToModelLength(t, e) {
          this._viewToModelLengthCallbacks.set(t, e)
        }
        findMappedViewAncestor(t) {
          let e = t.parent
          while (!this._viewToModelMapping.has(e)) {
            e = e.parent
          }
          return e
        }
        _toModelOffset(t, e, n) {
          if (n != t) {
            const o = this._toModelOffset(t.parent, t.index, n)
            const r = this._toModelOffset(t, e, t)
            return o + r
          }
          if (t.is("$text")) {
            return e
          }
          let o = 0
          for (let n = 0; n < e; n++) {
            o += this.getModelLength(t.getChild(n))
          }
          return o
        }
        getModelLength(t) {
          if (this._viewToModelLengthCallbacks.get(t.name)) {
            const e = this._viewToModelLengthCallbacks.get(t.name)
            return e(t)
          } else if (this._viewToModelMapping.has(t)) {
            return 1
          } else if (t.is("$text")) {
            return t.data.length
          } else if (t.is("uiElement")) {
            return 0
          } else {
            let e = 0
            for (const n of t.getChildren()) {
              e += this.getModelLength(n)
            }
            return e
          }
        }
        findPositionIn(t, e) {
          let n
          let o = 0
          let r = 0
          let i = 0
          if (t.is("$text")) {
            return new rp(t, e)
          }
          while (r < e) {
            n = t.getChild(i)
            o = this.getModelLength(n)
            r += o
            i++
          }
          if (r == e) {
            return this._moveViewPositionToTextNode(new rp(t, i))
          } else {
            return this.findPositionIn(n, e - (r - o))
          }
        }
        _moveViewPositionToTextNode(t) {
          const e = t.nodeBefore
          const n = t.nodeAfter
          if (e instanceof Gh) {
            return new rp(e, e.data.length)
          } else if (n instanceof Gh) {
            return new rp(n, 0)
          }
          return t
        }
      }
      class Pk {
        constructor() {
          this._consumable = new Map()
          this._textProxyRegistry = new Map()
        }
        add(t, e) {
          e = Bk(e)
          if (t instanceof mk) {
            t = this._getSymbolForTextProxy(t)
          }
          if (!this._consumable.has(t)) {
            this._consumable.set(t, new Map())
          }
          this._consumable.get(t).set(e, true)
        }
        consume(t, e) {
          e = Bk(e)
          if (t instanceof mk) {
            t = this._getSymbolForTextProxy(t)
          }
          if (this.test(t, e)) {
            this._consumable.get(t).set(e, false)
            return true
          } else {
            return false
          }
        }
        test(t, e) {
          e = Bk(e)
          if (t instanceof mk) {
            t = this._getSymbolForTextProxy(t)
          }
          const n = this._consumable.get(t)
          if (n === undefined) {
            return null
          }
          const o = n.get(e)
          if (o === undefined) {
            return null
          }
          return o
        }
        revert(t, e) {
          e = Bk(e)
          if (t instanceof mk) {
            t = this._getSymbolForTextProxy(t)
          }
          const n = this.test(t, e)
          if (n === false) {
            this._consumable.get(t).set(e, true)
            return true
          } else if (n === true) {
            return false
          }
          return null
        }
        verifyAllConsumed(t) {
          const e = []
          for (const [n, o] of this._consumable) {
            for (const [r, i] of o) {
              const o = r.split(":")[0]
              if (i && t == o) {
                e.push({ event: r, item: n.name || n.description })
              }
            }
          }
          if (e.length) {
            throw new P("conversion-model-consumable-not-consumed", null, { items: e })
          }
        }
        _getSymbolForTextProxy(t) {
          let e = null
          const n = this._textProxyRegistry.get(t.startOffset)
          if (n) {
            const o = n.get(t.endOffset)
            if (o) {
              e = o.get(t.parent)
            }
          }
          if (!e) {
            e = this._addSymbolForTextProxy(t)
          }
          return e
        }
        _addSymbolForTextProxy(t) {
          const e = t.startOffset
          const n = t.endOffset
          const o = t.parent
          const r = Symbol("$textProxy:" + t.data)
          let i
          let s
          i = this._textProxyRegistry.get(e)
          if (!i) {
            i = new Map()
            this._textProxyRegistry.set(e, i)
          }
          s = i.get(n)
          if (!s) {
            s = new Map()
            i.set(n, s)
          }
          s.set(o, r)
          return r
        }
      }
      function Bk(t) {
        const e = t.split(":")
        if (e[0] == "insert") {
          return e[0]
        }
        if (e[0] == "addMarker" || e[0] == "removeMarker") {
          return t
        }
        return e.length > 1 ? e[0] + ":" + e[1] : e[0]
      }
      class Rk extends q() {
        constructor(t) {
          super()
          this._conversionApi = { dispatcher: this, ...t }
          this._firedEventsMap = new WeakMap()
        }
        convertChanges(t, e, n) {
          const o = this._createConversionApi(n, t.getRefreshedItems())
          for (const e of t.getMarkersToRemove()) {
            this._convertMarkerRemove(e.name, e.range, o)
          }
          const r = this._reduceChanges(t.getChanges())
          for (const t of r) {
            if (t.type === "insert") {
              this._convertInsert(Sk._createFromPositionAndShift(t.position, t.length), o)
            } else if (t.type === "reinsert") {
              this._convertReinsert(Sk._createFromPositionAndShift(t.position, t.length), o)
            } else if (t.type === "remove") {
              this._convertRemove(t.position, t.length, t.name, o)
            } else {
              this._convertAttribute(
                t.range,
                t.attributeKey,
                t.attributeOldValue,
                t.attributeNewValue,
                o
              )
            }
          }
          for (const t of o.mapper.flushUnboundMarkerNames()) {
            const n = e.get(t).getRange()
            this._convertMarkerRemove(t, n, o)
            this._convertMarkerAdd(t, n, o)
          }
          for (const e of t.getMarkersToAdd()) {
            this._convertMarkerAdd(e.name, e.range, o)
          }
          o.mapper.flushDeferredBindings()
          o.consumable.verifyAllConsumed("insert")
        }
        convert(t, e, n, o = {}) {
          const r = this._createConversionApi(n, undefined, o)
          this._convertInsert(t, r)
          for (const [t, n] of e) {
            this._convertMarkerAdd(t, n, r)
          }
          r.consumable.verifyAllConsumed("insert")
        }
        convertSelection(t, e, n) {
          const o = Array.from(e.getMarkersAtPosition(t.getFirstPosition()))
          const r = this._createConversionApi(n)
          this._addConsumablesForSelection(r.consumable, t, o)
          this.fire("selection", { selection: t }, r)
          if (!t.isCollapsed) {
            return
          }
          for (const e of o) {
            const n = e.getRange()
            if (!Ok(t.getFirstPosition(), e, r.mapper)) {
              continue
            }
            const o = { item: t, markerName: e.name, markerRange: n }
            if (r.consumable.test(t, "addMarker:" + e.name)) {
              this.fire(`addMarker:${e.name}`, o, r)
            }
          }
          for (const e of t.getAttributeKeys()) {
            const n = {
              item: t,
              range: t.getFirstRange(),
              attributeKey: e,
              attributeOldValue: null,
              attributeNewValue: t.getAttribute(e),
            }
            if (r.consumable.test(t, "attribute:" + n.attributeKey)) {
              this.fire(`attribute:${n.attributeKey}:$text`, n, r)
            }
          }
        }
        _convertInsert(t, e, n = {}) {
          if (!n.doNotAddConsumables) {
            this._addConsumablesForInsert(e.consumable, Array.from(t))
          }
          for (const n of Array.from(t.getWalker({ shallow: true })).map(Ik)) {
            this._testAndFire("insert", n, e)
          }
        }
        _convertRemove(t, e, n, o) {
          this.fire(`remove:${n}`, { position: t, length: e }, o)
        }
        _convertAttribute(t, e, n, o, r) {
          this._addConsumablesForRange(r.consumable, t, `attribute:${e}`)
          for (const i of t) {
            const t = {
              item: i.item,
              range: Sk._createFromPositionAndShift(i.previousPosition, i.length),
              attributeKey: e,
              attributeOldValue: n,
              attributeNewValue: o,
            }
            this._testAndFire(`attribute:${e}`, t, r)
          }
        }
        _convertReinsert(t, e) {
          const n = Array.from(t.getWalker({ shallow: true }))
          this._addConsumablesForInsert(e.consumable, n)
          for (const t of n.map(Ik)) {
            this._testAndFire("insert", { ...t, reconversion: true }, e)
          }
        }
        _convertMarkerAdd(t, e, n) {
          if (e.root.rootName == "$graveyard") {
            return
          }
          const o = `addMarker:${t}`
          n.consumable.add(e, o)
          this.fire(o, { markerName: t, markerRange: e }, n)
          if (!n.consumable.consume(e, o)) {
            return
          }
          this._addConsumablesForRange(n.consumable, e, o)
          for (const r of e.getItems()) {
            if (!n.consumable.test(r, o)) {
              continue
            }
            const i = { item: r, range: Sk._createOn(r), markerName: t, markerRange: e }
            this.fire(o, i, n)
          }
        }
        _convertMarkerRemove(t, e, n) {
          if (e.root.rootName == "$graveyard") {
            return
          }
          this.fire(`removeMarker:${t}`, { markerName: t, markerRange: e }, n)
        }
        _reduceChanges(t) {
          const e = { changes: t }
          this.fire("reduceChanges", e)
          return e.changes
        }
        _addConsumablesForInsert(t, e) {
          for (const n of e) {
            const e = n.item
            if (t.test(e, "insert") === null) {
              t.add(e, "insert")
              for (const n of e.getAttributeKeys()) {
                t.add(e, "attribute:" + n)
              }
            }
          }
          return t
        }
        _addConsumablesForRange(t, e, n) {
          for (const o of e.getItems()) {
            t.add(o, n)
          }
          return t
        }
        _addConsumablesForSelection(t, e, n) {
          t.add(e, "selection")
          for (const o of n) {
            t.add(e, "addMarker:" + o.name)
          }
          for (const n of e.getAttributeKeys()) {
            t.add(e, "attribute:" + n)
          }
          return t
        }
        _testAndFire(t, e, n) {
          const o = Mk(t, e)
          const r = e.item.is("$textProxy") ? n.consumable._getSymbolForTextProxy(e.item) : e.item
          const i = this._firedEventsMap.get(n)
          const s = i.get(r)
          if (!s) {
            i.set(r, new Set([o]))
          } else if (!s.has(o)) {
            s.add(o)
          } else {
            return
          }
          this.fire(o, e, n)
        }
        _testAndFireAddAttributes(t, e) {
          const n = { item: t, range: Sk._createOn(t) }
          for (const t of n.item.getAttributeKeys()) {
            n.attributeKey = t
            n.attributeOldValue = null
            n.attributeNewValue = n.item.getAttribute(t)
            this._testAndFire(`attribute:${t}`, n, e)
          }
        }
        _createConversionApi(t, e = new Set(), n = {}) {
          const o = {
            ...this._conversionApi,
            consumable: new Pk(),
            writer: t,
            options: n,
            convertItem: (t) => this._convertInsert(Sk._createOn(t), o),
            convertChildren: (t) =>
              this._convertInsert(Sk._createIn(t), o, { doNotAddConsumables: true }),
            convertAttributes: (t) => this._testAndFireAddAttributes(t, o),
            canReuseView: (t) => !e.has(o.mapper.toModelElement(t)),
          }
          this._firedEventsMap.set(o, new Map())
          return o
        }
      }
      function Ok(t, e, n) {
        const o = e.getRange()
        const r = Array.from(t.getAncestors())
        r.shift()
        r.reverse()
        const i = r.some((t) => {
          if (o.containsItem(t)) {
            const e = n.toViewElement(t)
            return !!e.getCustomProperty("addHighlight")
          }
        })
        return !i
      }
      function Mk(t, e) {
        const n = e.item.is("element") ? e.item.name : "$text"
        return `${t}:${n}`
      }
      function Ik(t) {
        const e = t.item
        const n = Sk._createFromPositionAndShift(t.previousPosition, t.length)
        return { item: e, range: n }
      }
      class zk extends q(uk) {
        constructor(...t) {
          super()
          this._lastRangeBackward = false
          this._attrs = new Map()
          this._ranges = []
          if (t.length) {
            this.setTo(...t)
          }
        }
        get anchor() {
          if (this._ranges.length > 0) {
            const t = this._ranges[this._ranges.length - 1]
            return this._lastRangeBackward ? t.end : t.start
          }
          return null
        }
        get focus() {
          if (this._ranges.length > 0) {
            const t = this._ranges[this._ranges.length - 1]
            return this._lastRangeBackward ? t.start : t.end
          }
          return null
        }
        get isCollapsed() {
          const t = this._ranges.length
          if (t === 1) {
            return this._ranges[0].isCollapsed
          } else {
            return false
          }
        }
        get rangeCount() {
          return this._ranges.length
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward
        }
        isEqual(t) {
          if (this.rangeCount != t.rangeCount) {
            return false
          } else if (this.rangeCount === 0) {
            return true
          }
          if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
            return false
          }
          for (const e of this._ranges) {
            let n = false
            for (const o of t._ranges) {
              if (e.isEqual(o)) {
                n = true
                break
              }
            }
            if (!n) {
              return false
            }
          }
          return true
        }
        *getRanges() {
          for (const t of this._ranges) {
            yield new Sk(t.start, t.end)
          }
        }
        getFirstRange() {
          let t = null
          for (const e of this._ranges) {
            if (!t || e.start.isBefore(t.start)) {
              t = e
            }
          }
          return t ? new Sk(t.start, t.end) : null
        }
        getLastRange() {
          let t = null
          for (const e of this._ranges) {
            if (!t || e.end.isAfter(t.end)) {
              t = e
            }
          }
          return t ? new Sk(t.start, t.end) : null
        }
        getFirstPosition() {
          const t = this.getFirstRange()
          return t ? t.start.clone() : null
        }
        getLastPosition() {
          const t = this.getLastRange()
          return t ? t.end.clone() : null
        }
        setTo(...t) {
          let [e, n, o] = t
          if (typeof n == "object") {
            o = n
            n = undefined
          }
          if (e === null) {
            this._setRanges([])
          } else if (e instanceof zk) {
            this._setRanges(e.getRanges(), e.isBackward)
          } else if (e && typeof e.getRanges == "function") {
            this._setRanges(e.getRanges(), e.isBackward)
          } else if (e instanceof Sk) {
            this._setRanges([e], !!o && !!o.backward)
          } else if (e instanceof vk) {
            this._setRanges([new Sk(e)])
          } else if (e instanceof fk) {
            const t = !!o && !!o.backward
            let r
            if (n == "in") {
              r = Sk._createIn(e)
            } else if (n == "on") {
              r = Sk._createOn(e)
            } else if (n !== undefined) {
              r = new Sk(vk._createAt(e, n))
            } else {
              throw new P("model-selection-setto-required-second-parameter", [this, e])
            }
            this._setRanges([r], t)
          } else if (yt(e)) {
            this._setRanges(e, o && !!o.backward)
          } else {
            throw new P("model-selection-setto-not-selectable", [this, e])
          }
        }
        _setRanges(t, e = false) {
          const n = Array.from(t)
          const o = n.some((e) => {
            if (!(e instanceof Sk)) {
              throw new P("model-selection-set-ranges-not-range", [this, t])
            }
            return this._ranges.every((t) => !t.isEqual(e))
          })
          if (n.length === this._ranges.length && !o) {
            return
          }
          this._replaceAllRanges(n)
          this._lastRangeBackward = !!e
          this.fire("change:range", { directChange: true })
        }
        setFocus(t, e) {
          if (this.anchor === null) {
            throw new P("model-selection-setfocus-no-ranges", [this, t])
          }
          const n = vk._createAt(t, e)
          if (n.compareWith(this.focus) == "same") {
            return
          }
          const o = this.anchor
          if (this._ranges.length) {
            this._popRange()
          }
          if (n.compareWith(o) == "before") {
            this._pushRange(new Sk(n, o))
            this._lastRangeBackward = true
          } else {
            this._pushRange(new Sk(o, n))
            this._lastRangeBackward = false
          }
          this.fire("change:range", { directChange: true })
        }
        getAttribute(t) {
          return this._attrs.get(t)
        }
        getAttributes() {
          return this._attrs.entries()
        }
        getAttributeKeys() {
          return this._attrs.keys()
        }
        hasAttribute(t) {
          return this._attrs.has(t)
        }
        removeAttribute(t) {
          if (this.hasAttribute(t)) {
            this._attrs.delete(t)
            this.fire("change:attribute", { attributeKeys: [t], directChange: true })
          }
        }
        setAttribute(t, e) {
          if (this.getAttribute(t) !== e) {
            this._attrs.set(t, e)
            this.fire("change:attribute", { attributeKeys: [t], directChange: true })
          }
        }
        getSelectedElement() {
          if (this.rangeCount !== 1) {
            return null
          }
          return this.getFirstRange().getContainedElement()
        }
        *getSelectedBlocks() {
          const t = new WeakSet()
          for (const e of this.getRanges()) {
            const n = Vk(e.start, t)
            if (jk(n, e)) {
              yield n
            }
            for (const n of e.getWalker()) {
              const o = n.item
              if (n.type == "elementEnd" && Fk(o, t, e)) {
                yield o
              }
            }
            const o = Vk(e.end, t)
            if (Hk(o, e)) {
              yield o
            }
          }
        }
        containsEntireContent(t = this.anchor.root) {
          const e = vk._createAt(t, 0)
          const n = vk._createAt(t, "end")
          return e.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition())
        }
        _pushRange(t) {
          this._checkRange(t)
          this._ranges.push(new Sk(t.start, t.end))
        }
        _checkRange(t) {
          for (let e = 0; e < this._ranges.length; e++) {
            if (t.isIntersecting(this._ranges[e])) {
              throw new P("model-selection-range-intersects", [this, t], {
                addedRange: t,
                intersectingRange: this._ranges[e],
              })
            }
          }
        }
        _replaceAllRanges(t) {
          this._removeAllRanges()
          for (const e of t) {
            this._pushRange(e)
          }
        }
        _removeAllRanges() {
          while (this._ranges.length > 0) {
            this._popRange()
          }
        }
        _popRange() {
          this._ranges.pop()
        }
      }
      zk.prototype.is = function (t) {
        return t === "selection" || t === "model:selection"
      }
      function Nk(t, e) {
        if (e.has(t)) {
          return false
        }
        e.add(t)
        return t.root.document.model.schema.isBlock(t) && !!t.parent
      }
      function Fk(t, e, n) {
        return Nk(t, e) && Lk(t, n)
      }
      function Vk(t, e) {
        const n = t.parent
        const o = n.root.document.model.schema
        const r = t.parent.getAncestors({ parentFirst: true, includeSelf: true })
        let i = false
        const s = r.find((t) => {
          if (i) {
            return false
          }
          i = o.isLimit(t)
          return !i && Nk(t, e)
        })
        r.forEach((t) => e.add(t))
        return s
      }
      function Lk(t, e) {
        const n = Wk(t)
        if (!n) {
          return true
        }
        const o = e.containsRange(Sk._createOn(n), true)
        return !o
      }
      function jk(t, e) {
        if (!t) {
          return false
        }
        if (e.isCollapsed || t.isEmpty) {
          return true
        }
        if (e.start.isTouching(vk._createAt(t, t.maxOffset))) {
          return false
        }
        return Lk(t, e)
      }
      function Hk(t, e) {
        if (!t) {
          return false
        }
        if (e.isCollapsed || t.isEmpty) {
          return true
        }
        if (e.end.isTouching(vk._createAt(t, 0))) {
          return false
        }
        return Lk(t, e)
      }
      function Wk(t) {
        const e = t.root.document.model.schema
        let n = t.parent
        while (n) {
          if (e.isBlock(n)) {
            return n
          }
          n = n.parent
        }
      }
      class qk extends q(Sk) {
        constructor(t, e) {
          super(t, e)
          $k.call(this)
        }
        detach() {
          this.stopListening()
        }
        toRange() {
          return new Sk(this.start, this.end)
        }
        static fromRange(t) {
          return new qk(t.start, t.end)
        }
      }
      qk.prototype.is = function (t) {
        return t === "liveRange" || t === "model:liveRange" || t == "range" || t === "model:range"
      }
      function $k() {
        this.listenTo(
          this.root.document.model,
          "applyOperation",
          (t, e) => {
            const n = e[0]
            if (!n.isDocumentOperation) {
              return
            }
            Kk.call(this, n)
          },
          { priority: "low" }
        )
      }
      function Kk(t) {
        const e = this.getTransformedByOperation(t)
        const n = Sk._createFromRanges(e)
        const o = !n.isEqual(this)
        const r = Gk(this, t)
        let i = null
        if (o) {
          if (n.root.rootName == "$graveyard") {
            if (t.type == "remove") {
              i = t.sourcePosition
            } else {
              i = t.deletionPosition
            }
          }
          const e = this.toRange()
          this.start = n.start
          this.end = n.end
          this.fire("change:range", e, { deletionPosition: i })
        } else if (r) {
          this.fire("change:content", this.toRange(), { deletionPosition: i })
        }
      }
      function Gk(t, e) {
        switch (e.type) {
          case "insert":
            return t.containsPosition(e.position)
          case "move":
          case "remove":
          case "reinsert":
          case "merge":
            return (
              t.containsPosition(e.sourcePosition) ||
              t.start.isEqual(e.sourcePosition) ||
              t.containsPosition(e.targetPosition)
            )
          case "split":
            return t.containsPosition(e.splitPosition) || t.containsPosition(e.insertionPosition)
        }
        return false
      }
      const Uk = "selection:"
      class Jk extends q(uk) {
        constructor(t) {
          super()
          this._selection = new Zk(t)
          this._selection.delegate("change:range").to(this)
          this._selection.delegate("change:attribute").to(this)
          this._selection.delegate("change:marker").to(this)
        }
        get isCollapsed() {
          return this._selection.isCollapsed
        }
        get anchor() {
          return this._selection.anchor
        }
        get focus() {
          return this._selection.focus
        }
        get rangeCount() {
          return this._selection.rangeCount
        }
        get hasOwnRange() {
          return this._selection.hasOwnRange
        }
        get isBackward() {
          return this._selection.isBackward
        }
        get isGravityOverridden() {
          return this._selection.isGravityOverridden
        }
        get markers() {
          return this._selection.markers
        }
        get _ranges() {
          return this._selection._ranges
        }
        getRanges() {
          return this._selection.getRanges()
        }
        getFirstPosition() {
          return this._selection.getFirstPosition()
        }
        getLastPosition() {
          return this._selection.getLastPosition()
        }
        getFirstRange() {
          return this._selection.getFirstRange()
        }
        getLastRange() {
          return this._selection.getLastRange()
        }
        getSelectedBlocks() {
          return this._selection.getSelectedBlocks()
        }
        getSelectedElement() {
          return this._selection.getSelectedElement()
        }
        containsEntireContent(t) {
          return this._selection.containsEntireContent(t)
        }
        destroy() {
          this._selection.destroy()
        }
        getAttributeKeys() {
          return this._selection.getAttributeKeys()
        }
        getAttributes() {
          return this._selection.getAttributes()
        }
        getAttribute(t) {
          return this._selection.getAttribute(t)
        }
        hasAttribute(t) {
          return this._selection.hasAttribute(t)
        }
        refresh() {
          this._selection.updateMarkers()
          this._selection._updateAttributes(false)
        }
        observeMarkers(t) {
          this._selection.observeMarkers(t)
        }
        _setFocus(t, e) {
          this._selection.setFocus(t, e)
        }
        _setTo(...t) {
          this._selection.setTo(...t)
        }
        _setAttribute(t, e) {
          this._selection.setAttribute(t, e)
        }
        _removeAttribute(t) {
          this._selection.removeAttribute(t)
        }
        _getStoredAttributes() {
          return this._selection.getStoredAttributes()
        }
        _overrideGravity() {
          return this._selection.overrideGravity()
        }
        _restoreGravity(t) {
          this._selection.restoreGravity(t)
        }
        static _getStoreAttributeKey(t) {
          return Uk + t
        }
        static _isStoreAttributeKey(t) {
          return t.startsWith(Uk)
        }
      }
      Jk.prototype.is = function (t) {
        return (
          t === "selection" ||
          t == "model:selection" ||
          t == "documentSelection" ||
          t == "model:documentSelection"
        )
      }
      class Zk extends zk {
        constructor(t) {
          super()
          this.markers = new dl({ idProperty: "name" })
          this._attributePriority = new Map()
          this._selectionRestorePosition = null
          this._hasChangedRange = false
          this._overriddenGravityRegister = new Set()
          this._observedMarkers = new Set()
          this._model = t.model
          this._document = t
          this.listenTo(
            this._model,
            "applyOperation",
            (t, e) => {
              const n = e[0]
              if (
                !n.isDocumentOperation ||
                n.type == "marker" ||
                n.type == "rename" ||
                n.type == "noop"
              ) {
                return
              }
              if (this._ranges.length == 0 && this._selectionRestorePosition) {
                this._fixGraveyardSelection(this._selectionRestorePosition)
              }
              this._selectionRestorePosition = null
              if (this._hasChangedRange) {
                this._hasChangedRange = false
                this.fire("change:range", { directChange: false })
              }
            },
            { priority: "lowest" }
          )
          this.on("change:range", () => {
            this._validateSelectionRanges(this.getRanges())
          })
          this.listenTo(this._model.markers, "update", (t, e, n, o) => {
            this._updateMarker(e, o)
          })
          this.listenTo(this._document, "change", (t, e) => {
            Qk(this._model, e)
          })
        }
        get isCollapsed() {
          const t = this._ranges.length
          return t === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed
        }
        get anchor() {
          return super.anchor || this._document._getDefaultRange().start
        }
        get focus() {
          return super.focus || this._document._getDefaultRange().end
        }
        get rangeCount() {
          return this._ranges.length ? this._ranges.length : 1
        }
        get hasOwnRange() {
          return this._ranges.length > 0
        }
        get isGravityOverridden() {
          return !!this._overriddenGravityRegister.size
        }
        destroy() {
          for (let t = 0; t < this._ranges.length; t++) {
            this._ranges[t].detach()
          }
          this.stopListening()
        }
        *getRanges() {
          if (this._ranges.length) {
            yield* super.getRanges()
          } else {
            yield this._document._getDefaultRange()
          }
        }
        getFirstRange() {
          return super.getFirstRange() || this._document._getDefaultRange()
        }
        getLastRange() {
          return super.getLastRange() || this._document._getDefaultRange()
        }
        setTo(...t) {
          super.setTo(...t)
          this._updateAttributes(true)
          this.updateMarkers()
        }
        setFocus(t, e) {
          super.setFocus(t, e)
          this._updateAttributes(true)
          this.updateMarkers()
        }
        setAttribute(t, e) {
          if (this._setAttribute(t, e)) {
            const e = [t]
            this.fire("change:attribute", { attributeKeys: e, directChange: true })
          }
        }
        removeAttribute(t) {
          if (this._removeAttribute(t)) {
            const e = [t]
            this.fire("change:attribute", { attributeKeys: e, directChange: true })
          }
        }
        overrideGravity() {
          const t = x()
          this._overriddenGravityRegister.add(t)
          if (this._overriddenGravityRegister.size === 1) {
            this._updateAttributes(true)
          }
          return t
        }
        restoreGravity(t) {
          if (!this._overriddenGravityRegister.has(t)) {
            throw new P("document-selection-gravity-wrong-restore", this, { uid: t })
          }
          this._overriddenGravityRegister.delete(t)
          if (!this.isGravityOverridden) {
            this._updateAttributes(true)
          }
        }
        observeMarkers(t) {
          this._observedMarkers.add(t)
          this.updateMarkers()
        }
        _replaceAllRanges(t) {
          this._validateSelectionRanges(t)
          super._replaceAllRanges(t)
        }
        _popRange() {
          this._ranges.pop().detach()
        }
        _pushRange(t) {
          const e = this._prepareRange(t)
          if (e) {
            this._ranges.push(e)
          }
        }
        _validateSelectionRanges(t) {
          for (const e of t) {
            if (!this._document._validateSelectionRange(e)) {
              throw new P("document-selection-wrong-position", this, { range: e })
            }
          }
        }
        _prepareRange(t) {
          this._checkRange(t)
          if (t.root == this._document.graveyard) {
            return
          }
          const e = qk.fromRange(t)
          e.on("change:range", (t, n, o) => {
            this._hasChangedRange = true
            if (e.root == this._document.graveyard) {
              this._selectionRestorePosition = o.deletionPosition
              const t = this._ranges.indexOf(e)
              this._ranges.splice(t, 1)
              e.detach()
            }
          })
          return e
        }
        updateMarkers() {
          if (!this._observedMarkers.size) {
            return
          }
          const t = []
          let e = false
          for (const e of this._model.markers) {
            const n = e.name.split(":", 1)[0]
            if (!this._observedMarkers.has(n)) {
              continue
            }
            const o = e.getRange()
            for (const n of this.getRanges()) {
              if (o.containsRange(n, !n.isCollapsed)) {
                t.push(e)
              }
            }
          }
          const n = Array.from(this.markers)
          for (const n of t) {
            if (!this.markers.has(n)) {
              this.markers.add(n)
              e = true
            }
          }
          for (const n of Array.from(this.markers)) {
            if (!t.includes(n)) {
              this.markers.remove(n)
              e = true
            }
          }
          if (e) {
            this.fire("change:marker", { oldMarkers: n, directChange: false })
          }
        }
        _updateMarker(t, e) {
          const n = t.name.split(":", 1)[0]
          if (!this._observedMarkers.has(n)) {
            return
          }
          let o = false
          const r = Array.from(this.markers)
          const i = this.markers.has(t)
          if (!e) {
            if (i) {
              this.markers.remove(t)
              o = true
            }
          } else {
            let n = false
            for (const t of this.getRanges()) {
              if (e.containsRange(t, !t.isCollapsed)) {
                n = true
                break
              }
            }
            if (n && !i) {
              this.markers.add(t)
              o = true
            } else if (!n && i) {
              this.markers.remove(t)
              o = true
            }
          }
          if (o) {
            this.fire("change:marker", { oldMarkers: r, directChange: false })
          }
        }
        _updateAttributes(t) {
          const e = gl(this._getSurroundingAttributes())
          const n = gl(this.getAttributes())
          if (t) {
            this._attributePriority = new Map()
            this._attrs = new Map()
          } else {
            for (const [t, e] of this._attributePriority) {
              if (e == "low") {
                this._attrs.delete(t)
                this._attributePriority.delete(t)
              }
            }
          }
          this._setAttributesTo(e)
          const o = []
          for (const [t, e] of this.getAttributes()) {
            if (!n.has(t) || n.get(t) !== e) {
              o.push(t)
            }
          }
          for (const [t] of n) {
            if (!this.hasAttribute(t)) {
              o.push(t)
            }
          }
          if (o.length > 0) {
            this.fire("change:attribute", { attributeKeys: o, directChange: false })
          }
        }
        _setAttribute(t, e, n = true) {
          const o = n ? "normal" : "low"
          if (o == "low" && this._attributePriority.get(t) == "normal") {
            return false
          }
          const r = super.getAttribute(t)
          if (r === e) {
            return false
          }
          this._attrs.set(t, e)
          this._attributePriority.set(t, o)
          return true
        }
        _removeAttribute(t, e = true) {
          const n = e ? "normal" : "low"
          if (n == "low" && this._attributePriority.get(t) == "normal") {
            return false
          }
          this._attributePriority.set(t, n)
          if (!super.hasAttribute(t)) {
            return false
          }
          this._attrs.delete(t)
          return true
        }
        _setAttributesTo(t) {
          const e = new Set()
          for (const [e, n] of this.getAttributes()) {
            if (t.get(e) === n) {
              continue
            }
            this._removeAttribute(e, false)
          }
          for (const [n, o] of t) {
            const t = this._setAttribute(n, o, false)
            if (t) {
              e.add(n)
            }
          }
          return e
        }
        *getStoredAttributes() {
          const t = this.getFirstPosition().parent
          if (this.isCollapsed && t.isEmpty) {
            for (const e of t.getAttributeKeys()) {
              if (e.startsWith(Uk)) {
                const n = e.substr(Uk.length)
                yield [n, t.getAttribute(e)]
              }
            }
          }
        }
        _getSurroundingAttributes() {
          const t = this.getFirstPosition()
          const e = this._model.schema
          let n = null
          if (!this.isCollapsed) {
            const t = this.getFirstRange()
            for (const o of t) {
              if (o.item.is("element") && e.isObject(o.item)) {
                break
              }
              if (o.type == "text") {
                n = o.item.getAttributes()
                break
              }
            }
          } else {
            const o = t.textNode ? t.textNode : t.nodeBefore
            const r = t.textNode ? t.textNode : t.nodeAfter
            if (!this.isGravityOverridden) {
              n = Yk(o, e)
            }
            if (!n) {
              n = Yk(r, e)
            }
            if (!this.isGravityOverridden && !n) {
              let t = o
              while (t && !n) {
                t = t.previousSibling
                n = Yk(t, e)
              }
            }
            if (!n) {
              let t = r
              while (t && !n) {
                t = t.nextSibling
                n = Yk(t, e)
              }
            }
            if (!n) {
              n = this.getStoredAttributes()
            }
          }
          return n
        }
        _fixGraveyardSelection(t) {
          const e = this._model.schema.getNearestSelectionRange(t)
          if (e) {
            this._pushRange(e)
          }
        }
      }
      function Yk(t, e) {
        if (!t) {
          return null
        }
        if (t instanceof mk || t instanceof gk) {
          return t.getAttributes()
        }
        if (!e.isInline(t)) {
          return null
        }
        if (!e.isObject(t)) {
          return []
        }
        const n = []
        for (const [o, r] of t.getAttributes()) {
          if (e.checkAttribute("$text", o)) {
            n.push([o, r])
          }
        }
        return n
      }
      function Qk(t, e) {
        const n = t.document.differ
        for (const o of n.getChanges()) {
          if (o.type != "insert") {
            continue
          }
          const n = o.position.parent
          const r = o.length === n.maxOffset
          if (r) {
            t.enqueueChange(e, (t) => {
              const e = Array.from(n.getAttributeKeys()).filter((t) => t.startsWith(Uk))
              for (const o of e) {
                t.removeAttribute(o, n)
              }
            })
          }
        }
      }
      class Xk {
        constructor(t) {
          this._dispatchers = t
        }
        add(t) {
          for (const e of this._dispatchers) {
            t(e)
          }
          return this
        }
      }
      class tb extends Xk {
        elementToElement(t) {
          return this.add(Ab(t))
        }
        elementToStructure(t) {
          return this.add(Cb(t))
        }
        attributeToElement(t) {
          return this.add(yb(t))
        }
        attributeToAttribute(t) {
          return this.add(xb(t))
        }
        markerToElement(t) {
          return this.add(Eb(t))
        }
        markerToHighlight(t) {
          return this.add(Sb(t))
        }
        markerToData(t) {
          return this.add(Db(t))
        }
      }
      function eb() {
        return (t, e, n) => {
          if (!n.consumable.consume(e.item, t.name)) {
            return
          }
          const o = n.writer
          const r = n.mapper.toViewPosition(e.range.start)
          const i = o.createText(e.item.data)
          o.insert(r, i)
        }
      }
      function nb() {
        return (t, e, n) => {
          n.convertAttributes(e.item)
          if (!e.reconversion && e.item.is("element") && !e.item.isEmpty) {
            n.convertChildren(e.item)
          }
        }
      }
      function ob() {
        return (t, e, n) => {
          const o = n.mapper.toViewPosition(e.position)
          const r = e.position.getShiftedBy(e.length)
          const i = n.mapper.toViewPosition(r, { isPhantom: true })
          const s = n.writer.createRange(o, i)
          const a = n.writer.remove(s.getTrimmed())
          for (const t of n.writer.createRangeIn(a).getItems()) {
            n.mapper.unbindViewElement(t, { defer: true })
          }
        }
      }
      function rb(t, e) {
        const n = t.createAttributeElement("span", e.attributes)
        if (e.classes) {
          n._addClass(e.classes)
        }
        if (typeof e.priority === "number") {
          n._priority = e.priority
        }
        n._id = e.id
        return n
      }
      function ib() {
        return (t, e, n) => {
          const o = e.selection
          if (o.isCollapsed) {
            return
          }
          if (!n.consumable.consume(o, "selection")) {
            return
          }
          const r = []
          for (const t of o.getRanges()) {
            r.push(n.mapper.toViewRange(t))
          }
          n.writer.setSelection(r, { backward: o.isBackward })
        }
      }
      function sb() {
        return (t, e, n) => {
          const o = e.selection
          if (!o.isCollapsed) {
            return
          }
          if (!n.consumable.consume(o, "selection")) {
            return
          }
          const r = n.writer
          const i = o.getFirstPosition()
          const s = n.mapper.toViewPosition(i)
          const a = r.breakAttributes(s)
          r.setSelection(a)
        }
      }
      function ab() {
        return (t, e, n) => {
          const o = n.writer
          const r = o.document.selection
          for (const t of r.getRanges()) {
            if (t.isCollapsed) {
              if (t.end.parent.isAttached()) {
                n.writer.mergeAttributes(t.start)
              }
            }
          }
          o.setSelection(null)
        }
      }
      function cb(t) {
        return (e, n, o) => {
          if (!o.consumable.test(n.item, e.name)) {
            return
          }
          const r = t(n.attributeOldValue, o, n)
          const i = t(n.attributeNewValue, o, n)
          if (!r && !i) {
            return
          }
          o.consumable.consume(n.item, e.name)
          const s = o.writer
          const a = s.document.selection
          if (n.item instanceof zk || n.item instanceof Jk) {
            s.wrap(a.getFirstRange(), i)
          } else {
            let t = o.mapper.toViewRange(n.range)
            if (n.attributeOldValue !== null && r) {
              t = s.unwrap(t, r)
            }
            if (n.attributeNewValue !== null && i) {
              s.wrap(t, i)
            }
          }
        }
      }
      function lb(t, e = Wb) {
        return (n, o, r) => {
          if (!e(o.item, r.consumable, { preflight: true })) {
            return
          }
          const i = t(o.item, r, o)
          if (!i) {
            return
          }
          e(o.item, r.consumable)
          const s = r.mapper.toViewPosition(o.range.start)
          r.mapper.bindElements(o.item, i)
          r.writer.insert(s, i)
          r.convertAttributes(o.item)
          jb(i, o.item.getChildren(), r, { reconversion: o.reconversion })
        }
      }
      function db(t, e) {
        return (n, o, r) => {
          if (!e(o.item, r.consumable, { preflight: true })) {
            return
          }
          const i = new Map()
          r.writer._registerSlotFactory(Fb(o.item, i, r))
          const s = t(o.item, r, o)
          r.writer._clearSlotFactory()
          if (!s) {
            return
          }
          Vb(o.item, i, r)
          e(o.item, r.consumable)
          const a = r.mapper.toViewPosition(o.range.start)
          r.mapper.bindElements(o.item, s)
          r.writer.insert(a, s)
          r.convertAttributes(o.item)
          Lb(s, i, r, { reconversion: o.reconversion })
        }
      }
      function hb(t) {
        return (e, n, o) => {
          n.isOpening = true
          const r = t(n, o)
          n.isOpening = false
          const i = t(n, o)
          if (!r || !i) {
            return
          }
          const s = n.markerRange
          if (s.isCollapsed && !o.consumable.consume(s, e.name)) {
            return
          }
          for (const t of s) {
            if (!o.consumable.consume(t.item, e.name)) {
              return
            }
          }
          const a = o.mapper
          const c = o.writer
          c.insert(a.toViewPosition(s.start), r)
          o.mapper.bindElementToMarker(r, n.markerName)
          if (!s.isCollapsed) {
            c.insert(a.toViewPosition(s.end), i)
            o.mapper.bindElementToMarker(i, n.markerName)
          }
          e.stop()
        }
      }
      function ub() {
        return (t, e, n) => {
          const o = n.mapper.markerNameToElements(e.markerName)
          if (!o) {
            return
          }
          for (const t of o) {
            n.mapper.unbindElementFromMarkerName(t, e.markerName)
            n.writer.clear(n.writer.createRangeOn(t), t)
          }
          n.writer.clearClonedElementsGroup(e.markerName)
          t.stop()
        }
      }
      function fb(t) {
        return (e, n, o) => {
          const r = t(n.markerName, o)
          if (!r) {
            return
          }
          const i = n.markerRange
          if (!o.consumable.consume(i, e.name)) {
            return
          }
          pb(i, false, o, n, r)
          pb(i, true, o, n, r)
          e.stop()
        }
      }
      function pb(t, e, n, o, r) {
        const i = e ? t.start : t.end
        const s = i.nodeAfter && i.nodeAfter.is("element") ? i.nodeAfter : null
        const a = i.nodeBefore && i.nodeBefore.is("element") ? i.nodeBefore : null
        if (s || a) {
          let t
          let i
          if ((e && s) || (!e && !a)) {
            t = s
            i = true
          } else {
            t = a
            i = false
          }
          const c = n.mapper.toViewElement(t)
          if (c) {
            gb(c, e, i, n, o, r)
            return
          }
        }
        const c = n.mapper.toViewPosition(i)
        mb(c, e, n, o, r)
      }
      function gb(t, e, n, o, r, i) {
        const s = `data-${i.group}-${e ? "start" : "end"}-${n ? "before" : "after"}`
        const a = t.hasAttribute(s) ? t.getAttribute(s).split(",") : []
        a.unshift(i.name)
        o.writer.setAttribute(s, a.join(","), t)
        o.mapper.bindElementToMarker(t, r.markerName)
      }
      function mb(t, e, n, o, r) {
        const i = `${r.group}-${e ? "start" : "end"}`
        const s = r.name ? { name: r.name } : null
        const a = n.writer.createUIElement(i, s)
        n.writer.insert(t, a)
        n.mapper.bindElementToMarker(a, o.markerName)
      }
      function kb(t) {
        return (e, n, o) => {
          const r = t(n.markerName, o)
          if (!r) {
            return
          }
          const i = o.mapper.markerNameToElements(n.markerName)
          if (!i) {
            return
          }
          for (const t of i) {
            o.mapper.unbindElementFromMarkerName(t, n.markerName)
            if (t.is("containerElement")) {
              s(`data-${r.group}-start-before`, t)
              s(`data-${r.group}-start-after`, t)
              s(`data-${r.group}-end-before`, t)
              s(`data-${r.group}-end-after`, t)
            } else {
              o.writer.clear(o.writer.createRangeOn(t), t)
            }
          }
          o.writer.clearClonedElementsGroup(n.markerName)
          e.stop()
          function s(t, e) {
            if (e.hasAttribute(t)) {
              const n = new Set(e.getAttribute(t).split(","))
              n.delete(r.name)
              if (n.size == 0) {
                o.writer.removeAttribute(t, e)
              } else {
                o.writer.setAttribute(t, Array.from(n).join(","), e)
              }
            }
          }
        }
      }
      function bb(t) {
        return (e, n, o) => {
          if (!o.consumable.test(n.item, e.name)) {
            return
          }
          const r = t(n.attributeOldValue, o, n)
          const i = t(n.attributeNewValue, o, n)
          if (!r && !i) {
            return
          }
          o.consumable.consume(n.item, e.name)
          const s = o.mapper.toViewElement(n.item)
          const a = o.writer
          if (!s) {
            throw new P("conversion-attribute-to-attribute-on-text", o.dispatcher, n)
          }
          if (n.attributeOldValue !== null && r) {
            if (r.key == "class") {
              const t = tl(r.value)
              for (const e of t) {
                a.removeClass(e, s)
              }
            } else if (r.key == "style") {
              const t = Object.keys(r.value)
              for (const e of t) {
                a.removeStyle(e, s)
              }
            } else {
              a.removeAttribute(r.key, s)
            }
          }
          if (n.attributeNewValue !== null && i) {
            if (i.key == "class") {
              const t = tl(i.value)
              for (const e of t) {
                a.addClass(e, s)
              }
            } else if (i.key == "style") {
              const t = Object.keys(i.value)
              for (const e of t) {
                a.setStyle(e, i.value[e], s)
              }
            } else {
              a.setAttribute(i.key, i.value, s)
            }
          }
        }
      }
      function wb(t) {
        return (e, n, o) => {
          if (!n.item) {
            return
          }
          if (!(n.item instanceof zk || n.item instanceof Jk) && !n.item.is("$textProxy")) {
            return
          }
          const r = Mb(t, n, o)
          if (!r) {
            return
          }
          if (!o.consumable.consume(n.item, e.name)) {
            return
          }
          const i = o.writer
          const s = rb(i, r)
          const a = i.document.selection
          if (n.item instanceof zk || n.item instanceof Jk) {
            i.wrap(a.getFirstRange(), s)
          } else {
            const t = o.mapper.toViewRange(n.range)
            const e = i.wrap(t, s)
            for (const t of e.getItems()) {
              if (t.is("attributeElement") && t.isSimilar(s)) {
                o.mapper.bindElementToMarker(t, n.markerName)
                break
              }
            }
          }
        }
      }
      function _b(t) {
        return (e, n, o) => {
          if (!n.item) {
            return
          }
          if (!(n.item instanceof kk)) {
            return
          }
          const r = Mb(t, n, o)
          if (!r) {
            return
          }
          if (!o.consumable.test(n.item, e.name)) {
            return
          }
          const i = o.mapper.toViewElement(n.item)
          if (i && i.getCustomProperty("addHighlight")) {
            o.consumable.consume(n.item, e.name)
            for (const t of Sk._createIn(n.item)) {
              o.consumable.consume(t.item, e.name)
            }
            const t = i.getCustomProperty("addHighlight")
            t(i, r, o.writer)
            o.mapper.bindElementToMarker(i, n.markerName)
          }
        }
      }
      function vb(t) {
        return (e, n, o) => {
          if (n.markerRange.isCollapsed) {
            return
          }
          const r = Mb(t, n, o)
          if (!r) {
            return
          }
          const i = rb(o.writer, r)
          const s = o.mapper.markerNameToElements(n.markerName)
          if (!s) {
            return
          }
          for (const t of s) {
            o.mapper.unbindElementFromMarkerName(t, n.markerName)
            if (t.is("attributeElement")) {
              o.writer.unwrap(o.writer.createRangeOn(t), i)
            } else {
              const e = t.getCustomProperty("removeHighlight")
              e(t, r.id, o.writer)
            }
          }
          o.writer.clearClonedElementsGroup(n.markerName)
          e.stop()
        }
      }
      function Ab(t) {
        const e = Tb(t.model)
        const n = Pb(t.view, "container")
        if (e.attributes.length) {
          e.children = true
        }
        return (o) => {
          o.on(`insert:${e.name}`, lb(n, Nb(e)), { priority: t.converterPriority || "normal" })
          if (e.children || e.attributes.length) {
            o.on("reduceChanges", zb(e), { priority: "low" })
          }
        }
      }
      function Cb(t) {
        const e = Tb(t.model)
        const n = Pb(t.view, "container")
        e.children = true
        return (o) => {
          if (o._conversionApi.schema.checkChild(e.name, "$text")) {
            throw new P("conversion-element-to-structure-disallowed-text", o, {
              elementName: e.name,
            })
          }
          o.on(`insert:${e.name}`, db(n, Nb(e)), { priority: t.converterPriority || "normal" })
          o.on("reduceChanges", zb(e), { priority: "low" })
        }
      }
      function yb(t) {
        t = dk(t)
        let e = t.model
        if (typeof e == "string") {
          e = { key: e }
        }
        let n = `attribute:${e.key}`
        if (e.name) {
          n += ":" + e.name
        }
        if (e.values) {
          for (const n of e.values) {
            t.view[n] = Pb(t.view[n], "attribute")
          }
        } else {
          t.view = Pb(t.view, "attribute")
        }
        const o = Rb(t)
        return (e) => {
          e.on(n, cb(o), { priority: t.converterPriority || "normal" })
        }
      }
      function xb(t) {
        t = dk(t)
        let e = t.model
        if (typeof e == "string") {
          e = { key: e }
        }
        let n = `attribute:${e.key}`
        if (e.name) {
          n += ":" + e.name
        }
        if (e.values) {
          for (const n of e.values) {
            t.view[n] = Ob(t.view[n])
          }
        } else {
          t.view = Ob(t.view)
        }
        const o = Rb(t)
        return (e) => {
          e.on(n, bb(o), { priority: t.converterPriority || "normal" })
        }
      }
      function Eb(t) {
        const e = Pb(t.view, "ui")
        return (n) => {
          n.on(`addMarker:${t.model}`, hb(e), { priority: t.converterPriority || "normal" })
          n.on(`removeMarker:${t.model}`, ub(), { priority: t.converterPriority || "normal" })
        }
      }
      function Db(t) {
        t = dk(t)
        const e = t.model
        let n = t.view
        if (!n) {
          n = (n) => ({ group: e, name: n.substr(t.model.length + 1) })
        }
        return (o) => {
          o.on(`addMarker:${e}`, fb(n), { priority: t.converterPriority || "normal" })
          o.on(`removeMarker:${e}`, kb(n), { priority: t.converterPriority || "normal" })
        }
      }
      function Sb(t) {
        return (e) => {
          e.on(`addMarker:${t.model}`, wb(t.view), { priority: t.converterPriority || "normal" })
          e.on(`addMarker:${t.model}`, _b(t.view), { priority: t.converterPriority || "normal" })
          e.on(`removeMarker:${t.model}`, vb(t.view), { priority: t.converterPriority || "normal" })
        }
      }
      function Tb(t) {
        if (typeof t == "string") {
          t = { name: t }
        }
        if (!t.attributes) {
          t.attributes = []
        } else if (!Array.isArray(t.attributes)) {
          t.attributes = [t.attributes]
        }
        t.children = !!t.children
        return t
      }
      function Pb(t, e) {
        if (typeof t == "function") {
          return t
        }
        return (n, o) => Bb(t, o, e)
      }
      function Bb(t, e, n) {
        if (typeof t == "string") {
          t = { name: t }
        }
        let o
        const r = e.writer
        const i = Object.assign({}, t.attributes)
        if (n == "container") {
          o = r.createContainerElement(t.name, i)
        } else if (n == "attribute") {
          const e = { priority: t.priority || wp.DEFAULT_PRIORITY }
          o = r.createAttributeElement(t.name, i, e)
        } else {
          o = r.createUIElement(t.name, i)
        }
        if (t.styles) {
          const e = Object.keys(t.styles)
          for (const n of e) {
            r.setStyle(n, t.styles[n], o)
          }
        }
        if (t.classes) {
          const e = t.classes
          if (typeof e == "string") {
            r.addClass(e, o)
          } else {
            for (const t of e) {
              r.addClass(t, o)
            }
          }
        }
        return o
      }
      function Rb(t) {
        if (t.model.values) {
          return (e, n, o) => {
            const r = t.view[e]
            if (r) {
              return r(e, n, o)
            }
            return null
          }
        } else {
          return t.view
        }
      }
      function Ob(t) {
        if (typeof t == "string") {
          return (e) => ({ key: t, value: e })
        } else if (typeof t == "object") {
          if (t.value) {
            return () => t
          } else {
            return (e) => ({ key: t.key, value: e })
          }
        } else {
          return t
        }
      }
      function Mb(t, e, n) {
        const o = typeof t == "function" ? t(e, n) : t
        if (!o) {
          return null
        }
        if (!o.priority) {
          o.priority = 10
        }
        if (!o.id) {
          o.id = e.markerName
        }
        return o
      }
      function Ib(t) {
        return (e, n) => {
          if (!e.is("element", t.name)) {
            return false
          }
          if (n.type == "attribute") {
            if (t.attributes.includes(n.attributeKey)) {
              return true
            }
          } else {
            if (t.children) {
              return true
            }
          }
          return false
        }
      }
      function zb(t) {
        const e = Ib(t)
        return (t, n) => {
          const o = []
          if (!n.reconvertedElements) {
            n.reconvertedElements = new Set()
          }
          for (const t of n.changes) {
            const r = t.type == "attribute" ? t.range.start.nodeAfter : t.position.parent
            if (!r || !e(r, t)) {
              o.push(t)
              continue
            }
            if (!n.reconvertedElements.has(r)) {
              n.reconvertedElements.add(r)
              const t = vk._createBefore(r)
              let e = o.length
              for (let n = o.length - 1; n >= 0; n--) {
                const r = o[n]
                const i = r.type == "attribute" ? r.range.start : r.position
                const s = i.compareWith(t)
                if (s == "before" || (r.type == "remove" && s == "same")) {
                  break
                }
                e = n
              }
              o.splice(
                e,
                0,
                { type: "remove", name: r.name, position: t, length: 1 },
                { type: "reinsert", name: r.name, position: t, length: 1 }
              )
            }
          }
          n.changes = o
        }
      }
      function Nb(t) {
        return (e, n, o = {}) => {
          const r = ["insert"]
          for (const n of t.attributes) {
            if (e.hasAttribute(n)) {
              r.push(`attribute:${n}`)
            }
          }
          if (!r.every((t) => n.test(e, t))) {
            return false
          }
          if (!o.preflight) {
            r.forEach((t) => n.consume(e, t))
          }
          return true
        }
      }
      function Fb(t, e, n) {
        return (o, r) => {
          const i = o.createContainerElement("$slot")
          let s = null
          if (r === "children") {
            s = Array.from(t.getChildren())
          } else if (typeof r == "function") {
            s = Array.from(t.getChildren()).filter((t) => r(t))
          } else {
            throw new P("conversion-slot-mode-unknown", n.dispatcher, { modeOrFilter: r })
          }
          e.set(i, s)
          return i
        }
      }
      function Vb(t, e, n) {
        const o = Array.from(e.values()).flat()
        const r = new Set(o)
        if (r.size != o.length) {
          throw new P("conversion-slot-filter-overlap", n.dispatcher, { element: t })
        }
        if (r.size != t.childCount) {
          throw new P("conversion-slot-filter-incomplete", n.dispatcher, { element: t })
        }
      }
      function Lb(t, e, n, o) {
        n.mapper.on("modelToViewPosition", s, { priority: "highest" })
        let r = null
        let i = null
        for ([r, i] of e) {
          jb(t, i, n, o)
          n.writer.move(n.writer.createRangeIn(r), n.writer.createPositionBefore(r))
          n.writer.remove(r)
        }
        n.mapper.off("modelToViewPosition", s)
        function s(t, e) {
          const n = e.modelPosition.nodeAfter
          const o = i.indexOf(n)
          if (o < 0) {
            return
          }
          e.viewPosition = e.mapper.findPositionIn(r, o)
        }
      }
      function jb(t, e, n, o) {
        for (const r of e) {
          if (!Hb(t.root, r, n, o)) {
            n.convertItem(r)
          }
        }
      }
      function Hb(t, e, n, o) {
        const { writer: r, mapper: i } = n
        if (!o.reconversion) {
          return false
        }
        const s = i.toViewElement(e)
        if (!s || s.root == t) {
          return false
        }
        if (!n.canReuseView(s)) {
          return false
        }
        r.move(r.createRangeOn(s), i.toViewPosition(vk._createBefore(e)))
        return true
      }
      function Wb(t, e, { preflight: n } = {}) {
        if (n) {
          return e.test(t, "insert")
        } else {
          return e.consume(t, "insert")
        }
      }
      function qb(t) {
        const { schema: e, document: n } = t.model
        for (const o of n.getRootNames()) {
          const r = n.getRoot(o)
          if (r.isEmpty && !e.checkChild(r, "$text")) {
            if (e.checkChild(r, "paragraph")) {
              t.insertElement("paragraph", r)
              return true
            }
          }
        }
        return false
      }
      function $b(t, e, n) {
        const o = n.createContext(t)
        if (!n.checkChild(o, "paragraph")) {
          return false
        }
        if (!n.checkChild(o.push("paragraph"), e)) {
          return false
        }
        return true
      }
      function Kb(t, e) {
        const n = e.createElement("paragraph")
        e.insert(n, t)
        return e.createPositionAt(n, 0)
      }
      class Gb extends Xk {
        elementToElement(t) {
          return this.add(Yb(t))
        }
        elementToAttribute(t) {
          return this.add(Qb(t))
        }
        attributeToAttribute(t) {
          return this.add(Xb(t))
        }
        elementToMarker(t) {
          return this.add(tw(t))
        }
        dataToMarker(t) {
          return this.add(ew(t))
        }
      }
      function Ub() {
        return (t, e, n) => {
          if (!e.modelRange && n.consumable.consume(e.viewItem, { name: true })) {
            const { modelRange: t, modelCursor: o } = n.convertChildren(e.viewItem, e.modelCursor)
            e.modelRange = t
            e.modelCursor = o
          }
        }
      }
      function Jb() {
        return (t, e, { schema: n, consumable: o, writer: r }) => {
          let i = e.modelCursor
          if (!o.test(e.viewItem)) {
            return
          }
          if (!n.checkChild(i, "$text")) {
            if (!$b(i, "$text", n)) {
              return
            }
            if (e.viewItem.data.trim().length == 0) {
              return
            }
            const t = i.nodeBefore
            i = Kb(i, r)
            if (t && t.is("element", "$marker")) {
              r.move(r.createRangeOn(t), i)
              i = r.createPositionAfter(t)
            }
          }
          o.consume(e.viewItem)
          const s = r.createText(e.viewItem.data)
          r.insert(s, i)
          e.modelRange = r.createRange(i, i.getShiftedBy(s.offsetSize))
          e.modelCursor = e.modelRange.end
        }
      }
      function Zb(t, e) {
        return (n, o) => {
          const r = o.newSelection
          const i = []
          for (const t of r.getRanges()) {
            i.push(e.toModelRange(t))
          }
          const s = t.createSelection(i, { backward: r.isBackward })
          if (!s.isEqual(t.document.selection)) {
            t.change((t) => {
              t.setSelection(s)
            })
          }
        }
      }
      function Yb(t) {
        t = dk(t)
        const e = rw(t)
        const n = ow(t.view)
        const o = n ? `element:${n}` : "element"
        return (n) => {
          n.on(o, e, { priority: t.converterPriority || "normal" })
        }
      }
      function Qb(t) {
        t = dk(t)
        aw(t)
        const e = cw(t, false)
        const n = ow(t.view)
        const o = n ? `element:${n}` : "element"
        return (n) => {
          n.on(o, e, { priority: t.converterPriority || "low" })
        }
      }
      function Xb(t) {
        t = dk(t)
        let e = null
        if (typeof t.view == "string" || t.view.key) {
          e = sw(t)
        }
        aw(t, e)
        const n = cw(t, true)
        return (e) => {
          e.on("element", n, { priority: t.converterPriority || "low" })
        }
      }
      function tw(t) {
        const e = hw(t.model)
        return Yb({ ...t, model: e })
      }
      function ew(t) {
        t = dk(t)
        if (!t.model) {
          t.model = (e) => (e ? t.view + ":" + e : t.view)
        }
        const e = { view: t.view, model: t.model }
        const n = rw(uw(e, "start"))
        const o = rw(uw(e, "end"))
        return (r) => {
          r.on(`element:${t.view}-start`, n, { priority: t.converterPriority || "normal" })
          r.on(`element:${t.view}-end`, o, { priority: t.converterPriority || "normal" })
          const i = D.low
          const s = D.highest
          const a = D.get(t.converterPriority) / s
          r.on("element", nw(e), { priority: i + a })
        }
      }
      function nw(t) {
        return (e, n, o) => {
          const r = `data-${t.view}`
          if (
            !o.consumable.test(n.viewItem, { attributes: r + "-end-after" }) &&
            !o.consumable.test(n.viewItem, { attributes: r + "-start-after" }) &&
            !o.consumable.test(n.viewItem, { attributes: r + "-end-before" }) &&
            !o.consumable.test(n.viewItem, { attributes: r + "-start-before" })
          ) {
            return
          }
          if (!n.modelRange) {
            Object.assign(n, o.convertChildren(n.viewItem, n.modelCursor))
          }
          if (o.consumable.consume(n.viewItem, { attributes: r + "-end-after" })) {
            i(n.modelRange.end, n.viewItem.getAttribute(r + "-end-after").split(","))
          }
          if (o.consumable.consume(n.viewItem, { attributes: r + "-start-after" })) {
            i(n.modelRange.end, n.viewItem.getAttribute(r + "-start-after").split(","))
          }
          if (o.consumable.consume(n.viewItem, { attributes: r + "-end-before" })) {
            i(n.modelRange.start, n.viewItem.getAttribute(r + "-end-before").split(","))
          }
          if (o.consumable.consume(n.viewItem, { attributes: r + "-start-before" })) {
            i(n.modelRange.start, n.viewItem.getAttribute(r + "-start-before").split(","))
          }
          function i(e, r) {
            for (const i of r) {
              const r = t.model(i, o)
              const s = o.writer.createElement("$marker", { "data-name": r })
              o.writer.insert(s, e)
              if (n.modelCursor.isEqual(e)) {
                n.modelCursor = n.modelCursor.getShiftedBy(1)
              } else {
                n.modelCursor = n.modelCursor._getTransformedByInsertion(e, 1)
              }
              n.modelRange = n.modelRange._getTransformedByInsertion(e, 1)[0]
            }
          }
        }
      }
      function ow(t) {
        if (typeof t == "string") {
          return t
        }
        if (typeof t == "object" && typeof t.name == "string") {
          return t.name
        }
        return null
      }
      function rw(t) {
        const e = new Jh(t.view)
        return (n, o, r) => {
          const i = e.match(o.viewItem)
          if (!i) {
            return
          }
          const s = i.match
          s.name = true
          if (!r.consumable.test(o.viewItem, s)) {
            return
          }
          const a = iw(t.model, o.viewItem, r)
          if (!a) {
            return
          }
          if (!r.safeInsert(a, o.modelCursor)) {
            return
          }
          r.consumable.consume(o.viewItem, s)
          r.convertChildren(o.viewItem, a)
          r.updateConversionResult(a, o)
        }
      }
      function iw(t, e, n) {
        if (t instanceof Function) {
          return t(e, n)
        } else {
          return n.writer.createElement(t)
        }
      }
      function sw(t) {
        if (typeof t.view == "string") {
          t.view = { key: t.view }
        }
        const e = t.view.key
        let n
        if (e == "class" || e == "style") {
          const o = e == "class" ? "classes" : "styles"
          n = { [o]: t.view.value }
        } else {
          const o = typeof t.view.value == "undefined" ? /[\s\S]*/ : t.view.value
          n = { attributes: { [e]: o } }
        }
        if (t.view.name) {
          n.name = t.view.name
        }
        t.view = n
        return e
      }
      function aw(t, e = null) {
        const n = e === null ? true : (t) => t.getAttribute(e)
        const o = typeof t.model != "object" ? t.model : t.model.key
        const r =
          typeof t.model != "object" || typeof t.model.value == "undefined" ? n : t.model.value
        t.model = { key: o, value: r }
      }
      function cw(t, e) {
        const n = new Jh(t.view)
        return (o, r, i) => {
          if (!r.modelRange && e) {
            return
          }
          const s = n.match(r.viewItem)
          if (!s) {
            return
          }
          if (lw(t.view, r.viewItem)) {
            s.match.name = true
          } else {
            delete s.match.name
          }
          if (!i.consumable.test(r.viewItem, s.match)) {
            return
          }
          const a = t.model.key
          const c =
            typeof t.model.value == "function" ? t.model.value(r.viewItem, i) : t.model.value
          if (c === null) {
            return
          }
          if (!r.modelRange) {
            Object.assign(r, i.convertChildren(r.viewItem, r.modelCursor))
          }
          const l = dw(r.modelRange, { key: a, value: c }, e, i)
          if (l) {
            if (i.consumable.test(r.viewItem, { name: true })) {
              s.match.name = true
            }
            i.consumable.consume(r.viewItem, s.match)
          }
        }
      }
      function lw(t, e) {
        const n = typeof t == "function" ? t(e) : t
        if (typeof n == "object" && !ow(n)) {
          return false
        }
        return !n.classes && !n.attributes && !n.styles
      }
      function dw(t, e, n, o) {
        let r = false
        for (const i of Array.from(t.getItems({ shallow: n }))) {
          if (!o.schema.checkAttribute(i, e.key)) {
            continue
          }
          r = true
          if (i.hasAttribute(e.key)) {
            continue
          }
          o.writer.setAttribute(e.key, e.value, i)
        }
        return r
      }
      function hw(t) {
        return (e, n) => {
          const o = typeof t == "string" ? t : t(e, n)
          return n.writer.createElement("$marker", { "data-name": o })
        }
      }
      function uw(t, e) {
        const n = (e, n) => {
          const o = e.getAttribute("name")
          const r = t.model(o, n)
          return n.writer.createElement("$marker", { "data-name": r })
        }
        return { view: `${t.view}-${e}`, model: n }
      }
      function fw(t) {
        t.document.registerPostFixer((e) => pw(e, t))
      }
      function pw(t, e) {
        const n = e.document.selection
        const o = e.schema
        const r = []
        let i = false
        for (const t of n.getRanges()) {
          const e = gw(t, o)
          if (e && !e.isEqual(t)) {
            r.push(e)
            i = true
          } else {
            r.push(t)
          }
        }
        if (i) {
          t.setSelection(_w(r), { backward: n.isBackward })
        }
        return false
      }
      function gw(t, e) {
        if (t.isCollapsed) {
          return mw(t, e)
        }
        return kw(t, e)
      }
      function mw(t, e) {
        const n = t.start
        const o = e.getNearestSelectionRange(n)
        if (!o) {
          const t = n
            .getAncestors()
            .reverse()
            .find((t) => e.isObject(t))
          if (t) {
            return Sk._createOn(t)
          }
          return null
        }
        if (!o.isCollapsed) {
          return o
        }
        const r = o.start
        if (n.isEqual(r)) {
          return null
        }
        return new Sk(r)
      }
      function kw(t, e) {
        const { start: n, end: o } = t
        const r = e.checkChild(n, "$text")
        const i = e.checkChild(o, "$text")
        const s = e.getLimitElement(n)
        const a = e.getLimitElement(o)
        if (s === a) {
          if (r && i) {
            return null
          }
          if (ww(n, o, e)) {
            const t = n.nodeAfter && e.isSelectable(n.nodeAfter)
            const r = t ? null : e.getNearestSelectionRange(n, "forward")
            const i = o.nodeBefore && e.isSelectable(o.nodeBefore)
            const s = i ? null : e.getNearestSelectionRange(o, "backward")
            const a = r ? r.start : n
            const c = s ? s.end : o
            return new Sk(a, c)
          }
        }
        const c = s && !s.is("rootElement")
        const l = a && !a.is("rootElement")
        if (c || l) {
          const t = n.nodeAfter && o.nodeBefore && n.nodeAfter.parent === o.nodeBefore.parent
          const r = c && (!t || !vw(n.nodeAfter, e))
          const i = l && (!t || !vw(o.nodeBefore, e))
          let d = n
          let h = o
          if (r) {
            d = vk._createBefore(bw(s, e))
          }
          if (i) {
            h = vk._createAfter(bw(a, e))
          }
          return new Sk(d, h)
        }
        return null
      }
      function bw(t, e) {
        let n = t
        let o = n
        while (e.isLimit(o) && o.parent) {
          n = o
          o = o.parent
        }
        return n
      }
      function ww(t, e, n) {
        const o = (t.nodeAfter && !n.isLimit(t.nodeAfter)) || n.checkChild(t, "$text")
        const r = (e.nodeBefore && !n.isLimit(e.nodeBefore)) || n.checkChild(e, "$text")
        return o || r
      }
      function _w(t) {
        const e = [...t]
        const n = new Set()
        let o = 1
        while (o < e.length) {
          const t = e[o]
          const r = e.slice(0, o)
          for (const [i, s] of r.entries()) {
            if (n.has(i)) {
              continue
            }
            if (t.isEqual(s)) {
              n.add(i)
            } else if (t.isIntersecting(s)) {
              n.add(i)
              n.add(o)
              const r = t.getJoined(s)
              e.push(r)
            }
          }
          o++
        }
        const r = e.filter((t, e) => !n.has(e))
        return r
      }
      function vw(t, e) {
        return t && e.isSelectable(t)
      }
      class Aw extends dt() {
        constructor(t, e) {
          super()
          this.model = t
          this.view = new hk(e)
          this.mapper = new Tk()
          this.downcastDispatcher = new Rk({ mapper: this.mapper, schema: t.schema })
          const n = this.model.document
          const o = n.selection
          const r = this.model.markers
          this.listenTo(
            this.model,
            "_beforeChanges",
            () => {
              this.view._disableRendering(true)
            },
            { priority: "highest" }
          )
          this.listenTo(
            this.model,
            "_afterChanges",
            () => {
              this.view._disableRendering(false)
            },
            { priority: "lowest" }
          )
          this.listenTo(
            n,
            "change",
            () => {
              this.view.change((t) => {
                this.downcastDispatcher.convertChanges(n.differ, r, t)
                this.downcastDispatcher.convertSelection(o, r, t)
              })
            },
            { priority: "low" }
          )
          this.listenTo(this.view.document, "selectionChange", Zb(this.model, this.mapper))
          this.listenTo(
            this.view.document,
            "beforeinput",
            Cw(this.mapper, this.model.schema, this.view),
            { priority: "high" }
          )
          this.downcastDispatcher.on("insert:$text", eb(), { priority: "lowest" })
          this.downcastDispatcher.on("insert", nb(), { priority: "lowest" })
          this.downcastDispatcher.on("remove", ob(), { priority: "low" })
          this.downcastDispatcher.on("selection", ab(), { priority: "high" })
          this.downcastDispatcher.on("selection", ib(), { priority: "low" })
          this.downcastDispatcher.on("selection", sb(), { priority: "low" })
          this.view.document.roots.bindTo(this.model.document.roots).using((t) => {
            if (t.rootName == "$graveyard") {
              return null
            }
            const e = new np(this.view.document, t.name)
            e.rootName = t.rootName
            this.mapper.bindElements(t, e)
            return e
          })
        }
        destroy() {
          this.view.destroy()
          this.stopListening()
        }
        reconvertMarker(t) {
          const e = typeof t == "string" ? t : t.name
          const n = this.model.markers.get(e)
          if (!n) {
            throw new P("editingcontroller-reconvertmarker-marker-not-exist", this, {
              markerName: e,
            })
          }
          this.model.change(() => {
            this.model.markers._refresh(n)
          })
        }
        reconvertItem(t) {
          this.model.change(() => {
            this.model.document.differ._refreshItem(t)
          })
        }
      }
      function Cw(t, e, n) {
        return (o, r) => {
          if (n.document.isComposing && !i.isAndroid) {
            return
          }
          for (let n = 0; n < r.targetRanges.length; n++) {
            const o = r.targetRanges[n]
            const i = t.toModelRange(o)
            const s = gw(i, e)
            if (!s || s.isEqual(i)) {
              continue
            }
            r.targetRanges[n] = t.toViewRange(s)
          }
        }
      }
      class yw {
        constructor() {
          this._consumables = new Map()
        }
        add(t, e) {
          let n
          if (t.is("$text") || t.is("documentFragment")) {
            this._consumables.set(t, true)
            return
          }
          if (!this._consumables.has(t)) {
            n = new Ew(t)
            this._consumables.set(t, n)
          } else {
            n = this._consumables.get(t)
          }
          n.add(e)
        }
        test(t, e) {
          const n = this._consumables.get(t)
          if (n === undefined) {
            return null
          }
          if (t.is("$text") || t.is("documentFragment")) {
            return n
          }
          return n.test(e)
        }
        consume(t, e) {
          if (this.test(t, e)) {
            if (t.is("$text") || t.is("documentFragment")) {
              this._consumables.set(t, false)
            } else {
              this._consumables.get(t).consume(e)
            }
            return true
          }
          return false
        }
        revert(t, e) {
          const n = this._consumables.get(t)
          if (n !== undefined) {
            if (t.is("$text") || t.is("documentFragment")) {
              this._consumables.set(t, true)
            } else {
              n.revert(e)
            }
          }
        }
        static consumablesFromElement(t) {
          const e = { element: t, name: true, attributes: [], classes: [], styles: [] }
          const n = t.getAttributeKeys()
          for (const t of n) {
            if (t == "style" || t == "class") {
              continue
            }
            e.attributes.push(t)
          }
          const o = t.getClassNames()
          for (const t of o) {
            e.classes.push(t)
          }
          const r = t.getStyleNames()
          for (const t of r) {
            e.styles.push(t)
          }
          return e
        }
        static createFrom(t, e) {
          if (!e) {
            e = new yw()
          }
          if (t.is("$text")) {
            e.add(t)
            return e
          }
          if (t.is("element")) {
            e.add(t, yw.consumablesFromElement(t))
          }
          if (t.is("documentFragment")) {
            e.add(t)
          }
          for (const n of t.getChildren()) {
            e = yw.createFrom(n, e)
          }
          return e
        }
      }
      const xw = ["attributes", "classes", "styles"]
      class Ew {
        constructor(t) {
          this.element = t
          this._canConsumeName = null
          this._consumables = { attributes: new Map(), styles: new Map(), classes: new Map() }
        }
        add(t) {
          if (t.name) {
            this._canConsumeName = true
          }
          for (const e of xw) {
            if (e in t) {
              this._add(e, t[e])
            }
          }
        }
        test(t) {
          if (t.name && !this._canConsumeName) {
            return this._canConsumeName
          }
          for (const e of xw) {
            if (e in t) {
              const n = this._test(e, t[e])
              if (n !== true) {
                return n
              }
            }
          }
          return true
        }
        consume(t) {
          if (t.name) {
            this._canConsumeName = false
          }
          for (const e of xw) {
            if (e in t) {
              this._consume(e, t[e])
            }
          }
        }
        revert(t) {
          if (t.name) {
            this._canConsumeName = true
          }
          for (const e of xw) {
            if (e in t) {
              this._revert(e, t[e])
            }
          }
        }
        _add(t, e) {
          const n = Ut(e) ? e : [e]
          const o = this._consumables[t]
          for (const e of n) {
            if (t === "attributes" && (e === "class" || e === "style")) {
              throw new P("viewconsumable-invalid-attribute", this)
            }
            o.set(e, true)
            if (t === "styles") {
              for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) {
                o.set(t, true)
              }
            }
          }
        }
        _test(t, e) {
          const n = Ut(e) ? e : [e]
          const o = this._consumables[t]
          for (const e of n) {
            if (t === "attributes" && (e === "class" || e === "style")) {
              const t = e == "class" ? "classes" : "styles"
              const n = this._test(t, [...this._consumables[t].keys()])
              if (n !== true) {
                return n
              }
            } else {
              const t = o.get(e)
              if (t === undefined) {
                return null
              }
              if (!t) {
                return false
              }
            }
          }
          return true
        }
        _consume(t, e) {
          const n = Ut(e) ? e : [e]
          const o = this._consumables[t]
          for (const e of n) {
            if (t === "attributes" && (e === "class" || e === "style")) {
              const t = e == "class" ? "classes" : "styles"
              this._consume(t, [...this._consumables[t].keys()])
            } else {
              o.set(e, false)
              if (t == "styles") {
                for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) {
                  o.set(t, false)
                }
              }
            }
          }
        }
        _revert(t, e) {
          const n = Ut(e) ? e : [e]
          const o = this._consumables[t]
          for (const e of n) {
            if (t === "attributes" && (e === "class" || e === "style")) {
              const t = e == "class" ? "classes" : "styles"
              this._revert(t, [...this._consumables[t].keys()])
            } else {
              const t = o.get(e)
              if (t === false) {
                o.set(e, true)
              }
            }
          }
        }
      }
      class Dw extends dt() {
        constructor() {
          super()
          this._sourceDefinitions = {}
          this._attributeProperties = {}
          this.decorate("checkChild")
          this.decorate("checkAttribute")
          this.on(
            "checkAttribute",
            (t, e) => {
              e[0] = new Sw(e[0])
            },
            { priority: "highest" }
          )
          this.on(
            "checkChild",
            (t, e) => {
              e[0] = new Sw(e[0])
              e[1] = this.getDefinition(e[1])
            },
            { priority: "highest" }
          )
        }
        register(t, e) {
          if (this._sourceDefinitions[t]) {
            throw new P("schema-cannot-register-item-twice", this, { itemName: t })
          }
          this._sourceDefinitions[t] = [Object.assign({}, e)]
          this._clearCache()
        }
        extend(t, e) {
          if (!this._sourceDefinitions[t]) {
            throw new P("schema-cannot-extend-missing-item", this, { itemName: t })
          }
          this._sourceDefinitions[t].push(Object.assign({}, e))
          this._clearCache()
        }
        getDefinitions() {
          if (!this._compiledDefinitions) {
            this._compile()
          }
          return this._compiledDefinitions
        }
        getDefinition(t) {
          let e
          if (typeof t == "string") {
            e = t
          } else if ("is" in t && (t.is("$text") || t.is("$textProxy"))) {
            e = "$text"
          } else {
            e = t.name
          }
          return this.getDefinitions()[e]
        }
        isRegistered(t) {
          return !!this.getDefinition(t)
        }
        isBlock(t) {
          const e = this.getDefinition(t)
          return !!(e && e.isBlock)
        }
        isLimit(t) {
          const e = this.getDefinition(t)
          if (!e) {
            return false
          }
          return !!(e.isLimit || e.isObject)
        }
        isObject(t) {
          const e = this.getDefinition(t)
          if (!e) {
            return false
          }
          return !!(e.isObject || (e.isLimit && e.isSelectable && e.isContent))
        }
        isInline(t) {
          const e = this.getDefinition(t)
          return !!(e && e.isInline)
        }
        isSelectable(t) {
          const e = this.getDefinition(t)
          if (!e) {
            return false
          }
          return !!(e.isSelectable || e.isObject)
        }
        isContent(t) {
          const e = this.getDefinition(t)
          if (!e) {
            return false
          }
          return !!(e.isContent || e.isObject)
        }
        checkChild(t, e) {
          if (!e) {
            return false
          }
          return this._checkContextMatch(e, t)
        }
        checkAttribute(t, e) {
          const n = this.getDefinition(t.last)
          if (!n) {
            return false
          }
          return n.allowAttributes.includes(e)
        }
        checkMerge(t, e) {
          if (t instanceof vk) {
            const e = t.nodeBefore
            const n = t.nodeAfter
            if (!(e instanceof kk)) {
              throw new P("schema-check-merge-no-element-before", this)
            }
            if (!(n instanceof kk)) {
              throw new P("schema-check-merge-no-element-after", this)
            }
            return this.checkMerge(e, n)
          }
          for (const n of e.getChildren()) {
            if (!this.checkChild(t, n)) {
              return false
            }
          }
          return true
        }
        addChildCheck(t) {
          this.on(
            "checkChild",
            (e, [n, o]) => {
              if (!o) {
                return
              }
              const r = t(n, o)
              if (typeof r == "boolean") {
                e.stop()
                e.return = r
              }
            },
            { priority: "high" }
          )
        }
        addAttributeCheck(t) {
          this.on(
            "checkAttribute",
            (e, [n, o]) => {
              const r = t(n, o)
              if (typeof r == "boolean") {
                e.stop()
                e.return = r
              }
            },
            { priority: "high" }
          )
        }
        setAttributeProperties(t, e) {
          this._attributeProperties[t] = Object.assign(this.getAttributeProperties(t), e)
        }
        getAttributeProperties(t) {
          return this._attributeProperties[t] || {}
        }
        getLimitElement(t) {
          let e
          if (t instanceof vk) {
            e = t.parent
          } else {
            const n = t instanceof Sk ? [t] : Array.from(t.getRanges())
            e = n.reduce((t, e) => {
              const n = e.getCommonAncestor()
              if (!t) {
                return n
              }
              return t.getCommonAncestor(n, { includeSelf: true })
            }, null)
          }
          while (!this.isLimit(e)) {
            if (e.parent) {
              e = e.parent
            } else {
              break
            }
          }
          return e
        }
        checkAttributeInSelection(t, e) {
          if (t.isCollapsed) {
            const n = t.getFirstPosition()
            const o = [...n.getAncestors(), new gk("", t.getAttributes())]
            return this.checkAttribute(o, e)
          } else {
            const n = t.getRanges()
            for (const t of n) {
              for (const n of t) {
                if (this.checkAttribute(n.item, e)) {
                  return true
                }
              }
            }
          }
          return false
        }
        *getValidRanges(t, e) {
          t = $w(t)
          for (const n of t) {
            yield* this._getValidRangesForRange(n, e)
          }
        }
        getNearestSelectionRange(t, e = "both") {
          if (this.checkChild(t, "$text")) {
            return new Sk(t)
          }
          let n, o
          const r =
            t
              .getAncestors()
              .reverse()
              .find((t) => this.isLimit(t)) || t.root
          if (e == "both" || e == "backward") {
            n = new wk({ boundaries: Sk._createIn(r), startPosition: t, direction: "backward" })
          }
          if (e == "both" || e == "forward") {
            o = new wk({ boundaries: Sk._createIn(r), startPosition: t })
          }
          for (const t of qw(n, o)) {
            const e = t.walker == n ? "elementEnd" : "elementStart"
            const o = t.value
            if (o.type == e && this.isObject(o.item)) {
              return Sk._createOn(o.item)
            }
            if (this.checkChild(o.nextPosition, "$text")) {
              return new Sk(o.nextPosition)
            }
          }
          return null
        }
        findAllowedParent(t, e) {
          let n = t.parent
          while (n) {
            if (this.checkChild(n, e)) {
              return n
            }
            if (this.isLimit(n)) {
              return null
            }
            n = n.parent
          }
          return null
        }
        setAllowedAttributes(t, e, n) {
          const o = n.model
          for (const [r, i] of Object.entries(e)) {
            if (o.schema.checkAttribute(t, r)) {
              n.setAttribute(r, i, t)
            }
          }
        }
        removeDisallowedAttributes(t, e) {
          for (const n of t) {
            if (n.is("$text")) {
              Kw(this, n, e)
            } else {
              const t = Sk._createIn(n)
              const o = t.getPositions()
              for (const t of o) {
                const n = t.nodeBefore || t.parent
                Kw(this, n, e)
              }
            }
          }
        }
        getAttributesWithProperty(t, e, n) {
          const o = {}
          for (const [r, i] of t.getAttributes()) {
            const t = this.getAttributeProperties(r)
            if (t[e] === undefined) {
              continue
            }
            if (n === undefined || n === t[e]) {
              o[r] = i
            }
          }
          return o
        }
        createContext(t) {
          return new Sw(t)
        }
        _clearCache() {
          this._compiledDefinitions = null
        }
        _compile() {
          const t = {}
          const e = this._sourceDefinitions
          const n = Object.keys(e)
          for (const o of n) {
            t[o] = Tw(e[o], o)
          }
          for (const e of n) {
            Pw(t, e)
          }
          for (const e of n) {
            Bw(t, e)
          }
          for (const e of n) {
            Rw(t, e)
          }
          for (const e of n) {
            Ow(t, e)
            Mw(t, e)
          }
          for (const e of n) {
            Iw(t, e)
            zw(t, e)
            Nw(t, e)
          }
          this._compiledDefinitions = t
        }
        _checkContextMatch(t, e, n = e.length - 1) {
          const o = e.getItem(n)
          if (t.allowIn.includes(o.name)) {
            if (n == 0) {
              return true
            } else {
              const t = this.getDefinition(o)
              return this._checkContextMatch(t, e, n - 1)
            }
          } else {
            return false
          }
        }
        *_getValidRangesForRange(t, e) {
          let n = t.start
          let o = t.start
          for (const r of t.getItems({ shallow: true })) {
            if (r.is("element")) {
              yield* this._getValidRangesForRange(Sk._createIn(r), e)
            }
            if (!this.checkAttribute(r, e)) {
              if (!n.isEqual(o)) {
                yield new Sk(n, o)
              }
              n = vk._createAfter(r)
            }
            o = vk._createAfter(r)
          }
          if (!n.isEqual(o)) {
            yield new Sk(n, o)
          }
        }
      }
      class Sw {
        constructor(t) {
          if (t instanceof Sw) {
            return t
          }
          let e
          if (typeof t == "string") {
            e = [t]
          } else if (!Array.isArray(t)) {
            e = t.getAncestors({ includeSelf: true })
          } else {
            e = t
          }
          this._items = e.map(Ww)
        }
        get length() {
          return this._items.length
        }
        get last() {
          return this._items[this._items.length - 1]
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]()
        }
        push(t) {
          const e = new Sw([t])
          e._items = [...this._items, ...e._items]
          return e
        }
        getItem(t) {
          return this._items[t]
        }
        *getNames() {
          yield* this._items.map((t) => t.name)
        }
        endsWith(t) {
          return Array.from(this.getNames()).join(" ").endsWith(t)
        }
        startsWith(t) {
          return Array.from(this.getNames()).join(" ").startsWith(t)
        }
      }
      function Tw(t, e) {
        const n = {
          name: e,
          allowIn: [],
          allowContentOf: [],
          allowWhere: [],
          allowAttributes: [],
          allowAttributesOf: [],
          allowChildren: [],
          inheritTypesFrom: [],
        }
        Fw(t, n)
        Vw(t, n, "allowIn")
        Vw(t, n, "allowContentOf")
        Vw(t, n, "allowWhere")
        Vw(t, n, "allowAttributes")
        Vw(t, n, "allowAttributesOf")
        Vw(t, n, "allowChildren")
        Vw(t, n, "inheritTypesFrom")
        Lw(t, n)
        return n
      }
      function Pw(t, e) {
        const n = t[e]
        for (const o of n.allowChildren) {
          const n = t[o]
          if (!n) {
            continue
          }
          n.allowIn.push(e)
        }
        n.allowChildren.length = 0
      }
      function Bw(t, e) {
        for (const n of t[e].allowContentOf) {
          if (t[n]) {
            const o = jw(t, n)
            o.forEach((t) => {
              t.allowIn.push(e)
            })
          }
        }
        delete t[e].allowContentOf
      }
      function Rw(t, e) {
        for (const n of t[e].allowWhere) {
          const o = t[n]
          if (o) {
            const n = o.allowIn
            t[e].allowIn.push(...n)
          }
        }
        delete t[e].allowWhere
      }
      function Ow(t, e) {
        for (const n of t[e].allowAttributesOf) {
          const o = t[n]
          if (o) {
            const n = o.allowAttributes
            t[e].allowAttributes.push(...n)
          }
        }
        delete t[e].allowAttributesOf
      }
      function Mw(t, e) {
        const n = t[e]
        for (const e of n.inheritTypesFrom) {
          const o = t[e]
          if (o) {
            const t = Object.keys(o).filter((t) => t.startsWith("is"))
            for (const e of t) {
              if (!(e in n)) {
                n[e] = o[e]
              }
            }
          }
        }
        delete n.inheritTypesFrom
      }
      function Iw(t, e) {
        const n = t[e]
        const o = n.allowIn.filter((e) => t[e])
        n.allowIn = Array.from(new Set(o))
      }
      function zw(t, e) {
        const n = t[e]
        for (const o of n.allowIn) {
          const n = t[o]
          n.allowChildren.push(e)
        }
      }
      function Nw(t, e) {
        const n = t[e]
        n.allowAttributes = Array.from(new Set(n.allowAttributes))
      }
      function Fw(t, e) {
        for (const n of t) {
          const t = Object.keys(n).filter((t) => t.startsWith("is"))
          for (const o of t) {
            e[o] = !!n[o]
          }
        }
      }
      function Vw(t, e, n) {
        for (const o of t) {
          const t = o[n]
          if (typeof t == "string") {
            e[n].push(t)
          } else if (Array.isArray(t)) {
            e[n].push(...t)
          }
        }
      }
      function Lw(t, e) {
        for (const n of t) {
          const t = n.inheritAllFrom
          if (t) {
            e.allowContentOf.push(t)
            e.allowWhere.push(t)
            e.allowAttributesOf.push(t)
            e.inheritTypesFrom.push(t)
          }
        }
      }
      function jw(t, e) {
        const n = t[e]
        return Hw(t).filter((t) => t.allowIn.includes(n.name))
      }
      function Hw(t) {
        return Object.keys(t).map((e) => t[e])
      }
      function Ww(t) {
        if (typeof t == "string" || t.is("documentFragment")) {
          return {
            name: typeof t == "string" ? t : "$documentFragment",
            *getAttributeKeys() {},
            getAttribute() {},
          }
        } else {
          return {
            name: t.is("element") ? t.name : "$text",
            *getAttributeKeys() {
              yield* t.getAttributeKeys()
            },
            getAttribute(e) {
              return t.getAttribute(e)
            },
          }
        }
      }
      function* qw(t, e) {
        let n = false
        while (!n) {
          n = true
          if (t) {
            const e = t.next()
            if (!e.done) {
              n = false
              yield { walker: t, value: e.value }
            }
          }
          if (e) {
            const t = e.next()
            if (!t.done) {
              n = false
              yield { walker: e, value: t.value }
            }
          }
        }
      }
      function* $w(t) {
        for (const e of t) {
          yield* e.getMinimalFlatRanges()
        }
      }
      function Kw(t, e, n) {
        for (const o of e.getAttributeKeys()) {
          if (!t.checkAttribute(e, o)) {
            n.removeAttribute(o, e)
          }
        }
      }
      class Gw extends q() {
        constructor(t) {
          super()
          this._splitParts = new Map()
          this._cursorParents = new Map()
          this._modelCursor = null
          this._emptyElementsToKeep = new Set()
          this.conversionApi = {
            ...t,
            consumable: null,
            writer: null,
            store: null,
            convertItem: (t, e) => this._convertItem(t, e),
            convertChildren: (t, e) => this._convertChildren(t, e),
            safeInsert: (t, e) => this._safeInsert(t, e),
            updateConversionResult: (t, e) => this._updateConversionResult(t, e),
            splitToAllowedParent: (t, e) => this._splitToAllowedParent(t, e),
            getSplitParts: (t) => this._getSplitParts(t),
            keepEmptyElement: (t) => this._keepEmptyElement(t),
          }
        }
        convert(t, e, n = ["$root"]) {
          this.fire("viewCleanup", t)
          this._modelCursor = Jw(n, e)
          this.conversionApi.writer = e
          this.conversionApi.consumable = yw.createFrom(t)
          this.conversionApi.store = {}
          const { modelRange: o } = this._convertItem(t, this._modelCursor)
          const r = e.createDocumentFragment()
          if (o) {
            this._removeEmptyElements()
            for (const t of Array.from(this._modelCursor.parent.getChildren())) {
              e.append(t, r)
            }
            r.markers = Uw(r, e)
          }
          this._modelCursor = null
          this._splitParts.clear()
          this._cursorParents.clear()
          this._emptyElementsToKeep.clear()
          this.conversionApi.writer = null
          this.conversionApi.store = null
          return r
        }
        _convertItem(t, e) {
          const n = { viewItem: t, modelCursor: e, modelRange: null }
          if (t.is("element")) {
            this.fire(`element:${t.name}`, n, this.conversionApi)
          } else if (t.is("$text")) {
            this.fire("text", n, this.conversionApi)
          } else {
            this.fire("documentFragment", n, this.conversionApi)
          }
          if (n.modelRange && !(n.modelRange instanceof Sk)) {
            throw new P("view-conversion-dispatcher-incorrect-result", this)
          }
          return { modelRange: n.modelRange, modelCursor: n.modelCursor }
        }
        _convertChildren(t, e) {
          let n = e.is("position") ? e : vk._createAt(e, 0)
          const o = new Sk(n)
          for (const e of Array.from(t.getChildren())) {
            const t = this._convertItem(e, n)
            if (t.modelRange instanceof Sk) {
              o.end = t.modelRange.end
              n = t.modelCursor
            }
          }
          return { modelRange: o, modelCursor: n }
        }
        _safeInsert(t, e) {
          const n = this._splitToAllowedParent(t, e)
          if (!n) {
            return false
          }
          this.conversionApi.writer.insert(t, n.position)
          return true
        }
        _updateConversionResult(t, e) {
          const n = this._getSplitParts(t)
          const o = this.conversionApi.writer
          if (!e.modelRange) {
            e.modelRange = o.createRange(
              o.createPositionBefore(t),
              o.createPositionAfter(n[n.length - 1])
            )
          }
          const r = this._cursorParents.get(t)
          if (r) {
            e.modelCursor = o.createPositionAt(r, 0)
          } else {
            e.modelCursor = e.modelRange.end
          }
        }
        _splitToAllowedParent(t, e) {
          const { schema: n, writer: o } = this.conversionApi
          let r = n.findAllowedParent(e, t)
          if (r) {
            if (r === e.parent) {
              return { position: e }
            }
            if (this._modelCursor.parent.getAncestors().includes(r)) {
              r = null
            }
          }
          if (!r) {
            if (!$b(e, t, n)) {
              return null
            }
            return { position: Kb(e, o) }
          }
          const i = this.conversionApi.writer.split(e, r)
          const s = []
          for (const t of i.range.getWalker()) {
            if (t.type == "elementEnd") {
              s.push(t.item)
            } else {
              const e = s.pop()
              const n = t.item
              this._registerSplitPair(e, n)
            }
          }
          const a = i.range.end.parent
          this._cursorParents.set(t, a)
          return { position: i.position, cursorParent: a }
        }
        _registerSplitPair(t, e) {
          if (!this._splitParts.has(t)) {
            this._splitParts.set(t, [t])
          }
          const n = this._splitParts.get(t)
          this._splitParts.set(e, n)
          n.push(e)
        }
        _getSplitParts(t) {
          let e
          if (!this._splitParts.has(t)) {
            e = [t]
          } else {
            e = this._splitParts.get(t)
          }
          return e
        }
        _keepEmptyElement(t) {
          this._emptyElementsToKeep.add(t)
        }
        _removeEmptyElements() {
          let t = false
          for (const e of this._splitParts.keys()) {
            if (e.isEmpty && !this._emptyElementsToKeep.has(e)) {
              this.conversionApi.writer.remove(e)
              this._splitParts.delete(e)
              t = true
            }
          }
          if (t) {
            this._removeEmptyElements()
          }
        }
      }
      function Uw(t, e) {
        const n = new Set()
        const o = new Map()
        const r = Sk._createIn(t).getItems()
        for (const t of r) {
          if (t.is("element", "$marker")) {
            n.add(t)
          }
        }
        for (const t of n) {
          const n = t.getAttribute("data-name")
          const r = e.createPositionBefore(t)
          if (!o.has(n)) {
            o.set(n, new Sk(r.clone()))
          } else {
            o.get(n).end = r.clone()
          }
          e.remove(t)
        }
        return o
      }
      function Jw(t, e) {
        let n
        for (const o of new Sw(t)) {
          const t = {}
          for (const e of o.getAttributeKeys()) {
            t[e] = o.getAttribute(e)
          }
          const r = e.createElement(o.name, t)
          if (n) {
            e.insert(r, n)
          }
          n = vk._createAt(r, 0)
        }
        return n
      }
      class Zw {
        getHtml(t) {
          const e = document.implementation.createHTMLDocument("")
          const n = e.createElement("div")
          n.appendChild(t)
          return n.innerHTML
        }
      }
      class Yw {
        constructor(t) {
          this.skipComments = true
          this.domParser = new DOMParser()
          this.domConverter = new wg(t, { renderingMode: "data" })
          this.htmlWriter = new Zw()
        }
        toData(t) {
          const e = this.domConverter.viewToDom(t)
          return this.htmlWriter.getHtml(e)
        }
        toView(t) {
          const e = this._toDom(t)
          return this.domConverter.domToView(e, { skipComments: this.skipComments })
        }
        registerRawContentMatcher(t) {
          this.domConverter.registerRawContentMatcher(t)
        }
        useFillerType(t) {
          this.domConverter.blockFillerMode = t == "marked" ? "markedNbsp" : "nbsp"
        }
        _toDom(t) {
          if (!t.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i)) {
            t = `<body>${t}</body>`
          }
          const e = this.domParser.parseFromString(t, "text/html")
          const n = e.createDocumentFragment()
          const o = e.body.childNodes
          while (o.length > 0) {
            n.appendChild(o[0])
          }
          return n
        }
      }
      class Qw extends q() {
        constructor(t, e) {
          super()
          this.model = t
          this.mapper = new Tk()
          this.downcastDispatcher = new Rk({ mapper: this.mapper, schema: t.schema })
          this.downcastDispatcher.on("insert:$text", eb(), { priority: "lowest" })
          this.downcastDispatcher.on("insert", nb(), { priority: "lowest" })
          this.upcastDispatcher = new Gw({ schema: t.schema })
          this.viewDocument = new kp(e)
          this.stylesProcessor = e
          this.htmlProcessor = new Yw(this.viewDocument)
          this.processor = this.htmlProcessor
          this._viewWriter = new Rp(this.viewDocument)
          this.upcastDispatcher.on("text", Jb(), { priority: "lowest" })
          this.upcastDispatcher.on("element", Ub(), { priority: "lowest" })
          this.upcastDispatcher.on("documentFragment", Ub(), { priority: "lowest" })
          dt().prototype.decorate.call(this, "init")
          dt().prototype.decorate.call(this, "set")
          dt().prototype.decorate.call(this, "get")
          dt().prototype.decorate.call(this, "toView")
          dt().prototype.decorate.call(this, "toModel")
          this.on(
            "init",
            () => {
              this.fire("ready")
            },
            { priority: "lowest" }
          )
          this.on(
            "ready",
            () => {
              this.model.enqueueChange({ isUndoable: false }, qb)
            },
            { priority: "lowest" }
          )
        }
        get(t = {}) {
          const { rootName: e = "main", trim: n = "empty" } = t
          if (!this._checkIfRootsExists([e])) {
            throw new P("datacontroller-get-non-existent-root", this)
          }
          const o = this.model.document.getRoot(e)
          if (!o.isAttached()) {
            B("datacontroller-get-detached-root", this)
          }
          if (n === "empty" && !this.model.hasContent(o, { ignoreWhitespaces: true })) {
            return ""
          }
          return this.stringify(o, t)
        }
        stringify(t, e = {}) {
          const n = this.toView(t, e)
          return this.processor.toData(n)
        }
        toView(t, e = {}) {
          const n = this.viewDocument
          const o = this._viewWriter
          this.mapper.clearBindings()
          const r = Sk._createIn(t)
          const i = new Pp(n)
          this.mapper.bindElements(t, i)
          const s = t.is("documentFragment") ? t.markers : Xw(t)
          this.downcastDispatcher.convert(r, s, o, e)
          return i
        }
        init(t) {
          if (this.model.document.version) {
            throw new P("datacontroller-init-document-not-empty", this)
          }
          let e = {}
          if (typeof t === "string") {
            e.main = t
          } else {
            e = t
          }
          if (!this._checkIfRootsExists(Object.keys(e))) {
            throw new P("datacontroller-init-non-existent-root", this)
          }
          this.model.enqueueChange({ isUndoable: false }, (t) => {
            for (const n of Object.keys(e)) {
              const o = this.model.document.getRoot(n)
              t.insert(this.parse(e[n], o), o, 0)
            }
          })
          return Promise.resolve()
        }
        set(t, e = {}) {
          let n = {}
          if (typeof t === "string") {
            n.main = t
          } else {
            n = t
          }
          if (!this._checkIfRootsExists(Object.keys(n))) {
            throw new P("datacontroller-set-non-existent-root", this)
          }
          this.model.enqueueChange(e.batchType || {}, (t) => {
            t.setSelection(null)
            t.removeSelectionAttribute(this.model.document.selection.getAttributeKeys())
            for (const e of Object.keys(n)) {
              const o = this.model.document.getRoot(e)
              t.remove(t.createRangeIn(o))
              t.insert(this.parse(n[e], o), o, 0)
            }
          })
        }
        parse(t, e = "$root") {
          const n = this.processor.toView(t)
          return this.toModel(n, e)
        }
        toModel(t, e = "$root") {
          return this.model.change((n) => this.upcastDispatcher.convert(t, n, e))
        }
        addStyleProcessorRules(t) {
          t(this.stylesProcessor)
        }
        registerRawContentMatcher(t) {
          if (this.processor && this.processor !== this.htmlProcessor) {
            this.processor.registerRawContentMatcher(t)
          }
          this.htmlProcessor.registerRawContentMatcher(t)
        }
        destroy() {
          this.stopListening()
        }
        _checkIfRootsExists(t) {
          for (const e of t) {
            if (!this.model.document.getRoot(e)) {
              return false
            }
          }
          return true
        }
      }
      function Xw(t) {
        const e = []
        const n = t.root.document
        if (!n) {
          return new Map()
        }
        const o = Sk._createIn(t)
        for (const t of n.model.markers) {
          const n = t.getRange()
          const r = n.isCollapsed
          const i = n.start.isEqual(o.start) || n.end.isEqual(o.end)
          if (r && i) {
            e.push([t.name, n])
          } else {
            const r = o.getIntersection(n)
            if (r) {
              e.push([t.name, r])
            }
          }
        }
        e.sort(([t, e], [n, o]) => {
          if (e.end.compareWith(o.start) !== "after") {
            return 1
          } else if (e.start.compareWith(o.end) !== "before") {
            return -1
          } else {
            switch (e.start.compareWith(o.start)) {
              case "before":
                return 1
              case "after":
                return -1
              default:
                switch (e.end.compareWith(o.end)) {
                  case "before":
                    return 1
                  case "after":
                    return -1
                  default:
                    return n.localeCompare(t)
                }
            }
          }
        })
        return new Map(e)
      }
      class t_ {
        constructor(t, e) {
          this._helpers = new Map()
          this._downcast = tl(t)
          this._createConversionHelpers({
            name: "downcast",
            dispatchers: this._downcast,
            isDowncast: true,
          })
          this._upcast = tl(e)
          this._createConversionHelpers({
            name: "upcast",
            dispatchers: this._upcast,
            isDowncast: false,
          })
        }
        addAlias(t, e) {
          const n = this._downcast.includes(e)
          const o = this._upcast.includes(e)
          if (!o && !n) {
            throw new P("conversion-add-alias-dispatcher-not-registered", this)
          }
          this._createConversionHelpers({ name: t, dispatchers: [e], isDowncast: n })
        }
        for(t) {
          if (!this._helpers.has(t)) {
            throw new P("conversion-for-unknown-group", this)
          }
          return this._helpers.get(t)
        }
        elementToElement(t) {
          this.for("downcast").elementToElement(t)
          for (const { model: e, view: n } of e_(t)) {
            this.for("upcast").elementToElement({
              model: e,
              view: n,
              converterPriority: t.converterPriority,
            })
          }
        }
        attributeToElement(t) {
          this.for("downcast").attributeToElement(t)
          for (const { model: e, view: n } of e_(t)) {
            this.for("upcast").elementToAttribute({
              view: n,
              model: e,
              converterPriority: t.converterPriority,
            })
          }
        }
        attributeToAttribute(t) {
          this.for("downcast").attributeToAttribute(t)
          for (const { model: e, view: n } of e_(t)) {
            this.for("upcast").attributeToAttribute({ view: n, model: e })
          }
        }
        _createConversionHelpers({ name: t, dispatchers: e, isDowncast: n }) {
          if (this._helpers.has(t)) {
            throw new P("conversion-group-exists", this)
          }
          const o = n ? new tb(e) : new Gb(e)
          this._helpers.set(t, o)
        }
      }
      function* e_(t) {
        if (t.model.values) {
          for (const e of t.model.values) {
            const n = { key: t.model.key, value: e }
            const o = t.view[e]
            const r = t.upcastAlso ? t.upcastAlso[e] : undefined
            yield* n_(n, o, r)
          }
        } else {
          yield* n_(t.model, t.view, t.upcastAlso)
        }
      }
      function* n_(t, e, n) {
        yield { model: t, view: e }
        if (n) {
          for (const e of tl(n)) {
            yield { model: t, view: e }
          }
        }
      }
      class o_ {
        constructor(t) {
          this.baseVersion = t
          this.isDocumentOperation = this.baseVersion !== null
          this.batch = null
        }
        _validate() {}
        toJSON() {
          const t = Object.assign({}, this)
          t.__className = this.constructor.className
          delete t.batch
          delete t.isDocumentOperation
          return t
        }
        static get className() {
          return "Operation"
        }
        static fromJSON(t, e) {
          return new this(t.baseVersion)
        }
      }
      function r_(t, e) {
        const n = c_(e)
        const o = n.reduce((t, e) => t + e.offsetSize, 0)
        const r = t.parent
        d_(t)
        const i = t.index
        r._insertChild(i, n)
        l_(r, i + n.length)
        l_(r, i)
        return new Sk(t, t.getShiftedBy(o))
      }
      function i_(t) {
        if (!t.isFlat) {
          throw new P("operation-utils-remove-range-not-flat", this)
        }
        const e = t.start.parent
        d_(t.start)
        d_(t.end)
        const n = e._removeChildren(t.start.index, t.end.index - t.start.index)
        l_(e, t.start.index)
        return n
      }
      function s_(t, e) {
        if (!t.isFlat) {
          throw new P("operation-utils-move-range-not-flat", this)
        }
        const n = i_(t)
        e = e._getTransformedByDeletion(t.start, t.end.offset - t.start.offset)
        return r_(e, n)
      }
      function a_(t, e, n) {
        d_(t.start)
        d_(t.end)
        for (const o of t.getItems({ shallow: true })) {
          const t = o.is("$textProxy") ? o.textNode : o
          if (n !== null) {
            t._setAttribute(e, n)
          } else {
            t._removeAttribute(e)
          }
          l_(t.parent, t.index)
        }
        l_(t.end.parent, t.end.index)
      }
      function c_(t) {
        const e = []
        function n(t) {
          if (typeof t == "string") {
            e.push(new gk(t))
          } else if (t instanceof mk) {
            e.push(new gk(t.data, t.getAttributes()))
          } else if (t instanceof fk) {
            e.push(t)
          } else if (yt(t)) {
            for (const e of t) {
              n(e)
            }
          }
        }
        n(t)
        for (let t = 1; t < e.length; t++) {
          const n = e[t]
          const o = e[t - 1]
          if (n instanceof gk && o instanceof gk && h_(n, o)) {
            e.splice(t - 1, 2, new gk(o.data + n.data, o.getAttributes()))
            t--
          }
        }
        return e
      }
      function l_(t, e) {
        const n = t.getChild(e - 1)
        const o = t.getChild(e)
        if (n && o && n.is("$text") && o.is("$text") && h_(n, o)) {
          const r = new gk(n.data + o.data, n.getAttributes())
          t._removeChildren(e - 1, 2)
          t._insertChild(e - 1, r)
        }
      }
      function d_(t) {
        const e = t.textNode
        const n = t.parent
        if (e) {
          const o = t.offset - e.startOffset
          const r = e.index
          n._removeChildren(r, 1)
          const i = new gk(e.data.substr(0, o), e.getAttributes())
          const s = new gk(e.data.substr(o), e.getAttributes())
          n._insertChild(r, [i, s])
        }
      }
      function h_(t, e) {
        const n = t.getAttributes()
        const o = e.getAttributes()
        for (const t of n) {
          if (t[1] !== e.getAttribute(t[0])) {
            return false
          }
          o.next()
        }
        return o.next().done
      }
      class u_ extends o_ {
        constructor(t, e, n, o) {
          super(o)
          this.sourcePosition = t.clone()
          this.sourcePosition.stickiness = "toNext"
          this.howMany = e
          this.targetPosition = n.clone()
          this.targetPosition.stickiness = "toNone"
        }
        get type() {
          if (this.targetPosition.root.rootName == "$graveyard") {
            return "remove"
          } else if (this.sourcePosition.root.rootName == "$graveyard") {
            return "reinsert"
          }
          return "move"
        }
        get affectedSelectable() {
          return [
            Sk._createFromPositionAndShift(this.sourcePosition, this.howMany),
            Sk._createFromPositionAndShift(this.targetPosition, 0),
          ]
        }
        clone() {
          return new u_(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion)
        }
        getMovedRangeStart() {
          return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany)
        }
        getReversed() {
          const t = this.sourcePosition._getTransformedByInsertion(
            this.targetPosition,
            this.howMany
          )
          return new u_(this.getMovedRangeStart(), this.howMany, t, this.baseVersion + 1)
        }
        _validate() {
          const t = this.sourcePosition.parent
          const e = this.targetPosition.parent
          const n = this.sourcePosition.offset
          const o = this.targetPosition.offset
          if (n + this.howMany > t.maxOffset) {
            throw new P("move-operation-nodes-do-not-exist", this)
          } else if (t === e && n < o && o < n + this.howMany) {
            throw new P("move-operation-range-into-itself", this)
          } else if (this.sourcePosition.root == this.targetPosition.root) {
            if (
              Ct(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) ==
              "prefix"
            ) {
              const t = this.sourcePosition.path.length - 1
              if (
                this.targetPosition.path[t] >= n &&
                this.targetPosition.path[t] < n + this.howMany
              ) {
                throw new P("move-operation-node-into-itself", this)
              }
            }
          }
        }
        _execute() {
          s_(Sk._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition)
        }
        toJSON() {
          const t = super.toJSON()
          t.sourcePosition = this.sourcePosition.toJSON()
          t.targetPosition = this.targetPosition.toJSON()
          return t
        }
        static get className() {
          return "MoveOperation"
        }
        static fromJSON(t, e) {
          const n = vk.fromJSON(t.sourcePosition, e)
          const o = vk.fromJSON(t.targetPosition, e)
          return new this(n, t.howMany, o, t.baseVersion)
        }
      }
      class f_ extends o_ {
        constructor(t, e, n) {
          super(n)
          this.position = t.clone()
          this.position.stickiness = "toNone"
          this.nodes = new pk(c_(e))
          this.shouldReceiveAttributes = false
        }
        get type() {
          return "insert"
        }
        get howMany() {
          return this.nodes.maxOffset
        }
        get affectedSelectable() {
          return this.position.clone()
        }
        clone() {
          const t = new pk([...this.nodes].map((t) => t._clone(true)))
          const e = new f_(this.position, t, this.baseVersion)
          e.shouldReceiveAttributes = this.shouldReceiveAttributes
          return e
        }
        getReversed() {
          const t = this.position.root.document.graveyard
          const e = new vk(t, [0])
          return new u_(this.position, this.nodes.maxOffset, e, this.baseVersion + 1)
        }
        _validate() {
          const t = this.position.parent
          if (!t || t.maxOffset < this.position.offset) {
            throw new P("insert-operation-position-invalid", this)
          }
        }
        _execute() {
          const t = this.nodes
          this.nodes = new pk([...t].map((t) => t._clone(true)))
          r_(this.position, t)
        }
        toJSON() {
          const t = super.toJSON()
          t.position = this.position.toJSON()
          t.nodes = this.nodes.toJSON()
          return t
        }
        static get className() {
          return "InsertOperation"
        }
        static fromJSON(t, e) {
          const n = []
          for (const e of t.nodes) {
            if (e.name) {
              n.push(kk.fromJSON(e))
            } else {
              n.push(gk.fromJSON(e))
            }
          }
          const o = new f_(vk.fromJSON(t.position, e), n, t.baseVersion)
          o.shouldReceiveAttributes = t.shouldReceiveAttributes
          return o
        }
      }
      class p_ extends o_ {
        constructor(t, e, n, o, r) {
          super(r)
          this.splitPosition = t.clone()
          this.splitPosition.stickiness = "toNext"
          this.howMany = e
          this.insertionPosition = n
          this.graveyardPosition = o ? o.clone() : null
          if (this.graveyardPosition) {
            this.graveyardPosition.stickiness = "toNext"
          }
        }
        get type() {
          return "split"
        }
        get moveTargetPosition() {
          const t = this.insertionPosition.path.slice()
          t.push(0)
          return new vk(this.insertionPosition.root, t)
        }
        get movedRange() {
          const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY)
          return new Sk(this.splitPosition, t)
        }
        get affectedSelectable() {
          const t = [
            Sk._createFromPositionAndShift(this.splitPosition, 0),
            Sk._createFromPositionAndShift(this.insertionPosition, 0),
          ]
          if (this.graveyardPosition) {
            t.push(Sk._createFromPositionAndShift(this.graveyardPosition, 0))
          }
          return t
        }
        clone() {
          return new p_(
            this.splitPosition,
            this.howMany,
            this.insertionPosition,
            this.graveyardPosition,
            this.baseVersion
          )
        }
        getReversed() {
          const t = this.splitPosition.root.document.graveyard
          const e = new vk(t, [0])
          return new g_(
            this.moveTargetPosition,
            this.howMany,
            this.splitPosition,
            e,
            this.baseVersion + 1
          )
        }
        _validate() {
          const t = this.splitPosition.parent
          const e = this.splitPosition.offset
          if (!t || t.maxOffset < e) {
            throw new P("split-operation-position-invalid", this)
          } else if (!t.parent) {
            throw new P("split-operation-split-in-root", this)
          } else if (this.howMany != t.maxOffset - this.splitPosition.offset) {
            throw new P("split-operation-how-many-invalid", this)
          } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {
            throw new P("split-operation-graveyard-position-invalid", this)
          }
        }
        _execute() {
          const t = this.splitPosition.parent
          if (this.graveyardPosition) {
            s_(Sk._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition)
          } else {
            const e = t._clone()
            r_(this.insertionPosition, e)
          }
          const e = new Sk(vk._createAt(t, this.splitPosition.offset), vk._createAt(t, t.maxOffset))
          s_(e, this.moveTargetPosition)
        }
        toJSON() {
          const t = super.toJSON()
          t.splitPosition = this.splitPosition.toJSON()
          t.insertionPosition = this.insertionPosition.toJSON()
          if (this.graveyardPosition) {
            t.graveyardPosition = this.graveyardPosition.toJSON()
          }
          return t
        }
        static get className() {
          return "SplitOperation"
        }
        static getInsertionPosition(t) {
          const e = t.path.slice(0, -1)
          e[e.length - 1]++
          return new vk(t.root, e, "toPrevious")
        }
        static fromJSON(t, e) {
          const n = vk.fromJSON(t.splitPosition, e)
          const o = vk.fromJSON(t.insertionPosition, e)
          const r = t.graveyardPosition ? vk.fromJSON(t.graveyardPosition, e) : null
          return new this(n, t.howMany, o, r, t.baseVersion)
        }
      }
      class g_ extends o_ {
        constructor(t, e, n, o, r) {
          super(r)
          this.sourcePosition = t.clone()
          this.sourcePosition.stickiness = "toPrevious"
          this.howMany = e
          this.targetPosition = n.clone()
          this.targetPosition.stickiness = "toNext"
          this.graveyardPosition = o.clone()
        }
        get type() {
          return "merge"
        }
        get deletionPosition() {
          return new vk(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1))
        }
        get movedRange() {
          const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY)
          return new Sk(this.sourcePosition, t)
        }
        get affectedSelectable() {
          const t = this.sourcePosition.parent
          return [
            Sk._createOn(t),
            Sk._createFromPositionAndShift(this.targetPosition, 0),
            Sk._createFromPositionAndShift(this.graveyardPosition, 0),
          ]
        }
        clone() {
          return new g_(
            this.sourcePosition,
            this.howMany,
            this.targetPosition,
            this.graveyardPosition,
            this.baseVersion
          )
        }
        getReversed() {
          const t = this.targetPosition._getTransformedByMergeOperation(this)
          const e = this.sourcePosition.path.slice(0, -1)
          const n = new vk(this.sourcePosition.root, e)._getTransformedByMergeOperation(this)
          return new p_(t, this.howMany, n, this.graveyardPosition, this.baseVersion + 1)
        }
        _validate() {
          const t = this.sourcePosition.parent
          const e = this.targetPosition.parent
          if (!t.parent) {
            throw new P("merge-operation-source-position-invalid", this)
          } else if (!e.parent) {
            throw new P("merge-operation-target-position-invalid", this)
          } else if (this.howMany != t.maxOffset) {
            throw new P("merge-operation-how-many-invalid", this)
          }
        }
        _execute() {
          const t = this.sourcePosition.parent
          const e = Sk._createIn(t)
          s_(e, this.targetPosition)
          s_(Sk._createOn(t), this.graveyardPosition)
        }
        toJSON() {
          const t = super.toJSON()
          t.sourcePosition = t.sourcePosition.toJSON()
          t.targetPosition = t.targetPosition.toJSON()
          t.graveyardPosition = t.graveyardPosition.toJSON()
          return t
        }
        static get className() {
          return "MergeOperation"
        }
        static fromJSON(t, e) {
          const n = vk.fromJSON(t.sourcePosition, e)
          const o = vk.fromJSON(t.targetPosition, e)
          const r = vk.fromJSON(t.graveyardPosition, e)
          return new this(n, t.howMany, o, r, t.baseVersion)
        }
      }
      class m_ extends o_ {
        constructor(t, e, n, o, r, i) {
          super(i)
          this.name = t
          this.oldRange = e ? e.clone() : null
          this.newRange = n ? n.clone() : null
          this.affectsData = r
          this._markers = o
        }
        get type() {
          return "marker"
        }
        get affectedSelectable() {
          const t = []
          if (this.oldRange) {
            t.push(this.oldRange.clone())
          }
          if (this.newRange) {
            if (this.oldRange) {
              t.push(...this.newRange.getDifference(this.oldRange))
            } else {
              t.push(this.newRange.clone())
            }
          }
          return t
        }
        clone() {
          return new m_(
            this.name,
            this.oldRange,
            this.newRange,
            this._markers,
            this.affectsData,
            this.baseVersion
          )
        }
        getReversed() {
          return new m_(
            this.name,
            this.newRange,
            this.oldRange,
            this._markers,
            this.affectsData,
            this.baseVersion + 1
          )
        }
        _execute() {
          if (this.newRange) {
            this._markers._set(this.name, this.newRange, true, this.affectsData)
          } else {
            this._markers._remove(this.name)
          }
        }
        toJSON() {
          const t = super.toJSON()
          if (this.oldRange) {
            t.oldRange = this.oldRange.toJSON()
          }
          if (this.newRange) {
            t.newRange = this.newRange.toJSON()
          }
          delete t._markers
          return t
        }
        static get className() {
          return "MarkerOperation"
        }
        static fromJSON(t, e) {
          return new m_(
            t.name,
            t.oldRange ? Sk.fromJSON(t.oldRange, e) : null,
            t.newRange ? Sk.fromJSON(t.newRange, e) : null,
            e.model.markers,
            t.affectsData,
            t.baseVersion
          )
        }
      }
      function k_(t, e) {
        return Um(t, e)
      }
      const b_ = k_
      class w_ extends o_ {
        constructor(t, e, n, o, r) {
          super(r)
          this.range = t.clone()
          this.key = e
          this.oldValue = n === undefined ? null : n
          this.newValue = o === undefined ? null : o
        }
        get type() {
          if (this.oldValue === null) {
            return "addAttribute"
          } else if (this.newValue === null) {
            return "removeAttribute"
          } else {
            return "changeAttribute"
          }
        }
        get affectedSelectable() {
          return this.range.clone()
        }
        clone() {
          return new w_(this.range, this.key, this.oldValue, this.newValue, this.baseVersion)
        }
        getReversed() {
          return new w_(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
        }
        toJSON() {
          const t = super.toJSON()
          t.range = this.range.toJSON()
          return t
        }
        _validate() {
          if (!this.range.isFlat) {
            throw new P("attribute-operation-range-not-flat", this)
          }
          for (const t of this.range.getItems({ shallow: true })) {
            if (this.oldValue !== null && !b_(t.getAttribute(this.key), this.oldValue)) {
              throw new P("attribute-operation-wrong-old-value", this, {
                item: t,
                key: this.key,
                value: this.oldValue,
              })
            }
            if (this.oldValue === null && this.newValue !== null && t.hasAttribute(this.key)) {
              throw new P("attribute-operation-attribute-exists", this, { node: t, key: this.key })
            }
          }
        }
        _execute() {
          if (!b_(this.oldValue, this.newValue)) {
            a_(this.range, this.key, this.newValue)
          }
        }
        static get className() {
          return "AttributeOperation"
        }
        static fromJSON(t, e) {
          return new w_(Sk.fromJSON(t.range, e), t.key, t.oldValue, t.newValue, t.baseVersion)
        }
      }
      class __ extends o_ {
        get type() {
          return "noop"
        }
        get affectedSelectable() {
          return null
        }
        clone() {
          return new __(this.baseVersion)
        }
        getReversed() {
          return new __(this.baseVersion + 1)
        }
        _execute() {}
        static get className() {
          return "NoOperation"
        }
      }
      class v_ extends o_ {
        constructor(t, e, n, o) {
          super(o)
          this.position = t
          this.position.stickiness = "toNext"
          this.oldName = e
          this.newName = n
        }
        get type() {
          return "rename"
        }
        get affectedSelectable() {
          return this.position.nodeAfter
        }
        clone() {
          return new v_(this.position.clone(), this.oldName, this.newName, this.baseVersion)
        }
        getReversed() {
          return new v_(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1)
        }
        _validate() {
          const t = this.position.nodeAfter
          if (!(t instanceof kk)) {
            throw new P("rename-operation-wrong-position", this)
          } else if (t.name !== this.oldName) {
            throw new P("rename-operation-wrong-name", this)
          }
        }
        _execute() {
          const t = this.position.nodeAfter
          t.name = this.newName
        }
        toJSON() {
          const t = super.toJSON()
          t.position = this.position.toJSON()
          return t
        }
        static get className() {
          return "RenameOperation"
        }
        static fromJSON(t, e) {
          return new v_(vk.fromJSON(t.position, e), t.oldName, t.newName, t.baseVersion)
        }
      }
      class A_ extends o_ {
        constructor(t, e, n, o, r) {
          super(r)
          this.root = t
          this.key = e
          this.oldValue = n === undefined ? null : n
          this.newValue = o === undefined ? null : o
        }
        get type() {
          if (this.oldValue === null) {
            return "addRootAttribute"
          } else if (this.newValue === null) {
            return "removeRootAttribute"
          } else {
            return "changeRootAttribute"
          }
        }
        get affectedSelectable() {
          return this.root
        }
        clone() {
          return new A_(this.root, this.key, this.oldValue, this.newValue, this.baseVersion)
        }
        getReversed() {
          return new A_(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
        }
        _validate() {
          if (this.root != this.root.root || this.root.is("documentFragment")) {
            throw new P("rootattribute-operation-not-a-root", this, {
              root: this.root,
              key: this.key,
            })
          }
          if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) {
            throw new P("rootattribute-operation-wrong-old-value", this, {
              root: this.root,
              key: this.key,
            })
          }
          if (
            this.oldValue === null &&
            this.newValue !== null &&
            this.root.hasAttribute(this.key)
          ) {
            throw new P("rootattribute-operation-attribute-exists", this, {
              root: this.root,
              key: this.key,
            })
          }
        }
        _execute() {
          if (this.newValue !== null) {
            this.root._setAttribute(this.key, this.newValue)
          } else {
            this.root._removeAttribute(this.key)
          }
        }
        toJSON() {
          const t = super.toJSON()
          t.root = this.root.toJSON()
          return t
        }
        static get className() {
          return "RootAttributeOperation"
        }
        static fromJSON(t, e) {
          if (!e.getRoot(t.root)) {
            throw new P("rootattribute-operation-fromjson-no-root", this, { rootName: t.root })
          }
          return new A_(e.getRoot(t.root), t.key, t.oldValue, t.newValue, t.baseVersion)
        }
      }
      class C_ extends o_ {
        constructor(t, e, n, o, r) {
          super(r)
          this.rootName = t
          this.elementName = e
          this.isAdd = n
          this._document = o
          if (!this._document.getRoot(this.rootName)) {
            const t = this._document.createRoot(this.elementName, this.rootName)
            t._isAttached = false
          }
        }
        get type() {
          return this.isAdd ? "addRoot" : "detachRoot"
        }
        get affectedSelectable() {
          return this._document.getRoot(this.rootName)
        }
        clone() {
          return new C_(
            this.rootName,
            this.elementName,
            this.isAdd,
            this._document,
            this.baseVersion
          )
        }
        getReversed() {
          return new C_(
            this.rootName,
            this.elementName,
            !this.isAdd,
            this._document,
            this.baseVersion + 1
          )
        }
        _validate() {
          const t = this._document.getRoot(this.rootName)
          if (t.isAttached() && this.isAdd) {
            throw new P("root-operation-root-attached", this)
          } else if (!t.isAttached() && !this.isAdd) {
            throw new P("root-operation-root-detached", this)
          }
        }
        _execute() {
          this._document.getRoot(this.rootName)._isAttached = this.isAdd
        }
        toJSON() {
          const t = super.toJSON()
          delete t._document
          return t
        }
        static get className() {
          return "RootOperation"
        }
        static fromJSON(t, e) {
          return new C_(t.rootName, t.elementName, t.isAdd, e, t.baseVersion)
        }
      }
      const y_ = {}
      y_[w_.className] = w_
      y_[f_.className] = f_
      y_[m_.className] = m_
      y_[u_.className] = u_
      y_[__.className] = __
      y_[o_.className] = o_
      y_[v_.className] = v_
      y_[A_.className] = A_
      y_[C_.className] = C_
      y_[p_.className] = p_
      y_[g_.className] = g_
      class x_ {
        static fromJSON(t, e) {
          return y_[t.__className].fromJSON(t, e)
        }
      }
      const E_ = new Map()
      function D_(t, e, n) {
        let o = E_.get(t)
        if (!o) {
          o = new Map()
          E_.set(t, o)
        }
        o.set(e, n)
      }
      function S_(t, e) {
        const n = E_.get(t)
        if (n && n.has(e)) {
          return n.get(e)
        }
        return T_
      }
      function T_(t) {
        return [t]
      }
      function P_(t, e, n = {}) {
        const o = S_(t.constructor, e.constructor)
        try {
          t = t.clone()
          return o(t, e, n)
        } catch (t) {
          throw t
        }
      }
      function B_(t, e, n) {
        t = t.slice()
        e = e.slice()
        const o = new R_(n.document, n.useRelations, n.forceWeakRemove)
        o.setOriginalOperations(t)
        o.setOriginalOperations(e)
        const r = o.originalOperations
        if (t.length == 0 || e.length == 0) {
          return { operationsA: t, operationsB: e, originalOperations: r }
        }
        const i = new WeakMap()
        for (const e of t) {
          i.set(e, 0)
        }
        const s = {
          nextBaseVersionA: t[t.length - 1].baseVersion + 1,
          nextBaseVersionB: e[e.length - 1].baseVersion + 1,
          originalOperationsACount: t.length,
          originalOperationsBCount: e.length,
        }
        let a = 0
        while (a < t.length) {
          const n = t[a]
          const r = i.get(n)
          if (r == e.length) {
            a++
            continue
          }
          const s = e[r]
          const c = P_(n, s, o.getContext(n, s, true))
          const l = P_(s, n, o.getContext(s, n, false))
          o.updateRelation(n, s)
          o.setOriginalOperations(c, n)
          o.setOriginalOperations(l, s)
          for (const t of c) {
            i.set(t, r + l.length)
          }
          t.splice(a, 1, ...c)
          e.splice(r, 1, ...l)
        }
        if (n.padWithNoOps) {
          const n = t.length - s.originalOperationsACount
          const o = e.length - s.originalOperationsBCount
          M_(t, o - n)
          M_(e, n - o)
        }
        O_(t, s.nextBaseVersionB)
        O_(e, s.nextBaseVersionA)
        return { operationsA: t, operationsB: e, originalOperations: r }
      }
      class R_ {
        constructor(t, e, n = false) {
          this.originalOperations = new Map()
          this._history = t.history
          this._useRelations = e
          this._forceWeakRemove = !!n
          this._relations = new Map()
        }
        setOriginalOperations(t, e = null) {
          const n = e ? this.originalOperations.get(e) : null
          for (const e of t) {
            this.originalOperations.set(e, n || e)
          }
        }
        updateRelation(t, e) {
          if (t instanceof u_) {
            if (e instanceof g_) {
              if (
                t.targetPosition.isEqual(e.sourcePosition) ||
                e.movedRange.containsPosition(t.targetPosition)
              ) {
                this._setRelation(t, e, "insertAtSource")
              } else if (t.targetPosition.isEqual(e.deletionPosition)) {
                this._setRelation(t, e, "insertBetween")
              } else if (t.targetPosition.isAfter(e.sourcePosition)) {
                this._setRelation(t, e, "moveTargetAfter")
              }
            } else if (e instanceof u_) {
              if (
                t.targetPosition.isEqual(e.sourcePosition) ||
                t.targetPosition.isBefore(e.sourcePosition)
              ) {
                this._setRelation(t, e, "insertBefore")
              } else {
                this._setRelation(t, e, "insertAfter")
              }
            }
          } else if (t instanceof p_) {
            if (e instanceof g_) {
              if (t.splitPosition.isBefore(e.sourcePosition)) {
                this._setRelation(t, e, "splitBefore")
              }
            } else if (e instanceof u_) {
              if (
                t.splitPosition.isEqual(e.sourcePosition) ||
                t.splitPosition.isBefore(e.sourcePosition)
              ) {
                this._setRelation(t, e, "splitBefore")
              } else {
                const n = Sk._createFromPositionAndShift(e.sourcePosition, e.howMany)
                if (
                  t.splitPosition.hasSameParentAs(e.sourcePosition) &&
                  n.containsPosition(t.splitPosition)
                ) {
                  const o = n.end.offset - t.splitPosition.offset
                  const r = t.splitPosition.offset - n.start.offset
                  this._setRelation(t, e, { howMany: o, offset: r })
                }
              }
            }
          } else if (t instanceof g_) {
            if (e instanceof g_) {
              if (!t.targetPosition.isEqual(e.sourcePosition)) {
                this._setRelation(t, e, "mergeTargetNotMoved")
              }
              if (t.sourcePosition.isEqual(e.targetPosition)) {
                this._setRelation(t, e, "mergeSourceNotMoved")
              }
              if (t.sourcePosition.isEqual(e.sourcePosition)) {
                this._setRelation(t, e, "mergeSameElement")
              }
            } else if (e instanceof p_) {
              if (t.sourcePosition.isEqual(e.splitPosition)) {
                this._setRelation(t, e, "splitAtSource")
              }
            }
          } else if (t instanceof m_) {
            const n = t.newRange
            if (!n) {
              return
            }
            if (e instanceof u_) {
              const o = Sk._createFromPositionAndShift(e.sourcePosition, e.howMany)
              const r = o.containsPosition(n.start) || o.start.isEqual(n.start)
              const i = o.containsPosition(n.end) || o.end.isEqual(n.end)
              if ((r || i) && !o.containsRange(n)) {
                this._setRelation(t, e, {
                  side: r ? "left" : "right",
                  path: r ? n.start.path.slice() : n.end.path.slice(),
                })
              }
            } else if (e instanceof g_) {
              const o = n.start.isEqual(e.targetPosition)
              const r = n.start.isEqual(e.deletionPosition)
              const i = n.end.isEqual(e.deletionPosition)
              const s = n.end.isEqual(e.sourcePosition)
              if (o || r || i || s) {
                this._setRelation(t, e, {
                  wasInLeftElement: o,
                  wasStartBeforeMergedElement: r,
                  wasEndBeforeMergedElement: i,
                  wasInRightElement: s,
                })
              }
            }
          }
        }
        getContext(t, e, n) {
          return {
            aIsStrong: n,
            aWasUndone: this._wasUndone(t),
            bWasUndone: this._wasUndone(e),
            abRelation: this._useRelations ? this._getRelation(t, e) : null,
            baRelation: this._useRelations ? this._getRelation(e, t) : null,
            forceWeakRemove: this._forceWeakRemove,
          }
        }
        _wasUndone(t) {
          const e = this.originalOperations.get(t)
          return e.wasUndone || this._history.isUndoneOperation(e)
        }
        _getRelation(t, e) {
          const n = this.originalOperations.get(e)
          const o = this._history.getUndoneOperation(n)
          if (!o) {
            return null
          }
          const r = this.originalOperations.get(t)
          const i = this._relations.get(r)
          if (i) {
            return i.get(o) || null
          }
          return null
        }
        _setRelation(t, e, n) {
          const o = this.originalOperations.get(t)
          const r = this.originalOperations.get(e)
          let i = this._relations.get(o)
          if (!i) {
            i = new Map()
            this._relations.set(o, i)
          }
          i.set(r, n)
        }
      }
      function O_(t, e) {
        for (const n of t) {
          n.baseVersion = e++
        }
      }
      function M_(t, e) {
        for (let n = 0; n < e; n++) {
          t.push(new __(0))
        }
      }
      D_(w_, w_, (t, e, n) => {
        if (t.key === e.key && t.range.start.hasSameParentAs(e.range.start)) {
          const o = t.range
            .getDifference(e.range)
            .map((e) => new w_(e, t.key, t.oldValue, t.newValue, 0))
          const r = t.range.getIntersection(e.range)
          if (r) {
            if (n.aIsStrong) {
              o.push(new w_(r, e.key, e.newValue, t.newValue, 0))
            }
          }
          if (o.length == 0) {
            return [new __(0)]
          }
          return o
        } else {
          return [t]
        }
      })
      D_(w_, f_, (t, e) => {
        if (t.range.start.hasSameParentAs(e.position) && t.range.containsPosition(e.position)) {
          const n = t.range._getTransformedByInsertion(
            e.position,
            e.howMany,
            !e.shouldReceiveAttributes
          )
          const o = n.map((e) => new w_(e, t.key, t.oldValue, t.newValue, t.baseVersion))
          if (e.shouldReceiveAttributes) {
            const n = I_(e, t.key, t.oldValue)
            if (n) {
              o.unshift(n)
            }
          }
          return o
        }
        t.range = t.range._getTransformedByInsertion(e.position, e.howMany, false)[0]
        return [t]
      })
      function I_(t, e, n) {
        const o = t.nodes
        const r = o.getNode(0).getAttribute(e)
        if (r == n) {
          return null
        }
        const i = new Sk(t.position, t.position.getShiftedBy(t.howMany))
        return new w_(i, e, r, n, 0)
      }
      D_(w_, g_, (t, e) => {
        const n = []
        if (t.range.start.hasSameParentAs(e.deletionPosition)) {
          if (
            t.range.containsPosition(e.deletionPosition) ||
            t.range.start.isEqual(e.deletionPosition)
          ) {
            n.push(Sk._createFromPositionAndShift(e.graveyardPosition, 1))
          }
        }
        const o = t.range._getTransformedByMergeOperation(e)
        if (!o.isCollapsed) {
          n.push(o)
        }
        return n.map((e) => new w_(e, t.key, t.oldValue, t.newValue, t.baseVersion))
      })
      D_(w_, u_, (t, e) => {
        const n = z_(t.range, e)
        return n.map((e) => new w_(e, t.key, t.oldValue, t.newValue, t.baseVersion))
      })
      function z_(t, e) {
        const n = Sk._createFromPositionAndShift(e.sourcePosition, e.howMany)
        let o = null
        let r = []
        if (n.containsRange(t, true)) {
          o = t
        } else if (t.start.hasSameParentAs(n.start)) {
          r = t.getDifference(n)
          o = t.getIntersection(n)
        } else {
          r = [t]
        }
        const i = []
        for (let t of r) {
          t = t._getTransformedByDeletion(e.sourcePosition, e.howMany)
          const n = e.getMovedRangeStart()
          const o = t.start.hasSameParentAs(n)
          const r = t._getTransformedByInsertion(n, e.howMany, o)
          i.push(...r)
        }
        if (o) {
          i.push(o._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany, false)[0])
        }
        return i
      }
      D_(w_, p_, (t, e) => {
        if (t.range.end.isEqual(e.insertionPosition)) {
          if (!e.graveyardPosition) {
            t.range.end.offset++
          }
          return [t]
        }
        if (
          t.range.start.hasSameParentAs(e.splitPosition) &&
          t.range.containsPosition(e.splitPosition)
        ) {
          const n = t.clone()
          n.range = new Sk(
            e.moveTargetPosition.clone(),
            t.range.end._getCombined(e.splitPosition, e.moveTargetPosition)
          )
          t.range.end = e.splitPosition.clone()
          t.range.end.stickiness = "toPrevious"
          return [t, n]
        }
        t.range = t.range._getTransformedBySplitOperation(e)
        return [t]
      })
      D_(f_, w_, (t, e) => {
        const n = [t]
        if (
          t.shouldReceiveAttributes &&
          t.position.hasSameParentAs(e.range.start) &&
          e.range.containsPosition(t.position)
        ) {
          const o = I_(t, e.key, e.newValue)
          if (o) {
            n.push(o)
          }
        }
        return n
      })
      D_(f_, f_, (t, e, n) => {
        if (t.position.isEqual(e.position) && n.aIsStrong) {
          return [t]
        }
        t.position = t.position._getTransformedByInsertOperation(e)
        return [t]
      })
      D_(f_, u_, (t, e) => {
        t.position = t.position._getTransformedByMoveOperation(e)
        return [t]
      })
      D_(f_, p_, (t, e) => {
        t.position = t.position._getTransformedBySplitOperation(e)
        return [t]
      })
      D_(f_, g_, (t, e) => {
        t.position = t.position._getTransformedByMergeOperation(e)
        return [t]
      })
      D_(m_, f_, (t, e) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedByInsertOperation(e)[0]
        }
        if (t.newRange) {
          t.newRange = t.newRange._getTransformedByInsertOperation(e)[0]
        }
        return [t]
      })
      D_(m_, m_, (t, e, n) => {
        if (t.name == e.name) {
          if (n.aIsStrong) {
            t.oldRange = e.newRange ? e.newRange.clone() : null
          } else {
            return [new __(0)]
          }
        }
        return [t]
      })
      D_(m_, g_, (t, e) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedByMergeOperation(e)
        }
        if (t.newRange) {
          t.newRange = t.newRange._getTransformedByMergeOperation(e)
        }
        return [t]
      })
      D_(m_, u_, (t, e, n) => {
        if (t.oldRange) {
          t.oldRange = Sk._createFromRanges(t.oldRange._getTransformedByMoveOperation(e))
        }
        if (t.newRange) {
          if (n.abRelation) {
            const o = Sk._createFromRanges(t.newRange._getTransformedByMoveOperation(e))
            if (n.abRelation.side == "left" && e.targetPosition.isEqual(t.newRange.start)) {
              t.newRange.end = o.end
              t.newRange.start.path = n.abRelation.path
              return [t]
            } else if (n.abRelation.side == "right" && e.targetPosition.isEqual(t.newRange.end)) {
              t.newRange.start = o.start
              t.newRange.end.path = n.abRelation.path
              return [t]
            }
          }
          t.newRange = Sk._createFromRanges(t.newRange._getTransformedByMoveOperation(e))
        }
        return [t]
      })
      D_(m_, p_, (t, e, n) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedBySplitOperation(e)
        }
        if (t.newRange) {
          if (n.abRelation) {
            const o = t.newRange._getTransformedBySplitOperation(e)
            if (
              t.newRange.start.isEqual(e.splitPosition) &&
              n.abRelation.wasStartBeforeMergedElement
            ) {
              t.newRange.start = vk._createAt(e.insertionPosition)
            } else if (
              t.newRange.start.isEqual(e.splitPosition) &&
              !n.abRelation.wasInLeftElement
            ) {
              t.newRange.start = vk._createAt(e.moveTargetPosition)
            }
            if (t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasInRightElement) {
              t.newRange.end = vk._createAt(e.moveTargetPosition)
            } else if (
              t.newRange.end.isEqual(e.splitPosition) &&
              n.abRelation.wasEndBeforeMergedElement
            ) {
              t.newRange.end = vk._createAt(e.insertionPosition)
            } else {
              t.newRange.end = o.end
            }
            return [t]
          }
          t.newRange = t.newRange._getTransformedBySplitOperation(e)
        }
        return [t]
      })
      D_(g_, f_, (t, e) => {
        if (t.sourcePosition.hasSameParentAs(e.position)) {
          t.howMany += e.howMany
        }
        t.sourcePosition = t.sourcePosition._getTransformedByInsertOperation(e)
        t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e)
        return [t]
      })
      D_(g_, g_, (t, e, n) => {
        if (
          t.sourcePosition.isEqual(e.sourcePosition) &&
          t.targetPosition.isEqual(e.targetPosition)
        ) {
          if (!n.bWasUndone) {
            return [new __(0)]
          } else {
            const n = e.graveyardPosition.path.slice()
            n.push(0)
            t.sourcePosition = new vk(e.graveyardPosition.root, n)
            t.howMany = 0
            return [t]
          }
        }
        if (
          t.sourcePosition.isEqual(e.sourcePosition) &&
          !t.targetPosition.isEqual(e.targetPosition) &&
          !n.bWasUndone &&
          n.abRelation != "splitAtSource"
        ) {
          const o = t.targetPosition.root.rootName == "$graveyard"
          const r = e.targetPosition.root.rootName == "$graveyard"
          const i = o && !r
          const s = r && !o
          const a = s || (!i && n.aIsStrong)
          if (a) {
            const n = e.targetPosition._getTransformedByMergeOperation(e)
            const o = t.targetPosition._getTransformedByMergeOperation(e)
            return [new u_(n, t.howMany, o, 0)]
          } else {
            return [new __(0)]
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany
        }
        t.sourcePosition = t.sourcePosition._getTransformedByMergeOperation(e)
        t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e)
        if (!t.graveyardPosition.isEqual(e.graveyardPosition) || !n.aIsStrong) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)
        }
        return [t]
      })
      D_(g_, u_, (t, e, n) => {
        const o = Sk._createFromPositionAndShift(e.sourcePosition, e.howMany)
        if (e.type == "remove" && !n.bWasUndone && !n.forceWeakRemove) {
          if (
            t.deletionPosition.hasSameParentAs(e.sourcePosition) &&
            o.containsPosition(t.sourcePosition)
          ) {
            return [new __(0)]
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany
        }
        if (t.sourcePosition.hasSameParentAs(e.sourcePosition)) {
          t.howMany -= e.howMany
        }
        t.sourcePosition = t.sourcePosition._getTransformedByMoveOperation(e)
        t.targetPosition = t.targetPosition._getTransformedByMoveOperation(e)
        if (!t.graveyardPosition.isEqual(e.targetPosition)) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)
        }
        return [t]
      })
      D_(g_, p_, (t, e, n) => {
        if (e.graveyardPosition) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByDeletion(
            e.graveyardPosition,
            1
          )
          if (t.deletionPosition.isEqual(e.graveyardPosition)) {
            t.howMany = e.howMany
          }
        }
        if (t.targetPosition.isEqual(e.splitPosition)) {
          const o = e.howMany != 0
          const r = e.graveyardPosition && t.deletionPosition.isEqual(e.graveyardPosition)
          if (o || r || n.abRelation == "mergeTargetNotMoved") {
            t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e)
            return [t]
          }
        }
        if (t.sourcePosition.isEqual(e.splitPosition)) {
          if (n.abRelation == "mergeSourceNotMoved") {
            t.howMany = 0
            t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e)
            return [t]
          }
          if (n.abRelation == "mergeSameElement" || t.sourcePosition.offset > 0) {
            t.sourcePosition = e.moveTargetPosition.clone()
            t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e)
            return [t]
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.splitPosition)) {
          t.howMany = e.splitPosition.offset
        }
        t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e)
        t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e)
        return [t]
      })
      D_(u_, f_, (t, e) => {
        const n = Sk._createFromPositionAndShift(t.sourcePosition, t.howMany)
        const o = n._getTransformedByInsertOperation(e, false)[0]
        t.sourcePosition = o.start
        t.howMany = o.end.offset - o.start.offset
        if (!t.targetPosition.isEqual(e.position)) {
          t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e)
        }
        return [t]
      })
      D_(u_, u_, (t, e, n) => {
        const o = Sk._createFromPositionAndShift(t.sourcePosition, t.howMany)
        const r = Sk._createFromPositionAndShift(e.sourcePosition, e.howMany)
        let i = n.aIsStrong
        let s = !n.aIsStrong
        if (n.abRelation == "insertBefore" || n.baRelation == "insertAfter") {
          s = true
        } else if (n.abRelation == "insertAfter" || n.baRelation == "insertBefore") {
          s = false
        }
        let a
        if (t.targetPosition.isEqual(e.targetPosition) && s) {
          a = t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany)
        } else {
          a = t.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)
        }
        if (N_(t, e) && N_(e, t)) {
          return [e.getReversed()]
        }
        const c = o.containsPosition(e.targetPosition)
        if (c && o.containsRange(r, true)) {
          o.start = o.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)
          o.end = o.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)
          return F_([o], a)
        }
        const l = r.containsPosition(t.targetPosition)
        if (l && r.containsRange(o, true)) {
          o.start = o.start._getCombined(e.sourcePosition, e.getMovedRangeStart())
          o.end = o.end._getCombined(e.sourcePosition, e.getMovedRangeStart())
          return F_([o], a)
        }
        const d = Ct(t.sourcePosition.getParentPath(), e.sourcePosition.getParentPath())
        if (d == "prefix" || d == "extension") {
          o.start = o.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)
          o.end = o.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)
          return F_([o], a)
        }
        if (t.type == "remove" && e.type != "remove" && !n.aWasUndone && !n.forceWeakRemove) {
          i = true
        } else if (
          t.type != "remove" &&
          e.type == "remove" &&
          !n.bWasUndone &&
          !n.forceWeakRemove
        ) {
          i = false
        }
        const h = []
        const u = o.getDifference(r)
        for (const t of u) {
          t.start = t.start._getTransformedByDeletion(e.sourcePosition, e.howMany)
          t.end = t.end._getTransformedByDeletion(e.sourcePosition, e.howMany)
          const n = Ct(t.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == "same"
          const o = t._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, n)
          h.push(...o)
        }
        const f = o.getIntersection(r)
        if (f !== null && i) {
          f.start = f.start._getCombined(e.sourcePosition, e.getMovedRangeStart())
          f.end = f.end._getCombined(e.sourcePosition, e.getMovedRangeStart())
          if (h.length === 0) {
            h.push(f)
          } else if (h.length == 1) {
            if (r.start.isBefore(o.start) || r.start.isEqual(o.start)) {
              h.unshift(f)
            } else {
              h.push(f)
            }
          } else {
            h.splice(1, 0, f)
          }
        }
        if (h.length === 0) {
          return [new __(t.baseVersion)]
        }
        return F_(h, a)
      })
      D_(u_, p_, (t, e, n) => {
        let o = t.targetPosition.clone()
        if (
          !t.targetPosition.isEqual(e.insertionPosition) ||
          !e.graveyardPosition ||
          n.abRelation == "moveTargetAfter"
        ) {
          o = t.targetPosition._getTransformedBySplitOperation(e)
        }
        const r = Sk._createFromPositionAndShift(t.sourcePosition, t.howMany)
        if (r.end.isEqual(e.insertionPosition)) {
          if (!e.graveyardPosition) {
            t.howMany++
          }
          t.targetPosition = o
          return [t]
        }
        if (r.start.hasSameParentAs(e.splitPosition) && r.containsPosition(e.splitPosition)) {
          let t = new Sk(e.splitPosition, r.end)
          t = t._getTransformedBySplitOperation(e)
          const n = [new Sk(r.start, e.splitPosition), t]
          return F_(n, o)
        }
        if (t.targetPosition.isEqual(e.splitPosition) && n.abRelation == "insertAtSource") {
          o = e.moveTargetPosition
        }
        if (t.targetPosition.isEqual(e.insertionPosition) && n.abRelation == "insertBetween") {
          o = t.targetPosition
        }
        const i = r._getTransformedBySplitOperation(e)
        const s = [i]
        if (e.graveyardPosition) {
          const o = r.start.isEqual(e.graveyardPosition) || r.containsPosition(e.graveyardPosition)
          if (t.howMany > 1 && o && !n.aWasUndone) {
            s.push(Sk._createFromPositionAndShift(e.insertionPosition, 1))
          }
        }
        return F_(s, o)
      })
      D_(u_, g_, (t, e, n) => {
        const o = Sk._createFromPositionAndShift(t.sourcePosition, t.howMany)
        if (
          e.deletionPosition.hasSameParentAs(t.sourcePosition) &&
          o.containsPosition(e.sourcePosition)
        ) {
          if (t.type == "remove" && !n.forceWeakRemove) {
            if (!n.aWasUndone) {
              const n = []
              let o = e.graveyardPosition.clone()
              let r = e.targetPosition._getTransformedByMergeOperation(e)
              if (t.howMany > 1) {
                n.push(new u_(t.sourcePosition, t.howMany - 1, t.targetPosition, 0))
                o = o._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1)
                r = r._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1)
              }
              const i = e.deletionPosition._getCombined(t.sourcePosition, t.targetPosition)
              const s = new u_(o, 1, i, 0)
              const a = s.getMovedRangeStart().path.slice()
              a.push(0)
              const c = new vk(s.targetPosition.root, a)
              r = r._getTransformedByMove(o, i, 1)
              const l = new u_(r, e.howMany, c, 0)
              n.push(s)
              n.push(l)
              return n
            }
          } else {
            if (t.howMany == 1) {
              if (!n.bWasUndone) {
                return [new __(0)]
              } else {
                t.sourcePosition = e.graveyardPosition.clone()
                t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e)
                return [t]
              }
            }
          }
        }
        const r = Sk._createFromPositionAndShift(t.sourcePosition, t.howMany)
        const i = r._getTransformedByMergeOperation(e)
        t.sourcePosition = i.start
        t.howMany = i.end.offset - i.start.offset
        t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e)
        return [t]
      })
      D_(v_, f_, (t, e) => {
        t.position = t.position._getTransformedByInsertOperation(e)
        return [t]
      })
      D_(v_, g_, (t, e) => {
        if (t.position.isEqual(e.deletionPosition)) {
          t.position = e.graveyardPosition.clone()
          t.position.stickiness = "toNext"
          return [t]
        }
        t.position = t.position._getTransformedByMergeOperation(e)
        return [t]
      })
      D_(v_, u_, (t, e) => {
        t.position = t.position._getTransformedByMoveOperation(e)
        return [t]
      })
      D_(v_, v_, (t, e, n) => {
        if (t.position.isEqual(e.position)) {
          if (n.aIsStrong) {
            t.oldName = e.newName
          } else {
            return [new __(0)]
          }
        }
        return [t]
      })
      D_(v_, p_, (t, e) => {
        const n = t.position.path
        const o = e.splitPosition.getParentPath()
        if (Ct(n, o) == "same" && !e.graveyardPosition) {
          const e = new v_(t.position.getShiftedBy(1), t.oldName, t.newName, 0)
          return [t, e]
        }
        t.position = t.position._getTransformedBySplitOperation(e)
        return [t]
      })
      D_(A_, A_, (t, e, n) => {
        if (t.root === e.root && t.key === e.key) {
          if (!n.aIsStrong || t.newValue === e.newValue) {
            return [new __(0)]
          } else {
            t.oldValue = e.newValue
          }
        }
        return [t]
      })
      D_(C_, C_, (t, e, n) => {
        if (t.rootName === e.rootName && t.isAdd === e.isAdd && !n.bWasUndone) {
          return [new __(0)]
        }
        return [t]
      })
      D_(p_, f_, (t, e) => {
        if (
          t.splitPosition.hasSameParentAs(e.position) &&
          t.splitPosition.offset < e.position.offset
        ) {
          t.howMany += e.howMany
        }
        t.splitPosition = t.splitPosition._getTransformedByInsertOperation(e)
        t.insertionPosition = t.insertionPosition._getTransformedByInsertOperation(e)
        return [t]
      })
      D_(p_, g_, (t, e, n) => {
        if (
          !t.graveyardPosition &&
          !n.bWasUndone &&
          t.splitPosition.hasSameParentAs(e.sourcePosition)
        ) {
          const n = e.graveyardPosition.path.slice()
          n.push(0)
          const o = new vk(e.graveyardPosition.root, n)
          const r = p_.getInsertionPosition(new vk(e.graveyardPosition.root, n))
          const i = new p_(o, 0, r, null, 0)
          t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e)
          t.insertionPosition = p_.getInsertionPosition(t.splitPosition)
          t.graveyardPosition = i.insertionPosition.clone()
          t.graveyardPosition.stickiness = "toNext"
          return [i, t]
        }
        if (
          t.splitPosition.hasSameParentAs(e.deletionPosition) &&
          !t.splitPosition.isAfter(e.deletionPosition)
        ) {
          t.howMany--
        }
        if (t.splitPosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany
        }
        t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e)
        t.insertionPosition = p_.getInsertionPosition(t.splitPosition)
        if (t.graveyardPosition) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)
        }
        return [t]
      })
      D_(p_, u_, (t, e, n) => {
        const o = Sk._createFromPositionAndShift(e.sourcePosition, e.howMany)
        if (t.graveyardPosition) {
          const r = o.start.isEqual(t.graveyardPosition) || o.containsPosition(t.graveyardPosition)
          if (!n.bWasUndone && r) {
            const n = t.splitPosition._getTransformedByMoveOperation(e)
            const o = t.graveyardPosition._getTransformedByMoveOperation(e)
            const r = o.path.slice()
            r.push(0)
            const i = new vk(o.root, r)
            const s = new u_(n, t.howMany, i, 0)
            return [s]
          }
          t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)
        }
        const r = t.splitPosition.isEqual(e.targetPosition)
        if (r && (n.baRelation == "insertAtSource" || n.abRelation == "splitBefore")) {
          t.howMany += e.howMany
          t.splitPosition = t.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany)
          t.insertionPosition = p_.getInsertionPosition(t.splitPosition)
          return [t]
        }
        if (r && n.abRelation && n.abRelation.howMany) {
          const { howMany: e, offset: o } = n.abRelation
          t.howMany += e
          t.splitPosition = t.splitPosition.getShiftedBy(o)
          return [t]
        }
        if (
          t.splitPosition.hasSameParentAs(e.sourcePosition) &&
          o.containsPosition(t.splitPosition)
        ) {
          const n = e.howMany - (t.splitPosition.offset - e.sourcePosition.offset)
          t.howMany -= n
          if (
            t.splitPosition.hasSameParentAs(e.targetPosition) &&
            t.splitPosition.offset < e.targetPosition.offset
          ) {
            t.howMany += e.howMany
          }
          t.splitPosition = e.sourcePosition.clone()
          t.insertionPosition = p_.getInsertionPosition(t.splitPosition)
          return [t]
        }
        if (!e.sourcePosition.isEqual(e.targetPosition)) {
          if (
            t.splitPosition.hasSameParentAs(e.sourcePosition) &&
            t.splitPosition.offset <= e.sourcePosition.offset
          ) {
            t.howMany -= e.howMany
          }
          if (
            t.splitPosition.hasSameParentAs(e.targetPosition) &&
            t.splitPosition.offset < e.targetPosition.offset
          ) {
            t.howMany += e.howMany
          }
        }
        t.splitPosition.stickiness = "toNone"
        t.splitPosition = t.splitPosition._getTransformedByMoveOperation(e)
        t.splitPosition.stickiness = "toNext"
        if (t.graveyardPosition) {
          t.insertionPosition = t.insertionPosition._getTransformedByMoveOperation(e)
        } else {
          t.insertionPosition = p_.getInsertionPosition(t.splitPosition)
        }
        return [t]
      })
      D_(p_, p_, (t, e, n) => {
        if (t.splitPosition.isEqual(e.splitPosition)) {
          if (!t.graveyardPosition && !e.graveyardPosition) {
            return [new __(0)]
          }
          if (
            t.graveyardPosition &&
            e.graveyardPosition &&
            t.graveyardPosition.isEqual(e.graveyardPosition)
          ) {
            return [new __(0)]
          }
          if (n.abRelation == "splitBefore") {
            t.howMany = 0
            t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e)
            return [t]
          }
        }
        if (
          t.graveyardPosition &&
          e.graveyardPosition &&
          t.graveyardPosition.isEqual(e.graveyardPosition)
        ) {
          const o = t.splitPosition.root.rootName == "$graveyard"
          const r = e.splitPosition.root.rootName == "$graveyard"
          const i = o && !r
          const s = r && !o
          const a = s || (!i && n.aIsStrong)
          if (a) {
            const n = []
            if (e.howMany) {
              n.push(new u_(e.moveTargetPosition, e.howMany, e.splitPosition, 0))
            }
            if (t.howMany) {
              n.push(new u_(t.splitPosition, t.howMany, t.moveTargetPosition, 0))
            }
            return n
          } else {
            return [new __(0)]
          }
        }
        if (t.graveyardPosition) {
          t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e)
        }
        if (t.splitPosition.isEqual(e.insertionPosition) && n.abRelation == "splitBefore") {
          t.howMany++
          return [t]
        }
        if (e.splitPosition.isEqual(t.insertionPosition) && n.baRelation == "splitBefore") {
          const n = e.insertionPosition.path.slice()
          n.push(0)
          const o = new vk(e.insertionPosition.root, n)
          const r = new u_(t.insertionPosition, 1, o, 0)
          return [t, r]
        }
        if (
          t.splitPosition.hasSameParentAs(e.splitPosition) &&
          t.splitPosition.offset < e.splitPosition.offset
        ) {
          t.howMany -= e.howMany
        }
        t.splitPosition = t.splitPosition._getTransformedBySplitOperation(e)
        t.insertionPosition = p_.getInsertionPosition(t.splitPosition)
        return [t]
      })
      function N_(t, e) {
        return t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null
      }
      function F_(t, e) {
        const n = []
        for (let o = 0; o < t.length; o++) {
          const r = t[o]
          const i = new u_(r.start, r.end.offset - r.start.offset, e, 0)
          n.push(i)
          for (let e = o + 1; e < t.length; e++) {
            t[e] = t[e]._getTransformedByMove(i.sourcePosition, i.targetPosition, i.howMany)[0]
          }
          e = e._getTransformedByMove(i.sourcePosition, i.targetPosition, i.howMany)
        }
        return n
      }
      class V_ extends q(vk) {
        constructor(t, e, n = "toNone") {
          super(t, e, n)
          if (!this.root.is("rootElement")) {
            throw new P("model-liveposition-root-not-rootelement", t)
          }
          L_.call(this)
        }
        detach() {
          this.stopListening()
        }
        toPosition() {
          return new vk(this.root, this.path.slice(), this.stickiness)
        }
        static fromPosition(t, e) {
          return new this(t.root, t.path.slice(), e ? e : t.stickiness)
        }
      }
      V_.prototype.is = function (t) {
        return (
          t === "livePosition" ||
          t === "model:livePosition" ||
          t == "position" ||
          t === "model:position"
        )
      }
      function L_() {
        this.listenTo(
          this.root.document.model,
          "applyOperation",
          (t, e) => {
            const n = e[0]
            if (!n.isDocumentOperation) {
              return
            }
            j_.call(this, n)
          },
          { priority: "low" }
        )
      }
      function j_(t) {
        const e = this.getTransformedByOperation(t)
        if (!this.isEqual(e)) {
          const t = this.toPosition()
          this.path = e.path
          this.root = e.root
          this.fire("change", t)
        }
      }
      class H_ {
        constructor(t = {}) {
          if (typeof t === "string") {
            t = t === "transparent" ? { isUndoable: false } : {}
            B("batch-constructor-deprecated-string-type")
          }
          const {
            isUndoable: e = true,
            isLocal: n = true,
            isUndo: o = false,
            isTyping: r = false,
          } = t
          this.operations = []
          this.isUndoable = e
          this.isLocal = n
          this.isUndo = o
          this.isTyping = r
        }
        get type() {
          B("batch-type-deprecated")
          return "default"
        }
        get baseVersion() {
          for (const t of this.operations) {
            if (t.baseVersion !== null) {
              return t.baseVersion
            }
          }
          return null
        }
        addOperation(t) {
          t.batch = this
          this.operations.push(t)
          return t
        }
      }
      class W_ {
        constructor(t) {
          this._changesInElement = new Map()
          this._elementSnapshots = new Map()
          this._changedMarkers = new Map()
          this._changedRoots = new Map()
          this._changeCount = 0
          this._cachedChanges = null
          this._cachedChangesWithGraveyard = null
          this._refreshedItems = new Set()
          this._markerCollection = t
        }
        get isEmpty() {
          return (
            this._changesInElement.size == 0 &&
            this._changedMarkers.size == 0 &&
            this._changedRoots.size == 0
          )
        }
        bufferOperation(t) {
          const e = t
          switch (e.type) {
            case "insert": {
              if (this._isInInsertedElement(e.position.parent)) {
                return
              }
              this._markInsert(e.position.parent, e.position.offset, e.nodes.maxOffset)
              break
            }
            case "addAttribute":
            case "removeAttribute":
            case "changeAttribute": {
              for (const t of e.range.getItems({ shallow: true })) {
                if (this._isInInsertedElement(t.parent)) {
                  continue
                }
                this._markAttribute(t)
              }
              break
            }
            case "remove":
            case "move":
            case "reinsert": {
              if (
                e.sourcePosition.isEqual(e.targetPosition) ||
                e.sourcePosition.getShiftedBy(e.howMany).isEqual(e.targetPosition)
              ) {
                return
              }
              const t = this._isInInsertedElement(e.sourcePosition.parent)
              const n = this._isInInsertedElement(e.targetPosition.parent)
              if (!t) {
                this._markRemove(e.sourcePosition.parent, e.sourcePosition.offset, e.howMany)
              }
              if (!n) {
                this._markInsert(e.targetPosition.parent, e.getMovedRangeStart().offset, e.howMany)
              }
              break
            }
            case "rename": {
              if (this._isInInsertedElement(e.position.parent)) {
                return
              }
              this._markRemove(e.position.parent, e.position.offset, 1)
              this._markInsert(e.position.parent, e.position.offset, 1)
              const t = Sk._createFromPositionAndShift(e.position, 1)
              for (const e of this._markerCollection.getMarkersIntersectingRange(t)) {
                const t = e.getData()
                this.bufferMarkerChange(e.name, t, t)
              }
              break
            }
            case "split": {
              const t = e.splitPosition.parent
              if (!this._isInInsertedElement(t)) {
                this._markRemove(t, e.splitPosition.offset, e.howMany)
              }
              if (!this._isInInsertedElement(e.insertionPosition.parent)) {
                this._markInsert(e.insertionPosition.parent, e.insertionPosition.offset, 1)
              }
              if (e.graveyardPosition) {
                this._markRemove(e.graveyardPosition.parent, e.graveyardPosition.offset, 1)
              }
              break
            }
            case "merge": {
              const t = e.sourcePosition.parent
              if (!this._isInInsertedElement(t.parent)) {
                this._markRemove(t.parent, t.startOffset, 1)
              }
              const n = e.graveyardPosition.parent
              this._markInsert(n, e.graveyardPosition.offset, 1)
              const o = e.targetPosition.parent
              if (!this._isInInsertedElement(o)) {
                this._markInsert(o, e.targetPosition.offset, t.maxOffset)
              }
              break
            }
            case "detachRoot":
            case "addRoot": {
              this._bufferRootStateChange(e.rootName, e.isAdd)
              break
            }
            case "addRootAttribute":
            case "removeRootAttribute":
            case "changeRootAttribute": {
              const t = e.root.rootName
              this._bufferRootAttributeChange(t, e.key, e.oldValue, e.newValue)
              break
            }
          }
          this._cachedChanges = null
        }
        bufferMarkerChange(t, e, n) {
          const o = this._changedMarkers.get(t)
          if (!o) {
            this._changedMarkers.set(t, { newMarkerData: n, oldMarkerData: e })
          } else {
            o.newMarkerData = n
            if (o.oldMarkerData.range == null && n.range == null) {
              this._changedMarkers.delete(t)
            }
          }
        }
        getMarkersToRemove() {
          const t = []
          for (const [e, n] of this._changedMarkers) {
            if (n.oldMarkerData.range != null) {
              t.push({ name: e, range: n.oldMarkerData.range })
            }
          }
          return t
        }
        getMarkersToAdd() {
          const t = []
          for (const [e, n] of this._changedMarkers) {
            if (n.newMarkerData.range != null) {
              t.push({ name: e, range: n.newMarkerData.range })
            }
          }
          return t
        }
        getChangedMarkers() {
          return Array.from(this._changedMarkers).map(([t, e]) => ({
            name: t,
            data: { oldRange: e.oldMarkerData.range, newRange: e.newMarkerData.range },
          }))
        }
        hasDataChanges() {
          if (this._changesInElement.size > 0) {
            return true
          }
          if (this._changedRoots.size > 0) {
            return true
          }
          for (const { newMarkerData: t, oldMarkerData: e } of this._changedMarkers.values()) {
            if (t.affectsData !== e.affectsData) {
              return true
            }
            if (t.affectsData) {
              const n = t.range && !e.range
              const o = !t.range && e.range
              const r = t.range && e.range && !t.range.isEqual(e.range)
              if (n || o || r) {
                return true
              }
            }
          }
          return false
        }
        getChanges(t = {}) {
          if (this._cachedChanges) {
            if (t.includeChangesInGraveyard) {
              return this._cachedChangesWithGraveyard.slice()
            } else {
              return this._cachedChanges.slice()
            }
          }
          let e = []
          for (const t of this._changesInElement.keys()) {
            const n = this._changesInElement.get(t).sort((t, e) => {
              if (t.offset === e.offset) {
                if (t.type != e.type) {
                  return t.type == "remove" ? -1 : 1
                }
                return 0
              }
              return t.offset < e.offset ? -1 : 1
            })
            const o = this._elementSnapshots.get(t)
            const r = q_(t.getChildren())
            const i = $_(o.length, n)
            let s = 0
            let a = 0
            for (const n of i) {
              if (n === "i") {
                e.push(this._getInsertDiff(t, s, r[s]))
                s++
              } else if (n === "r") {
                e.push(this._getRemoveDiff(t, s, o[a]))
                a++
              } else if (n === "a") {
                const n = r[s].attributes
                const i = o[a].attributes
                let c
                if (r[s].name == "$text") {
                  c = new Sk(vk._createAt(t, s), vk._createAt(t, s + 1))
                } else {
                  const e = t.offsetToIndex(s)
                  c = new Sk(vk._createAt(t, s), vk._createAt(t.getChild(e), 0))
                }
                e.push(...this._getAttributesDiff(c, i, n))
                s++
                a++
              } else {
                s++
                a++
              }
            }
          }
          e.sort((t, e) => {
            if (t.position.root != e.position.root) {
              return t.position.root.rootName < e.position.root.rootName ? -1 : 1
            }
            if (t.position.isEqual(e.position)) {
              return t.changeCount - e.changeCount
            }
            return t.position.isBefore(e.position) ? -1 : 1
          })
          for (let t = 1, n = 0; t < e.length; t++) {
            const o = e[n]
            const r = e[t]
            const i =
              o.type == "remove" &&
              r.type == "remove" &&
              o.name == "$text" &&
              r.name == "$text" &&
              o.position.isEqual(r.position)
            const s =
              o.type == "insert" &&
              r.type == "insert" &&
              o.name == "$text" &&
              r.name == "$text" &&
              o.position.parent == r.position.parent &&
              o.position.offset + o.length == r.position.offset
            const a =
              o.type == "attribute" &&
              r.type == "attribute" &&
              o.position.parent == r.position.parent &&
              o.range.isFlat &&
              r.range.isFlat &&
              o.position.offset + o.length == r.position.offset &&
              o.attributeKey == r.attributeKey &&
              o.attributeOldValue == r.attributeOldValue &&
              o.attributeNewValue == r.attributeNewValue
            if (i || s || a) {
              o.length++
              if (a) {
                o.range.end = o.range.end.getShiftedBy(1)
              }
              e[t] = null
            } else {
              n = t
            }
          }
          e = e.filter((t) => t)
          for (const t of e) {
            delete t.changeCount
            if (t.type == "attribute") {
              delete t.position
              delete t.length
            }
          }
          this._changeCount = 0
          this._cachedChangesWithGraveyard = e
          this._cachedChanges = e.filter(K_)
          if (t.includeChangesInGraveyard) {
            return this._cachedChangesWithGraveyard.slice()
          } else {
            return this._cachedChanges.slice()
          }
        }
        getChangedRoots() {
          return Array.from(this._changedRoots.values()).map((t) => {
            const e = { ...t }
            if (e.state !== undefined) {
              delete e.attributes
            }
            return e
          })
        }
        getRefreshedItems() {
          return new Set(this._refreshedItems)
        }
        reset() {
          this._changesInElement.clear()
          this._elementSnapshots.clear()
          this._changedMarkers.clear()
          this._changedRoots.clear()
          this._refreshedItems = new Set()
          this._cachedChanges = null
        }
        _bufferRootStateChange(t, e) {
          if (!this._changedRoots.has(t)) {
            this._changedRoots.set(t, { name: t, state: e ? "attached" : "detached" })
            return
          }
          const n = this._changedRoots.get(t)
          if (n.state !== undefined) {
            delete n.state
            if (n.attributes === undefined) {
              this._changedRoots.delete(t)
            }
          } else {
            n.state = e ? "attached" : "detached"
          }
        }
        _bufferRootAttributeChange(t, e, n, o) {
          const r = this._changedRoots.get(t) || { name: t }
          const i = r.attributes || {}
          if (i[e]) {
            const t = i[e]
            if (o === t.oldValue) {
              delete i[e]
            } else {
              t.newValue = o
            }
          } else {
            i[e] = { oldValue: n, newValue: o }
          }
          if (Object.entries(i).length === 0) {
            delete r.attributes
            if (r.state === undefined) {
              this._changedRoots.delete(t)
            }
          } else {
            r.attributes = i
            this._changedRoots.set(t, r)
          }
        }
        _refreshItem(t) {
          if (this._isInInsertedElement(t.parent)) {
            return
          }
          this._markRemove(t.parent, t.startOffset, t.offsetSize)
          this._markInsert(t.parent, t.startOffset, t.offsetSize)
          this._refreshedItems.add(t)
          const e = Sk._createOn(t)
          for (const t of this._markerCollection.getMarkersIntersectingRange(e)) {
            const e = t.getData()
            this.bufferMarkerChange(t.name, e, e)
          }
          this._cachedChanges = null
        }
        _markInsert(t, e, n) {
          const o = { type: "insert", offset: e, howMany: n, count: this._changeCount++ }
          this._markChange(t, o)
        }
        _markRemove(t, e, n) {
          const o = { type: "remove", offset: e, howMany: n, count: this._changeCount++ }
          this._markChange(t, o)
          this._removeAllNestedChanges(t, e, n)
        }
        _markAttribute(t) {
          const e = {
            type: "attribute",
            offset: t.startOffset,
            howMany: t.offsetSize,
            count: this._changeCount++,
          }
          this._markChange(t.parent, e)
        }
        _markChange(t, e) {
          this._makeSnapshot(t)
          const n = this._getChangesForElement(t)
          this._handleChange(e, n)
          n.push(e)
          for (let t = 0; t < n.length; t++) {
            if (n[t].howMany < 1) {
              n.splice(t, 1)
              t--
            }
          }
        }
        _getChangesForElement(t) {
          let e
          if (this._changesInElement.has(t)) {
            e = this._changesInElement.get(t)
          } else {
            e = []
            this._changesInElement.set(t, e)
          }
          return e
        }
        _makeSnapshot(t) {
          if (!this._elementSnapshots.has(t)) {
            this._elementSnapshots.set(t, q_(t.getChildren()))
          }
        }
        _handleChange(t, e) {
          t.nodesToHandle = t.howMany
          for (const n of e) {
            const o = t.offset + t.howMany
            const r = n.offset + n.howMany
            if (t.type == "insert") {
              if (n.type == "insert") {
                if (t.offset <= n.offset) {
                  n.offset += t.howMany
                } else if (t.offset < r) {
                  n.howMany += t.nodesToHandle
                  t.nodesToHandle = 0
                }
              }
              if (n.type == "remove") {
                if (t.offset < n.offset) {
                  n.offset += t.howMany
                }
              }
              if (n.type == "attribute") {
                if (t.offset <= n.offset) {
                  n.offset += t.howMany
                } else if (t.offset < r) {
                  const r = n.howMany
                  n.howMany = t.offset - n.offset
                  e.unshift({
                    type: "attribute",
                    offset: o,
                    howMany: r - n.howMany,
                    count: this._changeCount++,
                  })
                }
              }
            }
            if (t.type == "remove") {
              if (n.type == "insert") {
                if (o <= n.offset) {
                  n.offset -= t.howMany
                } else if (o <= r) {
                  if (t.offset < n.offset) {
                    const e = o - n.offset
                    n.offset = t.offset
                    n.howMany -= e
                    t.nodesToHandle -= e
                  } else {
                    n.howMany -= t.nodesToHandle
                    t.nodesToHandle = 0
                  }
                } else {
                  if (t.offset <= n.offset) {
                    t.nodesToHandle -= n.howMany
                    n.howMany = 0
                  } else if (t.offset < r) {
                    const e = r - t.offset
                    n.howMany -= e
                    t.nodesToHandle -= e
                  }
                }
              }
              if (n.type == "remove") {
                if (o <= n.offset) {
                  n.offset -= t.howMany
                } else if (t.offset < n.offset) {
                  t.nodesToHandle += n.howMany
                  n.howMany = 0
                }
              }
              if (n.type == "attribute") {
                if (o <= n.offset) {
                  n.offset -= t.howMany
                } else if (t.offset < n.offset) {
                  const e = o - n.offset
                  n.offset = t.offset
                  n.howMany -= e
                } else if (t.offset < r) {
                  if (o <= r) {
                    const o = n.howMany
                    n.howMany = t.offset - n.offset
                    const r = o - n.howMany - t.nodesToHandle
                    e.unshift({
                      type: "attribute",
                      offset: t.offset,
                      howMany: r,
                      count: this._changeCount++,
                    })
                  } else {
                    n.howMany -= r - t.offset
                  }
                }
              }
            }
            if (t.type == "attribute") {
              if (n.type == "insert") {
                if (t.offset < n.offset && o > n.offset) {
                  if (o > r) {
                    const t = {
                      type: "attribute",
                      offset: r,
                      howMany: o - r,
                      count: this._changeCount++,
                    }
                    this._handleChange(t, e)
                    e.push(t)
                  }
                  t.nodesToHandle = n.offset - t.offset
                  t.howMany = t.nodesToHandle
                } else if (t.offset >= n.offset && t.offset < r) {
                  if (o > r) {
                    t.nodesToHandle = o - r
                    t.offset = r
                  } else {
                    t.nodesToHandle = 0
                  }
                }
              }
              if (n.type == "remove") {
                if (t.offset < n.offset && o > n.offset) {
                  const r = {
                    type: "attribute",
                    offset: n.offset,
                    howMany: o - n.offset,
                    count: this._changeCount++,
                  }
                  this._handleChange(r, e)
                  e.push(r)
                  t.nodesToHandle = n.offset - t.offset
                  t.howMany = t.nodesToHandle
                }
              }
              if (n.type == "attribute") {
                if (t.offset >= n.offset && o <= r) {
                  t.nodesToHandle = 0
                  t.howMany = 0
                  t.offset = 0
                } else if (t.offset <= n.offset && o >= r) {
                  n.howMany = 0
                }
              }
            }
          }
          t.howMany = t.nodesToHandle
          delete t.nodesToHandle
        }
        _getInsertDiff(t, e, n) {
          return {
            type: "insert",
            position: vk._createAt(t, e),
            name: n.name,
            attributes: new Map(n.attributes),
            length: 1,
            changeCount: this._changeCount++,
          }
        }
        _getRemoveDiff(t, e, n) {
          return {
            type: "remove",
            position: vk._createAt(t, e),
            name: n.name,
            attributes: new Map(n.attributes),
            length: 1,
            changeCount: this._changeCount++,
          }
        }
        _getAttributesDiff(t, e, n) {
          const o = []
          n = new Map(n)
          for (const [r, i] of e) {
            const e = n.has(r) ? n.get(r) : null
            if (e !== i) {
              o.push({
                type: "attribute",
                position: t.start,
                range: t.clone(),
                length: 1,
                attributeKey: r,
                attributeOldValue: i,
                attributeNewValue: e,
                changeCount: this._changeCount++,
              })
            }
            n.delete(r)
          }
          for (const [e, r] of n) {
            o.push({
              type: "attribute",
              position: t.start,
              range: t.clone(),
              length: 1,
              attributeKey: e,
              attributeOldValue: null,
              attributeNewValue: r,
              changeCount: this._changeCount++,
            })
          }
          return o
        }
        _isInInsertedElement(t) {
          const e = t.parent
          if (!e) {
            return false
          }
          const n = this._changesInElement.get(e)
          const o = t.startOffset
          if (n) {
            for (const t of n) {
              if (t.type == "insert" && o >= t.offset && o < t.offset + t.howMany) {
                return true
              }
            }
          }
          return this._isInInsertedElement(e)
        }
        _removeAllNestedChanges(t, e, n) {
          const o = new Sk(vk._createAt(t, e), vk._createAt(t, e + n))
          for (const t of o.getItems({ shallow: true })) {
            if (t.is("element")) {
              this._elementSnapshots.delete(t)
              this._changesInElement.delete(t)
              this._removeAllNestedChanges(t, 0, t.maxOffset)
            }
          }
        }
      }
      function q_(t) {
        const e = []
        for (const n of t) {
          if (n.is("$text")) {
            for (let t = 0; t < n.data.length; t++) {
              e.push({ name: "$text", attributes: new Map(n.getAttributes()) })
            }
          } else {
            e.push({ name: n.name, attributes: new Map(n.getAttributes()) })
          }
        }
        return e
      }
      function $_(t, e) {
        const n = []
        let o = 0
        let r = 0
        for (const t of e) {
          if (t.offset > o) {
            for (let e = 0; e < t.offset - o; e++) {
              n.push("e")
            }
            r += t.offset - o
          }
          if (t.type == "insert") {
            for (let e = 0; e < t.howMany; e++) {
              n.push("i")
            }
            o = t.offset + t.howMany
          } else if (t.type == "remove") {
            for (let e = 0; e < t.howMany; e++) {
              n.push("r")
            }
            o = t.offset
            r += t.howMany
          } else {
            n.push(..."a".repeat(t.howMany).split(""))
            o = t.offset + t.howMany
            r += t.howMany
          }
        }
        if (r < t) {
          for (let e = 0; e < t - r - o; e++) {
            n.push("e")
          }
        }
        return n
      }
      function K_(t) {
        const e = "position" in t && t.position.root.rootName == "$graveyard"
        const n = "range" in t && t.range.root.rootName == "$graveyard"
        return !e && !n
      }
      class G_ {
        constructor() {
          this._operations = []
          this._undoPairs = new Map()
          this._undoneOperations = new Set()
          this._baseVersionToOperationIndex = new Map()
          this._version = 0
          this._gaps = new Map()
        }
        get version() {
          return this._version
        }
        set version(t) {
          if (this._operations.length && t > this._version + 1) {
            this._gaps.set(this._version, t)
          }
          this._version = t
        }
        get lastOperation() {
          return this._operations[this._operations.length - 1]
        }
        addOperation(t) {
          if (t.baseVersion !== this.version) {
            throw new P("model-document-history-addoperation-incorrect-version", this, {
              operation: t,
              historyVersion: this.version,
            })
          }
          this._operations.push(t)
          this._version++
          this._baseVersionToOperationIndex.set(t.baseVersion, this._operations.length - 1)
        }
        getOperations(t, e = this.version) {
          if (!this._operations.length) {
            return []
          }
          const n = this._operations[0]
          if (t === undefined) {
            t = n.baseVersion
          }
          let o = e - 1
          for (const [e, n] of this._gaps) {
            if (t > e && t < n) {
              t = n
            }
            if (o > e && o < n) {
              o = e - 1
            }
          }
          if (o < n.baseVersion || t > this.lastOperation.baseVersion) {
            return []
          }
          let r = this._baseVersionToOperationIndex.get(t)
          if (r === undefined) {
            r = 0
          }
          let i = this._baseVersionToOperationIndex.get(o)
          if (i === undefined) {
            i = this._operations.length - 1
          }
          return this._operations.slice(r, i + 1)
        }
        getOperation(t) {
          const e = this._baseVersionToOperationIndex.get(t)
          if (e === undefined) {
            return
          }
          return this._operations[e]
        }
        setOperationAsUndone(t, e) {
          this._undoPairs.set(e, t)
          this._undoneOperations.add(t)
        }
        isUndoingOperation(t) {
          return this._undoPairs.has(t)
        }
        isUndoneOperation(t) {
          return this._undoneOperations.has(t)
        }
        getUndoneOperation(t) {
          return this._undoPairs.get(t)
        }
        reset() {
          this._version = 0
          this._undoPairs = new Map()
          this._operations = []
          this._undoneOperations = new Set()
          this._gaps = new Map()
          this._baseVersionToOperationIndex = new Map()
        }
      }
      class U_ extends kk {
        constructor(t, e, n = "main") {
          super(e)
          this._isAttached = true
          this._document = t
          this.rootName = n
        }
        get document() {
          return this._document
        }
        isAttached() {
          return this._isAttached
        }
        toJSON() {
          return this.rootName
        }
      }
      U_.prototype.is = function (t, e) {
        if (!e) {
          return (
            t === "rootElement" ||
            t === "model:rootElement" ||
            t === "element" ||
            t === "model:element" ||
            t === "node" ||
            t === "model:node"
          )
        }
        return (
          e === this.name &&
          (t === "rootElement" ||
            t === "model:rootElement" ||
            t === "element" ||
            t === "model:element")
        )
      }
      const J_ = "$graveyard"
      class Z_ extends q() {
        constructor(t) {
          super()
          this.model = t
          this.history = new G_()
          this.selection = new Jk(this)
          this.roots = new dl({ idProperty: "rootName" })
          this.differ = new W_(t.markers)
          this.isReadOnly = false
          this._postFixers = new Set()
          this._hasSelectionChangedFromTheLastChangeBlock = false
          this.createRoot("$root", J_)
          this.listenTo(
            t,
            "applyOperation",
            (t, e) => {
              const n = e[0]
              if (n.isDocumentOperation) {
                this.differ.bufferOperation(n)
              }
            },
            { priority: "high" }
          )
          this.listenTo(
            t,
            "applyOperation",
            (t, e) => {
              const n = e[0]
              if (n.isDocumentOperation) {
                this.history.addOperation(n)
              }
            },
            { priority: "low" }
          )
          this.listenTo(this.selection, "change", () => {
            this._hasSelectionChangedFromTheLastChangeBlock = true
          })
          this.listenTo(t.markers, "update", (t, e, n, o, r) => {
            const i = { ...e.getData(), range: o }
            this.differ.bufferMarkerChange(e.name, r, i)
            if (n === null) {
              e.on("change", (t, n) => {
                const o = e.getData()
                this.differ.bufferMarkerChange(e.name, { ...o, range: n }, o)
              })
            }
          })
          this.registerPostFixer((t) => {
            let e = false
            for (const n of this.roots) {
              if (!n.isAttached() && !n.isEmpty) {
                t.remove(t.createRangeIn(n))
                e = true
              }
            }
            for (const n of this.model.markers) {
              if (!n.getRange().root.isAttached()) {
                t.removeMarker(n)
                e = true
              }
            }
            return e
          })
        }
        get version() {
          return this.history.version
        }
        set version(t) {
          this.history.version = t
        }
        get graveyard() {
          return this.getRoot(J_)
        }
        createRoot(t = "$root", e = "main") {
          if (this.roots.get(e)) {
            throw new P("model-document-createroot-name-exists", this, { name: e })
          }
          const n = new U_(this, t, e)
          this.roots.add(n)
          return n
        }
        destroy() {
          this.selection.destroy()
          this.stopListening()
        }
        getRoot(t = "main") {
          return this.roots.get(t)
        }
        getRootNames(t = false) {
          return Array.from(this.roots)
            .filter((e) => e.rootName != J_ && (t || e.isAttached()))
            .map((t) => t.rootName)
        }
        registerPostFixer(t) {
          this._postFixers.add(t)
        }
        toJSON() {
          const t = $h(this)
          t.selection = "[engine.model.DocumentSelection]"
          t.model = "[engine.model.Model]"
          return t
        }
        _handleChangeBlock(t) {
          if (this._hasDocumentChangedFromTheLastChangeBlock()) {
            this._callPostFixers(t)
            this.selection.refresh()
            if (this.differ.hasDataChanges()) {
              this.fire("change:data", t.batch)
            } else {
              this.fire("change", t.batch)
            }
            this.selection.refresh()
            this.differ.reset()
          }
          this._hasSelectionChangedFromTheLastChangeBlock = false
        }
        _hasDocumentChangedFromTheLastChangeBlock() {
          return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock
        }
        _getDefaultRoot() {
          for (const t of this.roots) {
            if (t !== this.graveyard) {
              return t
            }
          }
          return this.graveyard
        }
        _getDefaultRange() {
          const t = this._getDefaultRoot()
          const e = this.model
          const n = e.schema
          const o = e.createPositionFromPath(t, [0])
          const r = n.getNearestSelectionRange(o)
          return r || e.createRange(o)
        }
        _validateSelectionRange(t) {
          return Y_(t.start) && Y_(t.end)
        }
        _callPostFixers(t) {
          let e = false
          do {
            for (const n of this._postFixers) {
              this.selection.refresh()
              e = n(t)
              if (e) {
                break
              }
            }
          } while (e)
        }
      }
      function Y_(t) {
        const e = t.textNode
        if (e) {
          const n = e.data
          const o = t.offset - e.startOffset
          return !Cl(n, o) && !yl(n, o)
        }
        return true
      }
      class Q_ extends q() {
        constructor() {
          super(...arguments)
          this._markers = new Map()
        }
        [Symbol.iterator]() {
          return this._markers.values()
        }
        has(t) {
          const e = t instanceof X_ ? t.name : t
          return this._markers.has(e)
        }
        get(t) {
          return this._markers.get(t) || null
        }
        _set(t, e, n = false, o = false) {
          const r = t instanceof X_ ? t.name : t
          if (r.includes(",")) {
            throw new P("markercollection-incorrect-marker-name", this)
          }
          const i = this._markers.get(r)
          if (i) {
            const t = i.getData()
            const s = i.getRange()
            let a = false
            if (!s.isEqual(e)) {
              i._attachLiveRange(qk.fromRange(e))
              a = true
            }
            if (n != i.managedUsingOperations) {
              i._managedUsingOperations = n
              a = true
            }
            if (typeof o === "boolean" && o != i.affectsData) {
              i._affectsData = o
              a = true
            }
            if (a) {
              this.fire(`update:${r}`, i, s, e, t)
            }
            return i
          }
          const s = qk.fromRange(e)
          const a = new X_(r, s, n, o)
          this._markers.set(r, a)
          this.fire(`update:${r}`, a, null, e, { ...a.getData(), range: null })
          return a
        }
        _remove(t) {
          const e = t instanceof X_ ? t.name : t
          const n = this._markers.get(e)
          if (n) {
            this._markers.delete(e)
            this.fire(`update:${e}`, n, n.getRange(), null, n.getData())
            this._destroyMarker(n)
            return true
          }
          return false
        }
        _refresh(t) {
          const e = t instanceof X_ ? t.name : t
          const n = this._markers.get(e)
          if (!n) {
            throw new P("markercollection-refresh-marker-not-exists", this)
          }
          const o = n.getRange()
          this.fire(`update:${e}`, n, o, o, n.getData())
        }
        *getMarkersAtPosition(t) {
          for (const e of this) {
            if (e.getRange().containsPosition(t)) {
              yield e
            }
          }
        }
        *getMarkersIntersectingRange(t) {
          for (const e of this) {
            if (e.getRange().getIntersection(t) !== null) {
              yield e
            }
          }
        }
        destroy() {
          for (const t of this._markers.values()) {
            this._destroyMarker(t)
          }
          this._markers = null
          this.stopListening()
        }
        *getMarkersGroup(t) {
          for (const e of this._markers.values()) {
            if (e.name.startsWith(t + ":")) {
              yield e
            }
          }
        }
        _destroyMarker(t) {
          t.stopListening()
          t._detachLiveRange()
        }
      }
      class X_ extends q(uk) {
        constructor(t, e, n, o) {
          super()
          this.name = t
          this._liveRange = this._attachLiveRange(e)
          this._managedUsingOperations = n
          this._affectsData = o
        }
        get managedUsingOperations() {
          if (!this._liveRange) {
            throw new P("marker-destroyed", this)
          }
          return this._managedUsingOperations
        }
        get affectsData() {
          if (!this._liveRange) {
            throw new P("marker-destroyed", this)
          }
          return this._affectsData
        }
        getData() {
          return {
            range: this.getRange(),
            affectsData: this.affectsData,
            managedUsingOperations: this.managedUsingOperations,
          }
        }
        getStart() {
          if (!this._liveRange) {
            throw new P("marker-destroyed", this)
          }
          return this._liveRange.start.clone()
        }
        getEnd() {
          if (!this._liveRange) {
            throw new P("marker-destroyed", this)
          }
          return this._liveRange.end.clone()
        }
        getRange() {
          if (!this._liveRange) {
            throw new P("marker-destroyed", this)
          }
          return this._liveRange.toRange()
        }
        _attachLiveRange(t) {
          if (this._liveRange) {
            this._detachLiveRange()
          }
          t.delegate("change:range").to(this)
          t.delegate("change:content").to(this)
          this._liveRange = t
          return t
        }
        _detachLiveRange() {
          this._liveRange.stopDelegating("change:range", this)
          this._liveRange.stopDelegating("change:content", this)
          this._liveRange.detach()
          this._liveRange = null
        }
      }
      X_.prototype.is = function (t) {
        return t === "marker" || t === "model:marker"
      }
      class tv extends o_ {
        constructor(t, e) {
          super(null)
          this.sourcePosition = t.clone()
          this.howMany = e
        }
        get type() {
          return "detach"
        }
        get affectedSelectable() {
          return null
        }
        toJSON() {
          const t = super.toJSON()
          t.sourcePosition = this.sourcePosition.toJSON()
          return t
        }
        _validate() {
          if (this.sourcePosition.root.document) {
            throw new P("detach-operation-on-document-node", this)
          }
        }
        _execute() {
          i_(Sk._createFromPositionAndShift(this.sourcePosition, this.howMany))
        }
        static get className() {
          return "DetachOperation"
        }
      }
      class ev extends uk {
        constructor(t) {
          super()
          this.markers = new Map()
          this._children = new pk()
          if (t) {
            this._insertChild(0, t)
          }
        }
        [Symbol.iterator]() {
          return this.getChildren()
        }
        get childCount() {
          return this._children.length
        }
        get maxOffset() {
          return this._children.maxOffset
        }
        get isEmpty() {
          return this.childCount === 0
        }
        get nextSibling() {
          return null
        }
        get previousSibling() {
          return null
        }
        get root() {
          return this
        }
        get parent() {
          return null
        }
        get document() {
          return null
        }
        isAttached() {
          return false
        }
        getAncestors() {
          return []
        }
        getChild(t) {
          return this._children.getNode(t)
        }
        getChildren() {
          return this._children[Symbol.iterator]()
        }
        getChildIndex(t) {
          return this._children.getNodeIndex(t)
        }
        getChildStartOffset(t) {
          return this._children.getNodeStartOffset(t)
        }
        getPath() {
          return []
        }
        getNodeByPath(t) {
          let e = this
          for (const n of t) {
            e = e.getChild(e.offsetToIndex(n))
          }
          return e
        }
        offsetToIndex(t) {
          return this._children.offsetToIndex(t)
        }
        toJSON() {
          const t = []
          for (const e of this._children) {
            t.push(e.toJSON())
          }
          return t
        }
        static fromJSON(t) {
          const e = []
          for (const n of t) {
            if (n.name) {
              e.push(kk.fromJSON(n))
            } else {
              e.push(gk.fromJSON(n))
            }
          }
          return new ev(e)
        }
        _appendChild(t) {
          this._insertChild(this.childCount, t)
        }
        _insertChild(t, e) {
          const n = nv(e)
          for (const t of n) {
            if (t.parent !== null) {
              t._remove()
            }
            t.parent = this
          }
          this._children._insertNodes(t, n)
        }
        _removeChildren(t, e = 1) {
          const n = this._children._removeNodes(t, e)
          for (const t of n) {
            t.parent = null
          }
          return n
        }
      }
      ev.prototype.is = function (t) {
        return t === "documentFragment" || t === "model:documentFragment"
      }
      function nv(t) {
        if (typeof t == "string") {
          return [new gk(t)]
        }
        if (!yt(t)) {
          t = [t]
        }
        return Array.from(t).map((t) => {
          if (typeof t == "string") {
            return new gk(t)
          }
          if (t instanceof mk) {
            return new gk(t.data, t.getAttributes())
          }
          return t
        })
      }
      class ov {
        constructor(t, e) {
          this.model = t
          this.batch = e
        }
        createText(t, e) {
          return new gk(t, e)
        }
        createElement(t, e) {
          return new kk(t, e)
        }
        createDocumentFragment() {
          return new ev()
        }
        cloneElement(t, e = true) {
          return t._clone(e)
        }
        insert(t, e, n = 0) {
          this._assertWriterUsedCorrectly()
          if (t instanceof gk && t.data == "") {
            return
          }
          const o = vk._createAt(e, n)
          if (t.parent) {
            if (cv(t.root, o.root)) {
              this.move(Sk._createOn(t), o)
              return
            } else {
              if (t.root.document) {
                throw new P("model-writer-insert-forbidden-move", this)
              } else {
                this.remove(t)
              }
            }
          }
          const r = o.root.document ? o.root.document.version : null
          const i = new f_(o, t, r)
          if (t instanceof gk) {
            i.shouldReceiveAttributes = true
          }
          this.batch.addOperation(i)
          this.model.applyOperation(i)
          if (t instanceof ev) {
            for (const [e, n] of t.markers) {
              const t = vk._createAt(n.root, 0)
              const r = new Sk(n.start._getCombined(t, o), n.end._getCombined(t, o))
              const i = { range: r, usingOperation: true, affectsData: true }
              if (this.model.markers.has(e)) {
                this.updateMarker(e, i)
              } else {
                this.addMarker(e, i)
              }
            }
          }
        }
        insertText(t, e, n, o) {
          if (e instanceof ev || e instanceof kk || e instanceof vk) {
            this.insert(this.createText(t), e, n)
          } else {
            this.insert(this.createText(t, e), n, o)
          }
        }
        insertElement(t, e, n, o) {
          if (e instanceof ev || e instanceof kk || e instanceof vk) {
            this.insert(this.createElement(t), e, n)
          } else {
            this.insert(this.createElement(t, e), n, o)
          }
        }
        append(t, e) {
          this.insert(t, e, "end")
        }
        appendText(t, e, n) {
          if (e instanceof ev || e instanceof kk) {
            this.insert(this.createText(t), e, "end")
          } else {
            this.insert(this.createText(t, e), n, "end")
          }
        }
        appendElement(t, e, n) {
          if (e instanceof ev || e instanceof kk) {
            this.insert(this.createElement(t), e, "end")
          } else {
            this.insert(this.createElement(t, e), n, "end")
          }
        }
        setAttribute(t, e, n) {
          this._assertWriterUsedCorrectly()
          if (n instanceof Sk) {
            const o = n.getMinimalFlatRanges()
            for (const n of o) {
              rv(this, t, e, n)
            }
          } else {
            iv(this, t, e, n)
          }
        }
        setAttributes(t, e) {
          for (const [n, o] of gl(t)) {
            this.setAttribute(n, o, e)
          }
        }
        removeAttribute(t, e) {
          this._assertWriterUsedCorrectly()
          if (e instanceof Sk) {
            const n = e.getMinimalFlatRanges()
            for (const e of n) {
              rv(this, t, null, e)
            }
          } else {
            iv(this, t, null, e)
          }
        }
        clearAttributes(t) {
          this._assertWriterUsedCorrectly()
          const e = (t) => {
            for (const e of t.getAttributeKeys()) {
              this.removeAttribute(e, t)
            }
          }
          if (!(t instanceof Sk)) {
            e(t)
          } else {
            for (const n of t.getItems()) {
              e(n)
            }
          }
        }
        move(t, e, n) {
          this._assertWriterUsedCorrectly()
          if (!(t instanceof Sk)) {
            throw new P("writer-move-invalid-range", this)
          }
          if (!t.isFlat) {
            throw new P("writer-move-range-not-flat", this)
          }
          const o = vk._createAt(e, n)
          if (o.isEqual(t.start)) {
            return
          }
          this._addOperationForAffectedMarkers("move", t)
          if (!cv(t.root, o.root)) {
            throw new P("writer-move-different-document", this)
          }
          const r = t.root.document ? t.root.document.version : null
          const i = new u_(t.start, t.end.offset - t.start.offset, o, r)
          this.batch.addOperation(i)
          this.model.applyOperation(i)
        }
        remove(t) {
          this._assertWriterUsedCorrectly()
          const e = t instanceof Sk ? t : Sk._createOn(t)
          const n = e.getMinimalFlatRanges().reverse()
          for (const t of n) {
            this._addOperationForAffectedMarkers("move", t)
            av(t.start, t.end.offset - t.start.offset, this.batch, this.model)
          }
        }
        merge(t) {
          this._assertWriterUsedCorrectly()
          const e = t.nodeBefore
          const n = t.nodeAfter
          this._addOperationForAffectedMarkers("merge", t)
          if (!(e instanceof kk)) {
            throw new P("writer-merge-no-element-before", this)
          }
          if (!(n instanceof kk)) {
            throw new P("writer-merge-no-element-after", this)
          }
          if (!t.root.document) {
            this._mergeDetached(t)
          } else {
            this._merge(t)
          }
        }
        createPositionFromPath(t, e, n) {
          return this.model.createPositionFromPath(t, e, n)
        }
        createPositionAt(t, e) {
          return this.model.createPositionAt(t, e)
        }
        createPositionAfter(t) {
          return this.model.createPositionAfter(t)
        }
        createPositionBefore(t) {
          return this.model.createPositionBefore(t)
        }
        createRange(t, e) {
          return this.model.createRange(t, e)
        }
        createRangeIn(t) {
          return this.model.createRangeIn(t)
        }
        createRangeOn(t) {
          return this.model.createRangeOn(t)
        }
        createSelection(...t) {
          return this.model.createSelection(...t)
        }
        _mergeDetached(t) {
          const e = t.nodeBefore
          const n = t.nodeAfter
          this.move(Sk._createIn(n), vk._createAt(e, "end"))
          this.remove(n)
        }
        _merge(t) {
          const e = vk._createAt(t.nodeBefore, "end")
          const n = vk._createAt(t.nodeAfter, 0)
          const o = t.root.document.graveyard
          const r = new vk(o, [0])
          const i = t.root.document.version
          const s = new g_(n, t.nodeAfter.maxOffset, e, r, i)
          this.batch.addOperation(s)
          this.model.applyOperation(s)
        }
        rename(t, e) {
          this._assertWriterUsedCorrectly()
          if (!(t instanceof kk)) {
            throw new P("writer-rename-not-element-instance", this)
          }
          const n = t.root.document ? t.root.document.version : null
          const o = new v_(vk._createBefore(t), t.name, e, n)
          this.batch.addOperation(o)
          this.model.applyOperation(o)
        }
        split(t, e) {
          this._assertWriterUsedCorrectly()
          let n = t.parent
          if (!n.parent) {
            throw new P("writer-split-element-no-parent", this)
          }
          if (!e) {
            e = n.parent
          }
          if (!t.parent.getAncestors({ includeSelf: true }).includes(e)) {
            throw new P("writer-split-invalid-limit-element", this)
          }
          let o
          let r
          do {
            const e = n.root.document ? n.root.document.version : null
            const i = n.maxOffset - t.offset
            const s = p_.getInsertionPosition(t)
            const a = new p_(t, i, s, null, e)
            this.batch.addOperation(a)
            this.model.applyOperation(a)
            if (!o && !r) {
              o = n
              r = t.parent.nextSibling
            }
            t = this.createPositionAfter(t.parent)
            n = t.parent
          } while (n !== e)
          return { position: t, range: new Sk(vk._createAt(o, "end"), vk._createAt(r, 0)) }
        }
        wrap(t, e) {
          this._assertWriterUsedCorrectly()
          if (!t.isFlat) {
            throw new P("writer-wrap-range-not-flat", this)
          }
          const n = e instanceof kk ? e : new kk(e)
          if (n.childCount > 0) {
            throw new P("writer-wrap-element-not-empty", this)
          }
          if (n.parent !== null) {
            throw new P("writer-wrap-element-attached", this)
          }
          this.insert(n, t.start)
          const o = new Sk(t.start.getShiftedBy(1), t.end.getShiftedBy(1))
          this.move(o, vk._createAt(n, 0))
        }
        unwrap(t) {
          this._assertWriterUsedCorrectly()
          if (t.parent === null) {
            throw new P("writer-unwrap-element-no-parent", this)
          }
          this.move(Sk._createIn(t), this.createPositionAfter(t))
          this.remove(t)
        }
        addMarker(t, e) {
          this._assertWriterUsedCorrectly()
          if (!e || typeof e.usingOperation != "boolean") {
            throw new P("writer-addmarker-no-usingoperation", this)
          }
          const n = e.usingOperation
          const o = e.range
          const r = e.affectsData === undefined ? false : e.affectsData
          if (this.model.markers.has(t)) {
            throw new P("writer-addmarker-marker-exists", this)
          }
          if (!o) {
            throw new P("writer-addmarker-no-range", this)
          }
          if (!n) {
            return this.model.markers._set(t, o, n, r)
          }
          sv(this, t, null, o, r)
          return this.model.markers.get(t)
        }
        updateMarker(t, e) {
          this._assertWriterUsedCorrectly()
          const n = typeof t == "string" ? t : t.name
          const o = this.model.markers.get(n)
          if (!o) {
            throw new P("writer-updatemarker-marker-not-exists", this)
          }
          if (!e) {
            B("writer-updatemarker-reconvert-using-editingcontroller", { markerName: n })
            this.model.markers._refresh(o)
            return
          }
          const r = typeof e.usingOperation == "boolean"
          const i = typeof e.affectsData == "boolean"
          const s = i ? e.affectsData : o.affectsData
          if (!r && !e.range && !i) {
            throw new P("writer-updatemarker-wrong-options", this)
          }
          const a = o.getRange()
          const c = e.range ? e.range : a
          if (r && e.usingOperation !== o.managedUsingOperations) {
            if (e.usingOperation) {
              sv(this, n, null, c, s)
            } else {
              sv(this, n, a, null, s)
              this.model.markers._set(n, c, undefined, s)
            }
            return
          }
          if (o.managedUsingOperations) {
            sv(this, n, a, c, s)
          } else {
            this.model.markers._set(n, c, undefined, s)
          }
        }
        removeMarker(t) {
          this._assertWriterUsedCorrectly()
          const e = typeof t == "string" ? t : t.name
          if (!this.model.markers.has(e)) {
            throw new P("writer-removemarker-no-marker", this)
          }
          const n = this.model.markers.get(e)
          if (!n.managedUsingOperations) {
            this.model.markers._remove(e)
            return
          }
          const o = n.getRange()
          sv(this, e, o, null, n.affectsData)
        }
        addRoot(t, e = "$root") {
          this._assertWriterUsedCorrectly()
          const n = this.model.document.getRoot(t)
          if (n && n.isAttached()) {
            throw new P("writer-addroot-root-exists", this)
          }
          const o = this.model.document
          const r = new C_(t, e, true, o, o.version)
          this.batch.addOperation(r)
          this.model.applyOperation(r)
          return this.model.document.getRoot(t)
        }
        detachRoot(t) {
          this._assertWriterUsedCorrectly()
          const e = typeof t == "string" ? this.model.document.getRoot(t) : t
          if (!e || !e.isAttached()) {
            throw new P("writer-detachroot-no-root", this)
          }
          for (const t of this.model.markers) {
            if (t.getRange().root === e) {
              this.removeMarker(t)
            }
          }
          for (const t of e.getAttributeKeys()) {
            this.removeAttribute(t, e)
          }
          this.remove(this.createRangeIn(e))
          const n = this.model.document
          const o = new C_(e.rootName, e.name, false, n, n.version)
          this.batch.addOperation(o)
          this.model.applyOperation(o)
        }
        setSelection(...t) {
          this._assertWriterUsedCorrectly()
          this.model.document.selection._setTo(...t)
        }
        setSelectionFocus(t, e) {
          this._assertWriterUsedCorrectly()
          this.model.document.selection._setFocus(t, e)
        }
        setSelectionAttribute(t, e) {
          this._assertWriterUsedCorrectly()
          if (typeof t === "string") {
            this._setSelectionAttribute(t, e)
          } else {
            for (const [e, n] of gl(t)) {
              this._setSelectionAttribute(e, n)
            }
          }
        }
        removeSelectionAttribute(t) {
          this._assertWriterUsedCorrectly()
          if (typeof t === "string") {
            this._removeSelectionAttribute(t)
          } else {
            for (const e of t) {
              this._removeSelectionAttribute(e)
            }
          }
        }
        overrideSelectionGravity() {
          return this.model.document.selection._overrideGravity()
        }
        restoreSelectionGravity(t) {
          this.model.document.selection._restoreGravity(t)
        }
        _setSelectionAttribute(t, e) {
          const n = this.model.document.selection
          if (n.isCollapsed && n.anchor.parent.isEmpty) {
            const o = Jk._getStoreAttributeKey(t)
            this.setAttribute(o, e, n.anchor.parent)
          }
          n._setAttribute(t, e)
        }
        _removeSelectionAttribute(t) {
          const e = this.model.document.selection
          if (e.isCollapsed && e.anchor.parent.isEmpty) {
            const n = Jk._getStoreAttributeKey(t)
            this.removeAttribute(n, e.anchor.parent)
          }
          e._removeAttribute(t)
        }
        _assertWriterUsedCorrectly() {
          if (this.model._currentWriter !== this) {
            throw new P("writer-incorrect-use", this)
          }
        }
        _addOperationForAffectedMarkers(t, e) {
          for (const n of this.model.markers) {
            if (!n.managedUsingOperations) {
              continue
            }
            const o = n.getRange()
            let r = false
            if (t === "move") {
              const t = e
              r =
                t.containsPosition(o.start) ||
                t.start.isEqual(o.start) ||
                t.containsPosition(o.end) ||
                t.end.isEqual(o.end)
            } else {
              const t = e
              const n = t.nodeBefore
              const i = t.nodeAfter
              const s = o.start.parent == n && o.start.isAtEnd
              const a = o.end.parent == i && o.end.offset == 0
              const c = o.end.nodeAfter == i
              const l = o.start.nodeAfter == i
              r = s || a || c || l
            }
            if (r) {
              this.updateMarker(n.name, { range: o })
            }
          }
        }
      }
      function rv(t, e, n, o) {
        const r = t.model
        const i = r.document
        let s = o.start
        let a
        let c
        let l
        for (const t of o.getWalker({ shallow: true })) {
          l = t.item.getAttribute(e)
          if (a && c != l) {
            if (c != n) {
              d()
            }
            s = a
          }
          a = t.nextPosition
          c = l
        }
        if (a instanceof vk && a != s && c != n) {
          d()
        }
        function d() {
          const o = new Sk(s, a)
          const l = o.root.document ? i.version : null
          const d = new w_(o, e, c, n, l)
          t.batch.addOperation(d)
          r.applyOperation(d)
        }
      }
      function iv(t, e, n, o) {
        const r = t.model
        const i = r.document
        const s = o.getAttribute(e)
        let a, c
        if (s != n) {
          const l = o.root === o
          if (l) {
            const t = o.document ? i.version : null
            c = new A_(o, e, s, n, t)
          } else {
            a = new Sk(vk._createBefore(o), t.createPositionAfter(o))
            const r = a.root.document ? i.version : null
            c = new w_(a, e, s, n, r)
          }
          t.batch.addOperation(c)
          r.applyOperation(c)
        }
      }
      function sv(t, e, n, o, r) {
        const i = t.model
        const s = i.document
        const a = new m_(e, n, o, i.markers, !!r, s.version)
        t.batch.addOperation(a)
        i.applyOperation(a)
      }
      function av(t, e, n, o) {
        let r
        if (t.root.document) {
          const n = o.document
          const i = new vk(n.graveyard, [0])
          r = new u_(t, e, i, n.version)
        } else {
          r = new tv(t, e)
        }
        n.addOperation(r)
        o.applyOperation(r)
      }
      function cv(t, e) {
        if (t === e) {
          return true
        }
        if (t instanceof U_ && e instanceof U_) {
          return true
        }
        return false
      }
      function lv(t, e, n = {}) {
        if (e.isCollapsed) {
          return
        }
        const o = e.getFirstRange()
        if (o.root.rootName == "$graveyard") {
          return
        }
        const r = t.schema
        t.change((t) => {
          if (!n.doNotResetEntireContent && Av(r, e)) {
            vv(t, e)
            return
          }
          const i = {}
          if (!n.doNotAutoparagraph) {
            const t = e.getSelectedElement()
            if (t) {
              Object.assign(i, r.getAttributesWithProperty(t, "copyOnReplace", true))
            }
          }
          const [s, a] = dv(o)
          if (!s.isTouching(a)) {
            t.remove(t.createRange(s, a))
          }
          if (!n.leaveUnmerged) {
            uv(t, s, a)
            r.removeDisallowedAttributes(s.parent.getChildren(), t)
          }
          Cv(t, e, s)
          if (!n.doNotAutoparagraph && bv(r, s)) {
            _v(t, s, e, i)
          }
          s.detach()
          a.detach()
        })
      }
      function dv(t) {
        const e = t.root.document.model
        const n = t.start
        let o = t.end
        if (e.hasContent(t, { ignoreMarkers: true })) {
          const n = hv(o)
          if (n && o.isTouching(e.createPositionAt(n, 0))) {
            const n = e.createSelection(t)
            e.modifySelection(n, { direction: "backward" })
            const r = n.getLastPosition()
            const i = e.createRange(r, o)
            if (!e.hasContent(i, { ignoreMarkers: true })) {
              o = r
            }
          }
        }
        return [V_.fromPosition(n, "toPrevious"), V_.fromPosition(o, "toNext")]
      }
      function hv(t) {
        const e = t.parent
        const n = e.root.document.model.schema
        const o = e.getAncestors({ parentFirst: true, includeSelf: true })
        for (const t of o) {
          if (n.isLimit(t)) {
            return null
          }
          if (n.isBlock(t)) {
            return t
          }
        }
      }
      function uv(t, e, n) {
        const o = t.model
        if (!mv(t.model.schema, e, n)) {
          return
        }
        const [r, i] = kv(e, n)
        if (!r || !i) {
          return
        }
        if (!o.hasContent(r, { ignoreMarkers: true }) && o.hasContent(i, { ignoreMarkers: true })) {
          pv(t, e, n, r.parent)
        } else {
          fv(t, e, n, r.parent)
        }
      }
      function fv(t, e, n, o) {
        const r = e.parent
        const i = n.parent
        if (r == o || i == o) {
          return
        }
        e = t.createPositionAfter(r)
        n = t.createPositionBefore(i)
        if (!n.isEqual(e)) {
          t.insert(i, e)
        }
        t.merge(e)
        while (n.parent.isEmpty) {
          const e = n.parent
          n = t.createPositionBefore(e)
          t.remove(e)
        }
        if (!mv(t.model.schema, e, n)) {
          return
        }
        fv(t, e, n, o)
      }
      function pv(t, e, n, o) {
        const r = e.parent
        const i = n.parent
        if (r == o || i == o) {
          return
        }
        e = t.createPositionAfter(r)
        n = t.createPositionBefore(i)
        if (!n.isEqual(e)) {
          t.insert(r, n)
        }
        while (e.parent.isEmpty) {
          const n = e.parent
          e = t.createPositionBefore(n)
          t.remove(n)
        }
        n = t.createPositionBefore(i)
        gv(t, n)
        if (!mv(t.model.schema, e, n)) {
          return
        }
        pv(t, e, n, o)
      }
      function gv(t, e) {
        const n = e.nodeBefore
        const o = e.nodeAfter
        if (n.name != o.name) {
          t.rename(n, o.name)
        }
        t.clearAttributes(n)
        t.setAttributes(Object.fromEntries(o.getAttributes()), n)
        t.merge(e)
      }
      function mv(t, e, n) {
        const o = e.parent
        const r = n.parent
        if (o == r) {
          return false
        }
        if (t.isLimit(o) || t.isLimit(r)) {
          return false
        }
        return wv(e, n, t)
      }
      function kv(t, e) {
        const n = t.getAncestors()
        const o = e.getAncestors()
        let r = 0
        while (n[r] && n[r] == o[r]) {
          r++
        }
        return [n[r], o[r]]
      }
      function bv(t, e) {
        const n = t.checkChild(e, "$text")
        const o = t.checkChild(e, "paragraph")
        return !n && o
      }
      function wv(t, e, n) {
        const o = new Sk(t, e)
        for (const t of o.getWalker()) {
          if (n.isLimit(t.item)) {
            return false
          }
        }
        return true
      }
      function _v(t, e, n, o = {}) {
        const r = t.createElement("paragraph")
        t.model.schema.setAllowedAttributes(r, o, t)
        t.insert(r, e)
        Cv(t, n, t.createPositionAt(r, 0))
      }
      function vv(t, e) {
        const n = t.model.schema.getLimitElement(e)
        t.remove(t.createRangeIn(n))
        _v(t, t.createPositionAt(n, 0), e)
      }
      function Av(t, e) {
        const n = t.getLimitElement(e)
        if (!e.containsEntireContent(n)) {
          return false
        }
        const o = e.getFirstRange()
        if (o.start.parent == o.end.parent) {
          return false
        }
        return t.checkChild(n, "paragraph")
      }
      function Cv(t, e, n) {
        if (e instanceof Jk) {
          t.setSelection(n)
        } else {
          e.setTo(n)
        }
      }
      function yv(t, e) {
        return t.change((t) => {
          const n = t.createDocumentFragment()
          const o = e.getFirstRange()
          if (!o || o.isCollapsed) {
            return n
          }
          const r = o.start.root
          const i = o.start.getCommonPath(o.end)
          const s = r.getNodeByPath(i)
          let a
          if (o.start.parent == o.end.parent) {
            a = o
          } else {
            a = t.createRange(
              t.createPositionAt(s, o.start.path[i.length]),
              t.createPositionAt(s, o.end.path[i.length] + 1)
            )
          }
          const c = a.end.offset - a.start.offset
          for (const e of a.getItems({ shallow: true })) {
            if (e.is("$textProxy")) {
              t.appendText(e.data, e.getAttributes(), n)
            } else {
              t.append(t.cloneElement(e, true), n)
            }
          }
          if (a != o) {
            const e = o._getTransformedByMove(a.start, t.createPositionAt(n, 0), c)[0]
            const r = t.createRange(t.createPositionAt(n, 0), e.start)
            const i = t.createRange(e.end, t.createPositionAt(n, "end"))
            xv(i, t)
            xv(r, t)
          }
          return n
        })
      }
      function xv(t, e) {
        const n = []
        Array.from(t.getItems({ direction: "backward" }))
          .map((t) => e.createRangeOn(t))
          .filter((e) => {
            const n =
              (e.start.isAfter(t.start) || e.start.isEqual(t.start)) &&
              (e.end.isBefore(t.end) || e.end.isEqual(t.end))
            return n
          })
          .forEach((t) => {
            n.push(t.start.parent)
            e.remove(t)
          })
        n.forEach((t) => {
          let n = t
          while (n.parent && n.isEmpty) {
            const t = e.createRangeOn(n)
            n = n.parent
            e.remove(t)
          }
        })
      }
      function Ev(t, e, n) {
        return t.change((o) => {
          const r = n ? n : t.document.selection
          if (!r.isCollapsed) {
            t.deleteContent(r, { doNotAutoparagraph: true })
          }
          const i = new Dv(t, o, r.anchor)
          const s = []
          let a
          if (e.is("documentFragment")) {
            if (e.markers.size) {
              const t = []
              for (const [n, o] of e.markers) {
                const { start: e, end: r } = o
                const i = e.isEqual(r)
                t.push(
                  { position: e, name: n, isCollapsed: i },
                  { position: r, name: n, isCollapsed: i }
                )
              }
              t.sort(({ position: t }, { position: e }) => (t.isBefore(e) ? 1 : -1))
              for (const { position: n, name: r, isCollapsed: i } of t) {
                let t = null
                let a = null
                const c = n.parent === e && n.isAtStart
                const l = n.parent === e && n.isAtEnd
                if (!c && !l) {
                  t = o.createElement("$marker")
                  o.insert(t, n)
                } else if (i) {
                  a = c ? "start" : "end"
                }
                s.push({ name: r, element: t, collapsed: a })
              }
            }
            a = e.getChildren()
          } else {
            a = [e]
          }
          i.handleNodes(a)
          let c = i.getSelectionRange()
          if (e.is("documentFragment") && s.length) {
            const t = c ? qk.fromRange(c) : null
            const e = {}
            for (let t = s.length - 1; t >= 0; t--) {
              const { name: n, element: r, collapsed: a } = s[t]
              const c = !e[n]
              if (c) {
                e[n] = []
              }
              if (r) {
                const t = o.createPositionAt(r, "before")
                e[n].push(t)
                o.remove(r)
              } else {
                const t = i.getAffectedRange()
                if (!t) {
                  if (a) {
                    e[n].push(i.position)
                  }
                  continue
                }
                if (a) {
                  e[n].push(t[a])
                } else {
                  e[n].push(c ? t.start : t.end)
                }
              }
            }
            for (const [t, [n, r]] of Object.entries(e)) {
              if (n && r && n.root === r.root) {
                o.addMarker(t, { usingOperation: true, affectsData: true, range: new Sk(n, r) })
              }
            }
            if (t) {
              c = t.toRange()
              t.detach()
            }
          }
          if (c) {
            if (r instanceof Jk) {
              o.setSelection(c)
            } else {
              r.setTo(c)
            }
          } else {
          }
          const l = i.getAffectedRange() || t.createRange(r.anchor)
          i.destroy()
          return l
        })
      }
      class Dv {
        constructor(t, e, n) {
          this._firstNode = null
          this._lastNode = null
          this._lastAutoParagraph = null
          this._filterAttributesOf = []
          this._affectedStart = null
          this._affectedEnd = null
          this._nodeToSelect = null
          this.model = t
          this.writer = e
          this.position = n
          this.canMergeWith = new Set([this.position.parent])
          this.schema = t.schema
          this._documentFragment = e.createDocumentFragment()
          this._documentFragmentPosition = e.createPositionAt(this._documentFragment, 0)
        }
        handleNodes(t) {
          for (const e of Array.from(t)) {
            this._handleNode(e)
          }
          this._insertPartialFragment()
          if (this._lastAutoParagraph) {
            this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph)
          }
          this._mergeOnRight()
          this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer)
          this._filterAttributesOf = []
        }
        _updateLastNodeFromAutoParagraph(t) {
          const e = this.writer.createPositionAfter(this._lastNode)
          const n = this.writer.createPositionAfter(t)
          if (n.isAfter(e)) {
            this._lastNode = t
            if (this.position.parent != t || !this.position.isAtEnd) {
              throw new P("insertcontent-invalid-insertion-position", this)
            }
            this.position = n
            this._setAffectedBoundaries(this.position)
          }
        }
        getSelectionRange() {
          if (this._nodeToSelect) {
            return Sk._createOn(this._nodeToSelect)
          }
          return this.model.schema.getNearestSelectionRange(this.position)
        }
        getAffectedRange() {
          if (!this._affectedStart) {
            return null
          }
          return new Sk(this._affectedStart, this._affectedEnd)
        }
        destroy() {
          if (this._affectedStart) {
            this._affectedStart.detach()
          }
          if (this._affectedEnd) {
            this._affectedEnd.detach()
          }
        }
        _handleNode(t) {
          if (this.schema.isObject(t)) {
            this._handleObject(t)
            return
          }
          let e = this._checkAndAutoParagraphToAllowedPosition(t)
          if (!e) {
            e = this._checkAndSplitToAllowedPosition(t)
            if (!e) {
              this._handleDisallowedNode(t)
              return
            }
          }
          this._appendToFragment(t)
          if (!this._firstNode) {
            this._firstNode = t
          }
          this._lastNode = t
        }
        _insertPartialFragment() {
          if (this._documentFragment.isEmpty) {
            return
          }
          const t = V_.fromPosition(this.position, "toNext")
          this._setAffectedBoundaries(this.position)
          if (this._documentFragment.getChild(0) == this._firstNode) {
            this.writer.insert(this._firstNode, this.position)
            this._mergeOnLeft()
            this.position = t.toPosition()
          }
          if (!this._documentFragment.isEmpty) {
            this.writer.insert(this._documentFragment, this.position)
          }
          this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0)
          this.position = t.toPosition()
          t.detach()
        }
        _handleObject(t) {
          if (this._checkAndSplitToAllowedPosition(t)) {
            this._appendToFragment(t)
          } else {
            this._tryAutoparagraphing(t)
          }
        }
        _handleDisallowedNode(t) {
          if (t.is("element")) {
            this.handleNodes(t.getChildren())
          } else {
            this._tryAutoparagraphing(t)
          }
        }
        _appendToFragment(t) {
          if (!this.schema.checkChild(this.position, t)) {
            throw new P("insertcontent-wrong-position", this, { node: t, position: this.position })
          }
          this.writer.insert(t, this._documentFragmentPosition)
          this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(t.offsetSize)
          if (this.schema.isObject(t) && !this.schema.checkChild(this.position, "$text")) {
            this._nodeToSelect = t
          } else {
            this._nodeToSelect = null
          }
          this._filterAttributesOf.push(t)
        }
        _setAffectedBoundaries(t) {
          if (!this._affectedStart) {
            this._affectedStart = V_.fromPosition(t, "toPrevious")
          }
          if (!this._affectedEnd || this._affectedEnd.isBefore(t)) {
            if (this._affectedEnd) {
              this._affectedEnd.detach()
            }
            this._affectedEnd = V_.fromPosition(t, "toNext")
          }
        }
        _mergeOnLeft() {
          const t = this._firstNode
          if (!(t instanceof kk)) {
            return
          }
          if (!this._canMergeLeft(t)) {
            return
          }
          const e = V_._createBefore(t)
          e.stickiness = "toNext"
          const n = V_.fromPosition(this.position, "toNext")
          if (this._affectedStart.isEqual(e)) {
            this._affectedStart.detach()
            this._affectedStart = V_._createAt(e.nodeBefore, "end", "toPrevious")
          }
          if (this._firstNode === this._lastNode) {
            this._firstNode = e.nodeBefore
            this._lastNode = e.nodeBefore
          }
          this.writer.merge(e)
          if (e.isEqual(this._affectedEnd) && this._firstNode === this._lastNode) {
            this._affectedEnd.detach()
            this._affectedEnd = V_._createAt(e.nodeBefore, "end", "toNext")
          }
          this.position = n.toPosition()
          n.detach()
          this._filterAttributesOf.push(this.position.parent)
          e.detach()
        }
        _mergeOnRight() {
          const t = this._lastNode
          if (!(t instanceof kk)) {
            return
          }
          if (!this._canMergeRight(t)) {
            return
          }
          const e = V_._createAfter(t)
          e.stickiness = "toNext"
          if (!this.position.isEqual(e)) {
            throw new P("insertcontent-invalid-insertion-position", this)
          }
          this.position = vk._createAt(e.nodeBefore, "end")
          const n = V_.fromPosition(this.position, "toPrevious")
          if (this._affectedEnd.isEqual(e)) {
            this._affectedEnd.detach()
            this._affectedEnd = V_._createAt(e.nodeBefore, "end", "toNext")
          }
          if (this._firstNode === this._lastNode) {
            this._firstNode = e.nodeBefore
            this._lastNode = e.nodeBefore
          }
          this.writer.merge(e)
          if (
            e.getShiftedBy(-1).isEqual(this._affectedStart) &&
            this._firstNode === this._lastNode
          ) {
            this._affectedStart.detach()
            this._affectedStart = V_._createAt(e.nodeBefore, 0, "toPrevious")
          }
          this.position = n.toPosition()
          n.detach()
          this._filterAttributesOf.push(this.position.parent)
          e.detach()
        }
        _canMergeLeft(t) {
          const e = t.previousSibling
          return e instanceof kk && this.canMergeWith.has(e) && this.model.schema.checkMerge(e, t)
        }
        _canMergeRight(t) {
          const e = t.nextSibling
          return e instanceof kk && this.canMergeWith.has(e) && this.model.schema.checkMerge(t, e)
        }
        _tryAutoparagraphing(t) {
          const e = this.writer.createElement("paragraph")
          if (this._getAllowedIn(this.position.parent, e) && this.schema.checkChild(e, t)) {
            e._appendChild(t)
            this._handleNode(e)
          }
        }
        _checkAndAutoParagraphToAllowedPosition(t) {
          if (this.schema.checkChild(this.position.parent, t)) {
            return true
          }
          if (
            !this.schema.checkChild(this.position.parent, "paragraph") ||
            !this.schema.checkChild("paragraph", t)
          ) {
            return false
          }
          this._insertPartialFragment()
          const e = this.writer.createElement("paragraph")
          this.writer.insert(e, this.position)
          this._setAffectedBoundaries(this.position)
          this._lastAutoParagraph = e
          this.position = this.writer.createPositionAt(e, 0)
          return true
        }
        _checkAndSplitToAllowedPosition(t) {
          const e = this._getAllowedIn(this.position.parent, t)
          if (!e) {
            return false
          }
          if (e != this.position.parent) {
            this._insertPartialFragment()
          }
          while (e != this.position.parent) {
            if (this.position.isAtStart) {
              const t = this.position.parent
              this.position = this.writer.createPositionBefore(t)
              if (t.isEmpty && t.parent === e) {
                this.writer.remove(t)
              }
            } else if (this.position.isAtEnd) {
              this.position = this.writer.createPositionAfter(this.position.parent)
            } else {
              const t = this.writer.createPositionAfter(this.position.parent)
              this._setAffectedBoundaries(this.position)
              this.writer.split(this.position)
              this.position = t
              this.canMergeWith.add(this.position.nodeAfter)
            }
          }
          return true
        }
        _getAllowedIn(t, e) {
          if (this.schema.checkChild(t, e)) {
            return t
          }
          if (this.schema.isLimit(t)) {
            return null
          }
          return this._getAllowedIn(t.parent, e)
        }
      }
      function Sv(t, e, n = "auto") {
        const o = t.getSelectedElement()
        if (o && e.schema.isObject(o) && !e.schema.isInline(o)) {
          if (n == "before" || n == "after") {
            return e.createRange(e.createPositionAt(o, n))
          }
          return e.createRangeOn(o)
        }
        const r = hl(t.getSelectedBlocks())
        if (!r) {
          return e.createRange(t.focus)
        }
        if (r.isEmpty) {
          return e.createRange(e.createPositionAt(r, 0))
        }
        const i = e.createPositionAfter(r)
        if (t.focus.isTouching(i)) {
          return e.createRange(i)
        }
        return e.createRange(e.createPositionBefore(r))
      }
      function Tv(t, e, n, o = {}) {
        if (!t.schema.isObject(e)) {
          throw new P("insertobject-element-not-an-object", t, { object: e })
        }
        const r = n ? n : t.document.selection
        let i = r
        if (o.findOptimalPosition && t.schema.isBlock(e)) {
          i = t.createSelection(Sv(r, t, o.findOptimalPosition))
        }
        const s = hl(r.getSelectedBlocks())
        const a = {}
        if (s) {
          Object.assign(a, t.schema.getAttributesWithProperty(s, "copyOnReplace", true))
        }
        return t.change((n) => {
          if (!i.isCollapsed) {
            t.deleteContent(i, { doNotAutoparagraph: true })
          }
          let r = e
          const s = i.anchor.parent
          if (
            !t.schema.checkChild(s, e) &&
            t.schema.checkChild(s, "paragraph") &&
            t.schema.checkChild("paragraph", e)
          ) {
            r = n.createElement("paragraph")
            n.insert(e, r)
          }
          t.schema.setAllowedAttributes(r, a, n)
          const c = t.insertContent(r, i)
          if (c.isCollapsed) {
            return c
          }
          if (o.setSelection) {
            Pv(n, e, o.setSelection, a)
          }
          return c
        })
      }
      function Pv(t, e, n, o) {
        const r = t.model
        if (n == "on") {
          t.setSelection(e, "on")
          return
        }
        if (n != "after") {
          throw new P("insertobject-invalid-place-parameter-value", r)
        }
        let i = e.nextSibling
        if (r.schema.isInline(e)) {
          t.setSelection(e, "after")
          return
        }
        const s = i && r.schema.checkChild(i, "$text")
        if (!s && r.schema.checkChild(e.parent, "paragraph")) {
          i = t.createElement("paragraph")
          r.schema.setAllowedAttributes(i, o, t)
          r.insertContent(i, t.createPositionAfter(e))
        }
        if (i) {
          t.setSelection(i, 0)
        }
      }
      const Bv = ' ,.?!:;"-()'
      function Rv(t, e, n = {}) {
        const o = t.schema
        const r = n.direction != "backward"
        const i = n.unit ? n.unit : "character"
        const s = !!n.treatEmojiAsSingleUnit
        const a = e.focus
        const c = new wk({
          boundaries: zv(a, r),
          singleCharacters: true,
          direction: r ? "forward" : "backward",
        })
        const l = { walker: c, schema: o, isForward: r, unit: i, treatEmojiAsSingleUnit: s }
        let d
        while ((d = c.next())) {
          if (d.done) {
            return
          }
          const n = Ov(l, d.value)
          if (n) {
            if (e instanceof Jk) {
              t.change((t) => {
                t.setSelectionFocus(n)
              })
            } else {
              e.setFocus(n)
            }
            return
          }
        }
      }
      function Ov(t, e) {
        const { isForward: n, walker: o, unit: r, schema: i, treatEmojiAsSingleUnit: s } = t
        const { type: a, item: c, nextPosition: l } = e
        if (a == "text") {
          if (t.unit === "word") {
            return Iv(o, n)
          }
          return Mv(o, r, s)
        }
        if (a == (n ? "elementStart" : "elementEnd")) {
          if (i.isSelectable(c)) {
            return vk._createAt(c, n ? "after" : "before")
          }
          if (i.checkChild(l, "$text")) {
            return l
          }
        } else {
          if (i.isLimit(c)) {
            o.skip(() => true)
            return
          }
          if (i.checkChild(l, "$text")) {
            return l
          }
        }
      }
      function Mv(t, e, n) {
        const o = t.position.textNode
        if (o) {
          const r = o.data
          let i = t.position.offset - o.startOffset
          while (Cl(r, i) || (e == "character" && yl(r, i)) || (n && El(r, i))) {
            t.next()
            i = t.position.offset - o.startOffset
          }
        }
        return t.position
      }
      function Iv(t, e) {
        let n = t.position.textNode
        if (!n) {
          n = e ? t.position.nodeAfter : t.position.nodeBefore
        }
        while (n && n.is("$text")) {
          const o = t.position.offset - n.startOffset
          if (Fv(n, o, e)) {
            n = e ? t.position.nodeAfter : t.position.nodeBefore
          } else if (Nv(n.data, o, e)) {
            break
          } else {
            t.next()
          }
        }
        return t.position
      }
      function zv(t, e) {
        const n = t.root
        const o = vk._createAt(n, e ? "end" : 0)
        if (e) {
          return new Sk(t, o)
        } else {
          return new Sk(o, t)
        }
      }
      function Nv(t, e, n) {
        const o = e + (n ? 0 : -1)
        return Bv.includes(t.charAt(o))
      }
      function Fv(t, e, n) {
        return e === (n ? t.offsetSize : 0)
      }
      class Vv extends dt() {
        constructor() {
          super()
          this.markers = new Q_()
          this.document = new Z_(this)
          this.schema = new Dw()
          this._pendingChanges = []
          this._currentWriter = null
          ;["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach(
            (t) => this.decorate(t)
          )
          this.on(
            "applyOperation",
            (t, e) => {
              const n = e[0]
              n._validate()
            },
            { priority: "highest" }
          )
          this.schema.register("$root", { isLimit: true })
          this.schema.register("$container", { allowIn: ["$root", "$container"] })
          this.schema.register("$block", { allowIn: ["$root", "$container"], isBlock: true })
          this.schema.register("$blockObject", {
            allowWhere: "$block",
            isBlock: true,
            isObject: true,
          })
          this.schema.register("$inlineObject", {
            allowWhere: "$text",
            allowAttributesOf: "$text",
            isInline: true,
            isObject: true,
          })
          this.schema.register("$text", { allowIn: "$block", isInline: true, isContent: true })
          this.schema.register("$clipboardHolder", {
            allowContentOf: "$root",
            allowChildren: "$text",
            isLimit: true,
          })
          this.schema.register("$documentFragment", {
            allowContentOf: "$root",
            allowChildren: "$text",
            isLimit: true,
          })
          this.schema.register("$marker")
          this.schema.addChildCheck((t, e) => {
            if (e.name === "$marker") {
              return true
            }
          })
          fw(this)
          this.document.registerPostFixer(qb)
          this.on("insertContent", (t, [e, n]) => {
            t.return = Ev(this, e, n)
          })
          this.on("insertObject", (t, [e, n, o]) => {
            t.return = Tv(this, e, n, o)
          })
          this.on("canEditAt", (t) => {
            const e = !this.document.isReadOnly
            t.return = e
            if (!e) {
              t.stop()
            }
          })
        }
        change(t) {
          try {
            if (this._pendingChanges.length === 0) {
              this._pendingChanges.push({ batch: new H_(), callback: t })
              return this._runPendingChanges()[0]
            } else {
              return t(this._currentWriter)
            }
          } catch (t) {
            P.rethrowUnexpectedError(t, this)
          }
        }
        enqueueChange(t, e) {
          try {
            if (!t) {
              t = new H_()
            } else if (typeof t === "function") {
              e = t
              t = new H_()
            } else if (!(t instanceof H_)) {
              t = new H_(t)
            }
            this._pendingChanges.push({ batch: t, callback: e })
            if (this._pendingChanges.length == 1) {
              this._runPendingChanges()
            }
          } catch (t) {
            P.rethrowUnexpectedError(t, this)
          }
        }
        applyOperation(t) {
          t._execute()
        }
        insertContent(t, e, n, ...o) {
          const r = Lv(e, n)
          return this.fire("insertContent", [t, r, n, ...o])
        }
        insertObject(t, e, n, o, ...r) {
          const i = Lv(e, n)
          return this.fire("insertObject", [t, i, o, o, ...r])
        }
        deleteContent(t, e) {
          lv(this, t, e)
        }
        modifySelection(t, e) {
          Rv(this, t, e)
        }
        getSelectedContent(t) {
          return yv(this, t)
        }
        hasContent(t, e = {}) {
          const n = t instanceof Sk ? t : Sk._createIn(t)
          if (n.isCollapsed) {
            return false
          }
          const { ignoreWhitespaces: o = false, ignoreMarkers: r = false } = e
          if (!r) {
            for (const t of this.markers.getMarkersIntersectingRange(n)) {
              if (t.affectsData) {
                return true
              }
            }
          }
          for (const t of n.getItems()) {
            if (this.schema.isContent(t)) {
              if (t.is("$textProxy")) {
                if (!o) {
                  return true
                } else if (t.data.search(/\S/) !== -1) {
                  return true
                }
              } else {
                return true
              }
            }
          }
          return false
        }
        canEditAt(t) {
          const e = Lv(t)
          return this.fire("canEditAt", [e])
        }
        createPositionFromPath(t, e, n) {
          return new vk(t, e, n)
        }
        createPositionAt(t, e) {
          return vk._createAt(t, e)
        }
        createPositionAfter(t) {
          return vk._createAfter(t)
        }
        createPositionBefore(t) {
          return vk._createBefore(t)
        }
        createRange(t, e) {
          return new Sk(t, e)
        }
        createRangeIn(t) {
          return Sk._createIn(t)
        }
        createRangeOn(t) {
          return Sk._createOn(t)
        }
        createSelection(...t) {
          return new zk(...t)
        }
        createBatch(t) {
          return new H_(t)
        }
        createOperationFromJSON(t) {
          return x_.fromJSON(t, this.document)
        }
        destroy() {
          this.document.destroy()
          this.stopListening()
        }
        _runPendingChanges() {
          const t = []
          this.fire("_beforeChanges")
          try {
            while (this._pendingChanges.length) {
              const e = this._pendingChanges[0].batch
              this._currentWriter = new ov(this, e)
              const n = this._pendingChanges[0].callback(this._currentWriter)
              t.push(n)
              this.document._handleChangeBlock(this._currentWriter)
              this._pendingChanges.shift()
              this._currentWriter = null
            }
          } finally {
            this._pendingChanges.length = 0
            this._currentWriter = null
            this.fire("_afterChanges")
          }
          return t
        }
      }
      function Lv(t, e) {
        if (!t) {
          return
        }
        if (t instanceof zk || t instanceof Jk) {
          return t
        }
        if (t instanceof fk) {
          if (e || e === 0) {
            return new zk(t, e)
          } else if (t.is("rootElement")) {
            return new zk(t, "in")
          } else {
            return new zk(t, "on")
          }
        }
        return new zk(t)
      }
      class jv extends (null && DomEventObserver) {
        constructor() {
          super(...arguments)
          this.domEventType = "click"
        }
        onDomEvent(t) {
          this.fire(t.type, t)
        }
      }
      class Hv extends Tg {
        constructor() {
          super(...arguments)
          this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"]
        }
        onDomEvent(t) {
          this.fire(t.type, t)
        }
      }
      class Wv {
        constructor(t) {
          this.document = t
        }
        createDocumentFragment(t) {
          return new DocumentFragment(this.document, t)
        }
        createElement(t, e, n) {
          return new Element(this.document, t, e, n)
        }
        createText(t) {
          return new Text(this.document, t)
        }
        clone(t, e = false) {
          return t._clone(e)
        }
        appendChild(t, e) {
          return e._appendChild(t)
        }
        insertChild(t, e, n) {
          return n._insertChild(t, e)
        }
        removeChildren(t, e, n) {
          return n._removeChildren(t, e)
        }
        remove(t) {
          const e = t.parent
          if (e) {
            return this.removeChildren(e.getChildIndex(t), 1, e)
          }
          return []
        }
        replace(t, e) {
          const n = t.parent
          if (n) {
            const o = n.getChildIndex(t)
            this.removeChildren(o, 1, n)
            this.insertChild(o, e, n)
            return true
          }
          return false
        }
        unwrapElement(t) {
          const e = t.parent
          if (e) {
            const n = e.getChildIndex(t)
            this.remove(t)
            this.insertChild(n, t.getChildren(), e)
          }
        }
        rename(t, e) {
          const n = new Element(this.document, t, e.getAttributes(), e.getChildren())
          return this.replace(e, n) ? n : null
        }
        setAttribute(t, e, n) {
          n._setAttribute(t, e)
        }
        removeAttribute(t, e) {
          e._removeAttribute(t)
        }
        addClass(t, e) {
          e._addClass(t)
        }
        removeClass(t, e) {
          e._removeClass(t)
        }
        setStyle(t, e, n) {
          if (isPlainObject(t) && n === undefined) {
            e._setStyle(t)
          } else {
            n._setStyle(t, e)
          }
        }
        removeStyle(t, e) {
          e._removeStyle(t)
        }
        setCustomProperty(t, e, n) {
          n._setCustomProperty(t, e)
        }
        removeCustomProperty(t, e) {
          return e._removeCustomProperty(t)
        }
        createPositionAt(t, e) {
          return Position._createAt(t, e)
        }
        createPositionAfter(t) {
          return Position._createAfter(t)
        }
        createPositionBefore(t) {
          return Position._createBefore(t)
        }
        createRange(t, e) {
          return new Range(t, e)
        }
        createRangeOn(t) {
          return Range._createOn(t)
        }
        createRangeIn(t) {
          return Range._createIn(t)
        }
        createSelection(...t) {
          return new Selection(...t)
        }
      }
      const qv = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i
      const $v = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i
      const Kv = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i
      const Gv = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i
      const Uv = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i
      const Jv = /\w+\((?:[^()]|\([^()]*\))*\)|\S+/gi
      const Zv = new Set([
        "black",
        "silver",
        "gray",
        "white",
        "maroon",
        "red",
        "purple",
        "fuchsia",
        "green",
        "lime",
        "olive",
        "yellow",
        "navy",
        "blue",
        "teal",
        "aqua",
        "orange",
        "aliceblue",
        "antiquewhite",
        "aquamarine",
        "azure",
        "beige",
        "bisque",
        "blanchedalmond",
        "blueviolet",
        "brown",
        "burlywood",
        "cadetblue",
        "chartreuse",
        "chocolate",
        "coral",
        "cornflowerblue",
        "cornsilk",
        "crimson",
        "cyan",
        "darkblue",
        "darkcyan",
        "darkgoldenrod",
        "darkgray",
        "darkgreen",
        "darkgrey",
        "darkkhaki",
        "darkmagenta",
        "darkolivegreen",
        "darkorange",
        "darkorchid",
        "darkred",
        "darksalmon",
        "darkseagreen",
        "darkslateblue",
        "darkslategray",
        "darkslategrey",
        "darkturquoise",
        "darkviolet",
        "deeppink",
        "deepskyblue",
        "dimgray",
        "dimgrey",
        "dodgerblue",
        "firebrick",
        "floralwhite",
        "forestgreen",
        "gainsboro",
        "ghostwhite",
        "gold",
        "goldenrod",
        "greenyellow",
        "grey",
        "honeydew",
        "hotpink",
        "indianred",
        "indigo",
        "ivory",
        "khaki",
        "lavender",
        "lavenderblush",
        "lawngreen",
        "lemonchiffon",
        "lightblue",
        "lightcoral",
        "lightcyan",
        "lightgoldenrodyellow",
        "lightgray",
        "lightgreen",
        "lightgrey",
        "lightpink",
        "lightsalmon",
        "lightseagreen",
        "lightskyblue",
        "lightslategray",
        "lightslategrey",
        "lightsteelblue",
        "lightyellow",
        "limegreen",
        "linen",
        "magenta",
        "mediumaquamarine",
        "mediumblue",
        "mediumorchid",
        "mediumpurple",
        "mediumseagreen",
        "mediumslateblue",
        "mediumspringgreen",
        "mediumturquoise",
        "mediumvioletred",
        "midnightblue",
        "mintcream",
        "mistyrose",
        "moccasin",
        "navajowhite",
        "oldlace",
        "olivedrab",
        "orangered",
        "orchid",
        "palegoldenrod",
        "palegreen",
        "paleturquoise",
        "palevioletred",
        "papayawhip",
        "peachpuff",
        "peru",
        "pink",
        "plum",
        "powderblue",
        "rosybrown",
        "royalblue",
        "saddlebrown",
        "salmon",
        "sandybrown",
        "seagreen",
        "seashell",
        "sienna",
        "skyblue",
        "slateblue",
        "slategray",
        "slategrey",
        "snow",
        "springgreen",
        "steelblue",
        "tan",
        "thistle",
        "tomato",
        "turquoise",
        "violet",
        "wheat",
        "whitesmoke",
        "yellowgreen",
        "activeborder",
        "activecaption",
        "appworkspace",
        "background",
        "buttonface",
        "buttonhighlight",
        "buttonshadow",
        "buttontext",
        "captiontext",
        "graytext",
        "highlight",
        "highlighttext",
        "inactiveborder",
        "inactivecaption",
        "inactivecaptiontext",
        "infobackground",
        "infotext",
        "menu",
        "menutext",
        "scrollbar",
        "threeddarkshadow",
        "threedface",
        "threedhighlight",
        "threedlightshadow",
        "threedshadow",
        "window",
        "windowframe",
        "windowtext",
        "rebeccapurple",
        "currentcolor",
        "transparent",
      ])
      function Yv(t) {
        if (t.startsWith("#")) {
          return qv.test(t)
        }
        if (t.startsWith("rgb")) {
          return $v.test(t) || Kv.test(t)
        }
        if (t.startsWith("hsl")) {
          return Gv.test(t) || Uv.test(t)
        }
        return Zv.has(t.toLowerCase())
      }
      const Qv = null && [
        "none",
        "hidden",
        "dotted",
        "dashed",
        "solid",
        "double",
        "groove",
        "ridge",
        "inset",
        "outset",
      ]
      function Xv(t) {
        return Qv.includes(t)
      }
      const tA = /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/
      function eA(t) {
        return tA.test(t)
      }
      const nA = /^[+-]?[0-9]*([.][0-9]+)?%$/
      function oA(t) {
        return nA.test(t)
      }
      const rA = null && ["repeat-x", "repeat-y", "repeat", "space", "round", "no-repeat"]
      function iA(t) {
        return rA.includes(t)
      }
      const sA = null && ["center", "top", "bottom", "left", "right"]
      function aA(t) {
        return sA.includes(t)
      }
      const cA = null && ["fixed", "scroll", "local"]
      function lA(t) {
        return cA.includes(t)
      }
      const dA = /^url\(/
      function hA(t) {
        return dA.test(t)
      }
      function uA(t = "") {
        if (t === "") {
          return { top: undefined, right: undefined, bottom: undefined, left: undefined }
        }
        const e = mA(t)
        const n = e[0]
        const o = e[2] || n
        const r = e[1] || n
        const i = e[3] || r
        return { top: n, bottom: o, right: r, left: i }
      }
      function fA(t) {
        return (e) => {
          const { top: n, right: o, bottom: r, left: i } = e
          const s = []
          if (![n, o, i, r].every((t) => !!t)) {
            if (n) {
              s.push([t + "-top", n])
            }
            if (o) {
              s.push([t + "-right", o])
            }
            if (r) {
              s.push([t + "-bottom", r])
            }
            if (i) {
              s.push([t + "-left", i])
            }
          } else {
            s.push([t, pA(e)])
          }
          return s
        }
      }
      function pA({ top: t, right: e, bottom: n, left: o }) {
        const r = []
        if (o !== e) {
          r.push(t, e, n, o)
        } else if (n !== t) {
          r.push(t, e, n)
        } else if (e !== t) {
          r.push(t, e)
        } else {
          r.push(t)
        }
        return r.join(" ")
      }
      function gA(t) {
        return (e) => ({ path: t, value: uA(e) })
      }
      function mA(t) {
        const e = t.matchAll(Jv)
        return Array.from(e).map((t) => t[0])
      }
      function kA(t) {
        t.setNormalizer("background", bA())
        t.setNormalizer("background-color", wA())
        t.setReducer("background", _A())
        t.setStyleRelation("background", ["background-color"])
      }
      function bA() {
        return (t) => {
          const e = {}
          const n = getShorthandValues(t)
          for (const t of n) {
            if (isRepeat(t)) {
              e.repeat = e.repeat || []
              e.repeat.push(t)
            } else if (isPosition(t)) {
              e.position = e.position || []
              e.position.push(t)
            } else if (isAttachment(t)) {
              e.attachment = t
            } else if (isColor(t)) {
              e.color = t
            } else if (isURL(t)) {
              e.image = t
            }
          }
          return { path: "background", value: e }
        }
      }
      function wA() {
        return (t) => ({ path: "background.color", value: t })
      }
      function _A() {
        return (t) => {
          const e = []
          e.push(["background-color", t.color])
          return e
        }
      }
      function vA(t) {
        t.setNormalizer("border", AA())
        t.setNormalizer("border-top", CA("top"))
        t.setNormalizer("border-right", CA("right"))
        t.setNormalizer("border-bottom", CA("bottom"))
        t.setNormalizer("border-left", CA("left"))
        t.setNormalizer("border-color", yA("color"))
        t.setNormalizer("border-width", yA("width"))
        t.setNormalizer("border-style", yA("style"))
        t.setNormalizer("border-top-color", EA("color", "top"))
        t.setNormalizer("border-top-style", EA("style", "top"))
        t.setNormalizer("border-top-width", EA("width", "top"))
        t.setNormalizer("border-right-color", EA("color", "right"))
        t.setNormalizer("border-right-style", EA("style", "right"))
        t.setNormalizer("border-right-width", EA("width", "right"))
        t.setNormalizer("border-bottom-color", EA("color", "bottom"))
        t.setNormalizer("border-bottom-style", EA("style", "bottom"))
        t.setNormalizer("border-bottom-width", EA("width", "bottom"))
        t.setNormalizer("border-left-color", EA("color", "left"))
        t.setNormalizer("border-left-style", EA("style", "left"))
        t.setNormalizer("border-left-width", EA("width", "left"))
        t.setExtractor("border-top", DA("top"))
        t.setExtractor("border-right", DA("right"))
        t.setExtractor("border-bottom", DA("bottom"))
        t.setExtractor("border-left", DA("left"))
        t.setExtractor("border-top-color", "border.color.top")
        t.setExtractor("border-right-color", "border.color.right")
        t.setExtractor("border-bottom-color", "border.color.bottom")
        t.setExtractor("border-left-color", "border.color.left")
        t.setExtractor("border-top-width", "border.width.top")
        t.setExtractor("border-right-width", "border.width.right")
        t.setExtractor("border-bottom-width", "border.width.bottom")
        t.setExtractor("border-left-width", "border.width.left")
        t.setExtractor("border-top-style", "border.style.top")
        t.setExtractor("border-right-style", "border.style.right")
        t.setExtractor("border-bottom-style", "border.style.bottom")
        t.setExtractor("border-left-style", "border.style.left")
        t.setReducer("border-color", getBoxSidesValueReducer("border-color"))
        t.setReducer("border-style", getBoxSidesValueReducer("border-style"))
        t.setReducer("border-width", getBoxSidesValueReducer("border-width"))
        t.setReducer("border-top", BA("top"))
        t.setReducer("border-right", BA("right"))
        t.setReducer("border-bottom", BA("bottom"))
        t.setReducer("border-left", BA("left"))
        t.setReducer("border", PA())
        t.setStyleRelation("border", [
          "border-color",
          "border-style",
          "border-width",
          "border-top",
          "border-right",
          "border-bottom",
          "border-left",
          "border-top-color",
          "border-right-color",
          "border-bottom-color",
          "border-left-color",
          "border-top-style",
          "border-right-style",
          "border-bottom-style",
          "border-left-style",
          "border-top-width",
          "border-right-width",
          "border-bottom-width",
          "border-left-width",
        ])
        t.setStyleRelation("border-color", [
          "border-top-color",
          "border-right-color",
          "border-bottom-color",
          "border-left-color",
        ])
        t.setStyleRelation("border-style", [
          "border-top-style",
          "border-right-style",
          "border-bottom-style",
          "border-left-style",
        ])
        t.setStyleRelation("border-width", [
          "border-top-width",
          "border-right-width",
          "border-bottom-width",
          "border-left-width",
        ])
        t.setStyleRelation("border-top", [
          "border-top-color",
          "border-top-style",
          "border-top-width",
        ])
        t.setStyleRelation("border-right", [
          "border-right-color",
          "border-right-style",
          "border-right-width",
        ])
        t.setStyleRelation("border-bottom", [
          "border-bottom-color",
          "border-bottom-style",
          "border-bottom-width",
        ])
        t.setStyleRelation("border-left", [
          "border-left-color",
          "border-left-style",
          "border-left-width",
        ])
      }
      function AA() {
        return (t) => {
          const { color: e, style: n, width: o } = TA(t)
          return {
            path: "border",
            value: {
              color: getBoxSidesValues(e),
              style: getBoxSidesValues(n),
              width: getBoxSidesValues(o),
            },
          }
        }
      }
      function CA(t) {
        return (e) => {
          const { color: n, style: o, width: r } = TA(e)
          const i = {}
          if (n !== undefined) {
            i.color = { [t]: n }
          }
          if (o !== undefined) {
            i.style = { [t]: o }
          }
          if (r !== undefined) {
            i.width = { [t]: r }
          }
          return { path: "border", value: i }
        }
      }
      function yA(t) {
        return (e) => ({ path: "border", value: xA(e, t) })
      }
      function xA(t, e) {
        return { [e]: getBoxSidesValues(t) }
      }
      function EA(t, e) {
        return (n) => ({ path: "border", value: { [t]: { [e]: n } } })
      }
      function DA(t) {
        return (e, n) => {
          if (n.border) {
            return SA(n.border, t)
          }
        }
      }
      function SA(t, e) {
        const n = {}
        if (t.width && t.width[e]) {
          n.width = t.width[e]
        }
        if (t.style && t.style[e]) {
          n.style = t.style[e]
        }
        if (t.color && t.color[e]) {
          n.color = t.color[e]
        }
        return n
      }
      function TA(t) {
        const e = {}
        const n = getShorthandValues(t)
        for (const t of n) {
          if (isLength(t) || /thin|medium|thick/.test(t)) {
            e.width = t
          } else if (isLineStyle(t)) {
            e.style = t
          } else {
            e.color = t
          }
        }
        return e
      }
      function PA() {
        return (e) => {
          const n = SA(e, "top")
          const o = SA(e, "right")
          const r = SA(e, "bottom")
          const i = SA(e, "left")
          const s = [n, o, r, i]
          const a = { width: t(s, "width"), style: t(s, "style"), color: t(s, "color") }
          const c = RA(a, "all")
          if (c.length) {
            return c
          }
          const l = Object.entries(a).reduce((t, [e, n]) => {
            if (n) {
              t.push([`border-${e}`, n])
              s.forEach((t) => delete t[e])
            }
            return t
          }, [])
          return [...l, ...RA(n, "top"), ...RA(o, "right"), ...RA(r, "bottom"), ...RA(i, "left")]
        }
        function t(t, e) {
          return t.map((t) => t[e]).reduce((t, e) => (t == e ? t : null))
        }
      }
      function BA(t) {
        return (e) => RA(e, t)
      }
      function RA(t, e) {
        const n = []
        if (t && t.width) {
          n.push("width")
        }
        if (t && t.style) {
          n.push("style")
        }
        if (t && t.color) {
          n.push("color")
        }
        if (n.length == 3) {
          const o = n.map((e) => t[e]).join(" ")
          return [e == "all" ? ["border", o] : [`border-${e}`, o]]
        }
        if (e == "all") {
          return []
        }
        return n.map((n) => [`border-${e}-${n}`, t[n]])
      }
      function OA(t) {
        t.setNormalizer("margin", getPositionShorthandNormalizer("margin"))
        t.setNormalizer("margin-top", (t) => ({ path: "margin.top", value: t }))
        t.setNormalizer("margin-right", (t) => ({ path: "margin.right", value: t }))
        t.setNormalizer("margin-bottom", (t) => ({ path: "margin.bottom", value: t }))
        t.setNormalizer("margin-left", (t) => ({ path: "margin.left", value: t }))
        t.setReducer("margin", getBoxSidesValueReducer("margin"))
        t.setStyleRelation("margin", ["margin-top", "margin-right", "margin-bottom", "margin-left"])
      }
      function MA(t) {
        t.setNormalizer("padding", getPositionShorthandNormalizer("padding"))
        t.setNormalizer("padding-top", (t) => ({ path: "padding.top", value: t }))
        t.setNormalizer("padding-right", (t) => ({ path: "padding.right", value: t }))
        t.setNormalizer("padding-bottom", (t) => ({ path: "padding.bottom", value: t }))
        t.setNormalizer("padding-left", (t) => ({ path: "padding.left", value: t }))
        t.setReducer("padding", getBoxSidesValueReducer("padding"))
        t.setStyleRelation("padding", [
          "padding-top",
          "padding-right",
          "padding-bottom",
          "padding-left",
        ])
      }
      class IA {
        constructor() {
          this._commands = new Map()
        }
        add(t, e) {
          this._commands.set(t, e)
        }
        get(t) {
          return this._commands.get(t)
        }
        execute(t, ...e) {
          const n = this.get(t)
          if (!n) {
            throw new P("commandcollection-command-not-found", this, { commandName: t })
          }
          return n.execute(...e)
        }
        *names() {
          yield* this._commands.keys()
        }
        *commands() {
          yield* this._commands.values()
        }
        [Symbol.iterator]() {
          return this._commands[Symbol.iterator]()
        }
        destroy() {
          for (const t of this.commands()) {
            t.destroy()
          }
        }
      }
      class zA extends fl {
        constructor(t) {
          super()
          this.editor = t
        }
        set(t, e, n = {}) {
          if (typeof e == "string") {
            const t = e
            e = (e, n) => {
              this.editor.execute(t)
              n()
            }
          }
          super.set(t, e, n)
        }
      }
      class NA extends dt() {
        constructor(t = {}) {
          super()
          const e = this.constructor
          const n = t.language || (e.defaultConfig && e.defaultConfig.language)
          this._context = t.context || new Dh({ language: n })
          this._context._addEditor(this, !t.context)
          const o = Array.from(e.builtinPlugins || [])
          this.config = new Ha(t, e.defaultConfig)
          this.config.define("plugins", o)
          this.config.define(this._context._getEditorConfig())
          this.plugins = new Eh(this, o, this._context.plugins)
          this.locale = this._context.locale
          this.t = this.locale.t
          this._readOnlyLocks = new Set()
          this.commands = new IA()
          this.set("state", "initializing")
          this.once("ready", () => (this.state = "ready"), { priority: "high" })
          this.once("destroy", () => (this.state = "destroyed"), { priority: "high" })
          this.model = new Vv()
          this.on("change:isReadOnly", () => {
            this.model.document.isReadOnly = this.isReadOnly
          })
          const r = new qf()
          this.data = new Qw(this.model, r)
          this.editing = new Aw(this.model, r)
          this.editing.view.document.bind("isReadOnly").to(this)
          this.conversion = new t_(
            [this.editing.downcastDispatcher, this.data.downcastDispatcher],
            this.data.upcastDispatcher
          )
          this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher)
          this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher)
          this.keystrokes = new zA(this)
          this.keystrokes.listenTo(this.editing.view.document)
        }
        get isReadOnly() {
          return this._readOnlyLocks.size > 0
        }
        set isReadOnly(t) {
          throw new P("editor-isreadonly-has-no-setter")
        }
        enableReadOnlyMode(t) {
          if (typeof t !== "string" && typeof t !== "symbol") {
            throw new P("editor-read-only-lock-id-invalid", null, { lockId: t })
          }
          if (this._readOnlyLocks.has(t)) {
            return
          }
          this._readOnlyLocks.add(t)
          if (this._readOnlyLocks.size === 1) {
            this.fire("change:isReadOnly", "isReadOnly", true, false)
          }
        }
        disableReadOnlyMode(t) {
          if (typeof t !== "string" && typeof t !== "symbol") {
            throw new P("editor-read-only-lock-id-invalid", null, { lockId: t })
          }
          if (!this._readOnlyLocks.has(t)) {
            return
          }
          this._readOnlyLocks.delete(t)
          if (this._readOnlyLocks.size === 0) {
            this.fire("change:isReadOnly", "isReadOnly", false, true)
          }
        }
        initPlugins() {
          const t = this.config
          const e = t.get("plugins")
          const n = t.get("removePlugins") || []
          const o = t.get("extraPlugins") || []
          const r = t.get("substitutePlugins") || []
          return this.plugins.init(e.concat(o), n, r)
        }
        destroy() {
          let t = Promise.resolve()
          if (this.state == "initializing") {
            t = new Promise((t) => this.once("ready", t))
          }
          return t
            .then(() => {
              this.fire("destroy")
              this.stopListening()
              this.commands.destroy()
            })
            .then(() => this.plugins.destroy())
            .then(() => {
              this.model.destroy()
              this.data.destroy()
              this.editing.destroy()
              this.keystrokes.destroy()
            })
            .then(() => this._context._removeEditor(this))
        }
        execute(t, ...e) {
          try {
            return this.commands.execute(t, ...e)
          } catch (t) {
            P.rethrowUnexpectedError(t, this)
          }
        }
        focus() {
          this.editing.view.focus()
        }
        static create(...t) {
          throw new Error("This is an abstract method.")
        }
      }
      function FA(t) {
        if (!qe(t.updateSourceElement)) {
          throw new P("attachtoform-missing-elementapi-interface", t)
        }
        const e = t.sourceElement
        if (VA(e) && e.form) {
          let n
          const o = e.form
          const r = () => t.updateSourceElement()
          if (qe(o.submit)) {
            n = o.submit
            o.submit = () => {
              r()
              n.apply(o)
            }
          }
          o.addEventListener("submit", r)
          t.on("destroy", () => {
            o.removeEventListener("submit", r)
            if (n) {
              o.submit = n
            }
          })
        }
      }
      function VA(t) {
        return !!t && t.tagName.toLowerCase() === "textarea"
      }
      function LA(t) {
        class e extends t {
          setData(t) {
            this.data.set(t)
          }
          getData(t) {
            return this.data.get(t)
          }
        }
        return e
      }
      {
        const t = LA(Object)
        LA.setData = t.prototype.setData
        LA.getData = t.prototype.getData
      }
      function jA(t) {
        class e extends t {
          updateSourceElement(t = this.data.get()) {
            if (!this.sourceElement) {
              throw new P("editor-missing-sourceelement", this)
            }
            const e = this.config.get("updateSourceElementOnDestroy")
            const n = this.sourceElement instanceof HTMLTextAreaElement
            if (!e && !n) {
              pc(this.sourceElement, "")
              return
            }
            pc(this.sourceElement, t)
          }
        }
        return e
      }
      jA.updateSourceElement = jA(Object).prototype.updateSourceElement
      function HA(t, e) {
        if (e.ckeditorInstance) {
          throw new CKEditorError("editor-source-element-already-used", t)
        }
        e.ckeditorInstance = t
        t.once("destroy", () => {
          delete e.ckeditorInstance
        })
      }
      class WA extends Sh {
        static get pluginName() {
          return "PendingActions"
        }
        init() {
          this.set("hasAny", false)
          this._actions = new dl({ idProperty: "_id" })
          this._actions.delegate("add", "remove").to(this)
        }
        add(t) {
          if (typeof t !== "string") {
            throw new P("pendingactions-add-invalid-message", this)
          }
          const e = new (dt())()
          e.set("message", t)
          this._actions.add(e)
          this.hasAny = true
          return e
        }
        remove(t) {
          this._actions.remove(t)
          this.hasAny = !!this._actions.length
        }
        get first() {
          return this._actions.get(0)
        }
        [Symbol.iterator]() {
          return this._actions[Symbol.iterator]()
        }
      }
      const qA =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>'
      const $A =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>'
      const KA =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>'
      const GA =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>'
      const UA =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>'
      const JA =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>'
      const ZA =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>'
      const YA =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>'
      const QA =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>'
      const XA =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>'
      const tC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>'
      const eC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>'
      const nC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>'
      const oC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>'
      const rC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>'
      const iC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>'
      const sC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>'
      const aC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>'
      const cC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>'
      const lC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>'
      const dC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>'
      const hC =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>'
      const uC =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>'
      const fC =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>'
      const pC =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>'
      const gC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>'
      const mC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>'
      const kC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>'
      const bC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>'
      const wC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>'
      const _C =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>'
      const vC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>'
      const AC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></svg>'
      const CC =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></svg>'
      const yC = {
        bold: wC,
        cancel: qA,
        caption: $A,
        check: KA,
        cog: GA,
        eraser: UA,
        image: ZA,
        lowVision: JA,
        importExport: CC,
        paragraph: _C,
        plus: vC,
        text: AC,
        alignBottom: YA,
        alignMiddle: QA,
        alignTop: XA,
        alignLeft: tC,
        alignCenter: eC,
        alignRight: nC,
        alignJustify: oC,
        objectLeft: lC,
        objectCenter: iC,
        objectRight: dC,
        objectFullWidth: aC,
        objectInline: cC,
        objectBlockLeft: rC,
        objectBlockRight: sC,
        objectSizeFull: hC,
        objectSizeLarge: uC,
        objectSizeSmall: fC,
        objectSizeMedium: pC,
        pencil: gC,
        pilcrow: mC,
        quote: kC,
        threeVerticalDots: bC,
      }
      var xC = n(571)
      var EC = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      EC.insert = "head"
      EC.singleton = true
      var DC = Bl()(xC.Z, EC)
      const SC = xC.Z.locals || {}
      const { threeVerticalDots: TC } = yC
      const PC = {
        alignLeft: yC.alignLeft,
        bold: yC.bold,
        importExport: yC.importExport,
        paragraph: yC.paragraph,
        plus: yC.plus,
        text: yC.text,
        threeVerticalDots: yC.threeVerticalDots,
      }
      class BC extends zl {
        constructor(t, e) {
          super(t)
          const n = this.bindTemplate
          const o = this.t
          this.options = e || {}
          this.set("ariaLabel", o("Editor toolbar"))
          this.set("maxWidth", "auto")
          this.items = this.createCollection()
          this.focusTracker = new ul()
          this.keystrokes = new fl()
          this.set("class", undefined)
          this.set("isCompact", false)
          this.itemsView = new RC(t)
          this.children = this.createCollection()
          this.children.add(this.itemsView)
          this.focusables = this.createCollection()
          const r = t.uiLanguageDirection === "rtl"
          this._focusCycler = new gh({
            focusables: this.focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
              focusPrevious: [r ? "arrowright" : "arrowleft", "arrowup"],
              focusNext: [r ? "arrowleft" : "arrowright", "arrowdown"],
            },
          })
          const i = ["ck", "ck-toolbar", n.to("class"), n.if("isCompact", "ck-toolbar_compact")]
          if (this.options.shouldGroupWhenFull && this.options.isFloating) {
            i.push("ck-toolbar_floating")
          }
          this.setTemplate({
            tag: "div",
            attributes: {
              class: i,
              role: "toolbar",
              "aria-label": n.to("ariaLabel"),
              style: { maxWidth: n.to("maxWidth") },
              tabindex: -1,
            },
            children: this.children,
            on: { mousedown: wh(this) },
          })
          this._behavior = this.options.shouldGroupWhenFull ? new MC(this) : new OC(this)
        }
        render() {
          super.render()
          this.focusTracker.add(this.element)
          for (const t of this.items) {
            this.focusTracker.add(t.element)
          }
          this.items.on("add", (t, e) => {
            this.focusTracker.add(e.element)
          })
          this.items.on("remove", (t, e) => {
            this.focusTracker.remove(e.element)
          })
          this.keystrokes.listenTo(this.element)
          this._behavior.render(this)
        }
        destroy() {
          this._behavior.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
          return super.destroy()
        }
        focus() {
          this._focusCycler.focusFirst()
        }
        focusLast() {
          this._focusCycler.focusLast()
        }
        fillFromConfig(t, e, n) {
          this.items.addMany(this._buildItemsFromConfig(t, e, n))
        }
        _buildItemsFromConfig(t, e, n) {
          const o = _h(t)
          const r = n || o.removeItems
          const i = this._cleanItemsConfiguration(o.items, e, r)
            .map((t) => {
              if (ot(t)) {
                return this._createNestedToolbarDropdown(t, e, r)
              } else if (t === "|") {
                return new kh()
              } else if (t === "-") {
                return new bh()
              }
              return e.create(t)
            })
            .filter((t) => !!t)
          return i
        }
        _cleanItemsConfiguration(t, e, n) {
          const o = t.filter((t, o, r) => {
            if (t === "|") {
              return true
            }
            if (n.indexOf(t) !== -1) {
              return false
            }
            if (t === "-") {
              if (this.options.shouldGroupWhenFull) {
                B("toolbarview-line-break-ignored-when-grouping-items", r)
                return false
              }
              return true
            }
            if (!ot(t) && !e.has(t)) {
              B("toolbarview-item-unavailable", { item: t })
              return false
            }
            return true
          })
          return this._cleanSeparatorsAndLineBreaks(o)
        }
        _cleanSeparatorsAndLineBreaks(t) {
          const e = (t) => t !== "-" && t !== "|"
          const n = t.length
          const o = t.findIndex(e)
          if (o === -1) {
            return []
          }
          const r = n - t.slice().reverse().findIndex(e)
          return t.slice(o, r).filter((t, n, o) => {
            if (e(t)) {
              return true
            }
            const r = n > 0 && o[n - 1] === t
            return !r
          })
        }
        _createNestedToolbarDropdown(t, e, n) {
          let { label: o, icon: r, items: i, tooltip: s = true, withText: a = false } = t
          i = this._cleanItemsConfiguration(i, e, n)
          if (!i.length) {
            return null
          }
          const c = this.locale
          const l = ny(c)
          if (!o) {
            B("toolbarview-nested-toolbar-dropdown-missing-label", t)
          }
          l.class = "ck-toolbar__nested-toolbar-dropdown"
          l.buttonView.set({ label: o, tooltip: s, withText: !!a })
          if (r !== false) {
            l.buttonView.icon = PC[r] || r || TC
          } else {
            l.buttonView.withText = true
          }
          oy(l, () => l.toolbarView._buildItemsFromConfig(i, e, n))
          return l
        }
      }
      class RC extends zl {
        constructor(t) {
          super(t)
          this.children = this.createCollection()
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-toolbar__items"] },
            children: this.children,
          })
        }
      }
      class OC {
        constructor(t) {
          const e = t.bindTemplate
          t.set("isVertical", false)
          t.itemsView.children.bindTo(t.items).using((t) => t)
          t.focusables.bindTo(t.items).using((t) => t)
          t.extendTemplate({ attributes: { class: [e.if("isVertical", "ck-toolbar_vertical")] } })
        }
        render() {}
        destroy() {}
      }
      class MC {
        constructor(t) {
          this.resizeObserver = null
          this.cachedPadding = null
          this.shouldUpdateGroupingOnNextResize = false
          this.view = t
          this.viewChildren = t.children
          this.viewFocusables = t.focusables
          this.viewItemsView = t.itemsView
          this.viewFocusTracker = t.focusTracker
          this.viewLocale = t.locale
          this.ungroupedItems = t.createCollection()
          this.groupedItems = t.createCollection()
          this.groupedItemsDropdown = this._createGroupedItemsDropdown()
          t.itemsView.children.bindTo(this.ungroupedItems).using((t) => t)
          this.ungroupedItems.on("change", this._updateFocusCycleableItems.bind(this))
          t.children.on("change", this._updateFocusCycleableItems.bind(this))
          t.items.on("change", (t, e) => {
            const n = e.index
            const o = Array.from(e.added)
            for (const t of e.removed) {
              if (n >= this.ungroupedItems.length) {
                this.groupedItems.remove(t)
              } else {
                this.ungroupedItems.remove(t)
              }
            }
            for (let t = n; t < n + o.length; t++) {
              const e = o[t - n]
              if (t > this.ungroupedItems.length) {
                this.groupedItems.add(e, t - this.ungroupedItems.length)
              } else {
                this.ungroupedItems.add(e, t)
              }
            }
            this._updateGrouping()
          })
          t.extendTemplate({ attributes: { class: ["ck-toolbar_grouping"] } })
        }
        render(t) {
          this.viewElement = t.element
          this._enableGroupingOnResize()
          this._enableGroupingOnMaxWidthChange(t)
        }
        destroy() {
          this.groupedItemsDropdown.destroy()
          this.resizeObserver.destroy()
        }
        _updateGrouping() {
          if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
            return
          }
          if (!_c(this.viewElement)) {
            this.shouldUpdateGroupingOnNextResize = true
            return
          }
          const t = this.groupedItems.length
          let e
          while (this._areItemsOverflowing) {
            this._groupLastItem()
            e = true
          }
          if (!e && this.groupedItems.length) {
            while (this.groupedItems.length && !this._areItemsOverflowing) {
              this._ungroupFirstItem()
            }
            if (this._areItemsOverflowing) {
              this._groupLastItem()
            }
          }
          if (this.groupedItems.length !== t) {
            this.view.fire("groupedItemsUpdate")
          }
        }
        get _areItemsOverflowing() {
          if (!this.ungroupedItems.length) {
            return false
          }
          const t = this.viewElement
          const e = this.viewLocale.uiLanguageDirection
          const n = new ac(t.lastChild)
          const o = new ac(t)
          if (!this.cachedPadding) {
            const n = Xa.window.getComputedStyle(t)
            const o = e === "ltr" ? "paddingRight" : "paddingLeft"
            this.cachedPadding = Number.parseInt(n[o])
          }
          if (e === "ltr") {
            return n.right > o.right - this.cachedPadding
          } else {
            return n.left < o.left + this.cachedPadding
          }
        }
        _enableGroupingOnResize() {
          let t
          this.resizeObserver = new fc(this.viewElement, (e) => {
            if (!t || t !== e.contentRect.width || this.shouldUpdateGroupingOnNextResize) {
              this.shouldUpdateGroupingOnNextResize = false
              this._updateGrouping()
              t = e.contentRect.width
            }
          })
          this._updateGrouping()
        }
        _enableGroupingOnMaxWidthChange(t) {
          t.on("change:maxWidth", () => {
            this._updateGrouping()
          })
        }
        _groupLastItem() {
          if (!this.groupedItems.length) {
            this.viewChildren.add(new kh())
            this.viewChildren.add(this.groupedItemsDropdown)
            this.viewFocusTracker.add(this.groupedItemsDropdown.element)
          }
          this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0)
        }
        _ungroupFirstItem() {
          this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first))
          if (!this.groupedItems.length) {
            this.viewChildren.remove(this.groupedItemsDropdown)
            this.viewChildren.remove(this.viewChildren.last)
            this.viewFocusTracker.remove(this.groupedItemsDropdown.element)
          }
        }
        _createGroupedItemsDropdown() {
          const t = this.viewLocale
          const e = t.t
          const n = ny(t)
          n.class = "ck-toolbar__grouped-dropdown"
          n.panelPosition = t.uiLanguageDirection === "ltr" ? "sw" : "se"
          oy(n, this.groupedItems)
          n.buttonView.set({
            label: e("Show more items"),
            tooltip: true,
            tooltipPosition: t.uiLanguageDirection === "rtl" ? "se" : "sw",
            icon: TC,
          })
          return n
        }
        _updateFocusCycleableItems() {
          this.viewFocusables.clear()
          this.ungroupedItems.map((t) => {
            this.viewFocusables.add(t)
          })
          if (this.groupedItems.length) {
            this.viewFocusables.add(this.groupedItemsDropdown)
          }
        }
      }
      var IC = n(162)
      var zC = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      zC.insert = "head"
      zC.singleton = true
      var NC = Bl()(IC.Z, zC)
      const FC = IC.Z.locals || {}
      class VC extends (null && View) {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.items = this.createCollection()
          this.focusTracker = new FocusTracker()
          this.keystrokes = new KeystrokeHandler()
          this._focusCycler = new FocusCycler({
            focusables: this.items,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "arrowup", focusNext: "arrowdown" },
          })
          this.set("ariaLabel", undefined)
          this.set("role", undefined)
          this.setTemplate({
            tag: "ul",
            attributes: {
              class: ["ck", "ck-reset", "ck-list"],
              role: e.to("role"),
              "aria-label": e.to("ariaLabel"),
            },
            children: this.items,
          })
        }
        render() {
          super.render()
          for (const t of this.items) {
            this.focusTracker.add(t.element)
          }
          this.items.on("add", (t, e) => {
            this.focusTracker.add(e.element)
          })
          this.items.on("remove", (t, e) => {
            this.focusTracker.remove(e.element)
          })
          this.keystrokes.listenTo(this.element)
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
        }
        focus() {
          this._focusCycler.focusFirst()
        }
        focusLast() {
          this._focusCycler.focusLast()
        }
      }
      class LC extends (null && View) {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.set("isVisible", true)
          this.children = this.createCollection()
          this.setTemplate({
            tag: "li",
            attributes: {
              class: ["ck", "ck-list__item", e.if("isVisible", "ck-hidden", (t) => !t)],
              role: "presentation",
            },
            children: this.children,
          })
        }
        focus() {
          this.children.first.focus()
        }
      }
      class jC extends (null && View) {
        constructor(t) {
          super(t)
          this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__separator"] } })
        }
      }
      var HC = n(66)
      var WC = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      WC.insert = "head"
      WC.singleton = true
      var qC = Bl()(HC.Z, WC)
      const $C = HC.Z.locals || {}
      class KC extends zl {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.set("class", undefined)
          this.set("labelStyle", undefined)
          this.set("icon", undefined)
          this.set("isEnabled", true)
          this.set("isOn", false)
          this.set("isToggleable", false)
          this.set("isVisible", true)
          this.set("keystroke", undefined)
          this.set("withKeystroke", false)
          this.set("label", undefined)
          this.set("tabindex", -1)
          this.set("tooltip", false)
          this.set("tooltipPosition", "s")
          this.set("type", "button")
          this.set("withText", false)
          this.children = this.createCollection()
          this.actionView = this._createActionView()
          this.arrowView = this._createArrowView()
          this.keystrokes = new fl()
          this.focusTracker = new ul()
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-splitbutton",
                e.to("class"),
                e.if("isVisible", "ck-hidden", (t) => !t),
                this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open"),
              ],
            },
            children: this.children,
          })
        }
        render() {
          super.render()
          this.children.add(this.actionView)
          this.children.add(this.arrowView)
          this.focusTracker.add(this.actionView.element)
          this.focusTracker.add(this.arrowView.element)
          this.keystrokes.listenTo(this.element)
          this.keystrokes.set("arrowright", (t, e) => {
            if (this.focusTracker.focusedElement === this.actionView.element) {
              this.arrowView.focus()
              e()
            }
          })
          this.keystrokes.set("arrowleft", (t, e) => {
            if (this.focusTracker.focusedElement === this.arrowView.element) {
              this.actionView.focus()
              e()
            }
          })
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
          this.keystrokes.destroy()
        }
        focus() {
          this.actionView.focus()
        }
        _createActionView() {
          const t = new vd()
          t.bind(
            "icon",
            "isEnabled",
            "isOn",
            "isToggleable",
            "keystroke",
            "label",
            "tabindex",
            "tooltip",
            "tooltipPosition",
            "type",
            "withText"
          ).to(this)
          t.extendTemplate({ attributes: { class: "ck-splitbutton__action" } })
          t.delegate("execute").to(this)
          return t
        }
        _createArrowView() {
          const t = new vd()
          const e = t.bindTemplate
          t.icon = fh
          t.extendTemplate({
            attributes: {
              class: ["ck-splitbutton__arrow"],
              "data-cke-tooltip-disabled": e.to("isOn"),
              "aria-haspopup": true,
              "aria-expanded": e.to("isOn", (t) => String(t)),
            },
          })
          t.bind("isEnabled").to(this)
          t.bind("label").to(this)
          t.bind("tooltip").to(this)
          t.delegate("execute").to(this, "open")
          return t
        }
      }
      function GC({ emitter: t, activator: e, callback: n, contextElements: o }) {
        t.listenTo(document, "mousedown", (t, r) => {
          if (!e()) {
            return
          }
          const i = typeof r.composedPath == "function" ? r.composedPath() : []
          const s = typeof o == "function" ? o() : o
          for (const t of s) {
            if (t.contains(r.target) || i.includes(t)) {
              return
            }
          }
          n()
        })
      }
      var UC = n(75)
      var JC = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      JC.insert = "head"
      JC.singleton = true
      var ZC = Bl()(UC.Z, JC)
      const YC = UC.Z.locals || {}
      var QC = n(875)
      var XC = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      XC.insert = "head"
      XC.singleton = true
      var ty = Bl()(QC.Z, XC)
      const ey = QC.Z.locals || {}
      function ny(t, e = ph) {
        const n = new e(t)
        const o = new ah(t)
        const r = new uh(t, n, o)
        n.bind("isEnabled").to(r)
        if (n instanceof KC) {
          n.arrowView.bind("isOn").to(r, "isOpen")
        } else {
          n.bind("isOn").to(r, "isOpen")
        }
        cy(r)
        return r
      }
      function oy(t, e, n = {}) {
        t.extendTemplate({ attributes: { class: ["ck-toolbar-dropdown"] } })
        if (t.isOpen) {
          ry(t, e, n)
        } else {
          t.once("change:isOpen", () => ry(t, e, n), { priority: "highest" })
        }
        if (n.enableActiveItemFocusOnDropdownOpen) {
          ay(t, () => t.toolbarView.items.find((t) => t.isOn))
        }
      }
      function ry(t, e, n) {
        const o = t.locale
        const r = o.t
        const i = (t.toolbarView = new BC(o))
        const s = typeof e == "function" ? e() : e
        i.ariaLabel = n.ariaLabel || r("Dropdown toolbar")
        if (n.maxWidth) {
          i.maxWidth = n.maxWidth
        }
        if (n.class) {
          i.class = n.class
        }
        if (n.isCompact) {
          i.isCompact = n.isCompact
        }
        if (n.isVertical) {
          i.isVertical = true
        }
        if (s instanceof Sl) {
          i.items.bindTo(s).using((t) => t)
        } else {
          i.items.addMany(s)
        }
        t.panelView.children.add(i)
        i.items.delegate("execute").to(t)
      }
      function iy(t, e, n = {}) {
        if (t.isOpen) {
          sy(t, e, n)
        } else {
          t.once("change:isOpen", () => sy(t, e, n), { priority: "highest" })
        }
        ay(t, () =>
          t.listView.items.find((t) => {
            if (t instanceof ListItemView) {
              return t.children.first.isOn
            }
            return false
          })
        )
      }
      function sy(t, e, n) {
        const o = t.locale
        const r = (t.listView = new ListView(o))
        const i = typeof e == "function" ? e() : e
        r.ariaLabel = n.ariaLabel
        r.role = n.role
        r.items.bindTo(i).using((t) => {
          if (t.type === "separator") {
            return new ListSeparatorView(o)
          } else if (t.type === "button" || t.type === "switchbutton") {
            const e = new ListItemView(o)
            let n
            if (t.type === "button") {
              n = new ButtonView(o)
            } else {
              n = new SwitchButtonView(o)
            }
            n.bind(...Object.keys(t.model)).to(t.model)
            n.delegate("execute").to(e)
            e.children.add(n)
            return e
          }
          return null
        })
        t.panelView.children.add(r)
        r.items.delegate("execute").to(t)
      }
      function ay(t, e) {
        t.on(
          "change:isOpen",
          () => {
            if (!t.isOpen) {
              return
            }
            const n = e()
            if (!n) {
              return
            }
            if (typeof n.focus === "function") {
              n.focus()
            } else {
              B("ui-dropdown-focus-child-on-open-child-missing-focus", { view: n })
            }
          },
          { priority: D.low - 10 }
        )
      }
      function cy(t) {
        ly(t)
        dy(t)
        hy(t)
        uy(t)
        fy(t)
        py(t)
      }
      function ly(t) {
        t.on("render", () => {
          GC({
            emitter: t,
            activator: () => t.isOpen,
            callback: () => {
              t.isOpen = false
            },
            contextElements: [t.element],
          })
        })
      }
      function dy(t) {
        t.on("execute", (e) => {
          if (e.source instanceof Ed) {
            return
          }
          t.isOpen = false
        })
      }
      function hy(t) {
        t.focusTracker.on("change:isFocused", (e, n, o) => {
          if (t.isOpen && !o) {
            t.isOpen = false
          }
        })
      }
      function uy(t) {
        t.keystrokes.set("arrowdown", (e, n) => {
          if (t.isOpen) {
            t.panelView.focus()
            n()
          }
        })
        t.keystrokes.set("arrowup", (e, n) => {
          if (t.isOpen) {
            t.panelView.focusLast()
            n()
          }
        })
      }
      function fy(t) {
        t.on("change:isOpen", (e, n, o) => {
          if (o) {
            return
          }
          const r = t.panelView.element
          if (r && r.contains(Xa.document.activeElement)) {
            t.buttonView.focus()
          }
        })
      }
      function py(t) {
        t.on(
          "change:isOpen",
          (e, n, o) => {
            if (!o) {
              return
            }
            t.panelView.focus()
          },
          { priority: "low" }
        )
      }
      function gy(t, e, n) {
        const o = new InputTextView(t.locale)
        o.set({ id: e, ariaDescribedById: n })
        o.bind("isReadOnly").to(t, "isEnabled", (t) => !t)
        o.bind("hasError").to(t, "errorText", (t) => !!t)
        o.on("input", () => {
          t.errorText = null
        })
        t.bind("isEmpty", "isFocused", "placeholder").to(o)
        return o
      }
      function my(t, e, n) {
        const o = new InputNumberView(t.locale)
        o.set({ id: e, ariaDescribedById: n, inputMode: "numeric" })
        o.bind("isReadOnly").to(t, "isEnabled", (t) => !t)
        o.bind("hasError").to(t, "errorText", (t) => !!t)
        o.on("input", () => {
          t.errorText = null
        })
        t.bind("isEmpty", "isFocused", "placeholder").to(o)
        return o
      }
      function ky(t, e, n) {
        const o = createDropdown(t.locale)
        o.set({ id: e, ariaDescribedById: n })
        o.bind("isEnabled").to(t)
        return o
      }
      const by = (t, e = 0, n = 1) => (t > n ? n : t < e ? e : t)
      const wy = (t, e = 0, n = Math.pow(10, e)) => Math.round(n * t) / n
      const _y = { grad: 360 / 400, turn: 360, rad: 360 / (Math.PI * 2) }
      const vy = (t) => Hy(Ay(t))
      const Ay = (t) => {
        if (t[0] === "#") t = t.substring(1)
        if (t.length < 6) {
          return {
            r: parseInt(t[0] + t[0], 16),
            g: parseInt(t[1] + t[1], 16),
            b: parseInt(t[2] + t[2], 16),
            a: t.length === 4 ? wy(parseInt(t[3] + t[3], 16) / 255, 2) : 1,
          }
        }
        return {
          r: parseInt(t.substring(0, 2), 16),
          g: parseInt(t.substring(2, 4), 16),
          b: parseInt(t.substring(4, 6), 16),
          a: t.length === 8 ? wy(parseInt(t.substring(6, 8), 16) / 255, 2) : 1,
        }
      }
      const Cy = (t, e = "deg") => Number(t) * (_y[e] || 1)
      const yy = (t) => {
        const e =
          /hsla?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i
        const n = e.exec(t)
        if (!n) return { h: 0, s: 0, v: 0, a: 1 }
        return Ey({
          h: Cy(n[1], n[2]),
          s: Number(n[3]),
          l: Number(n[4]),
          a: n[5] === undefined ? 1 : Number(n[5]) / (n[6] ? 100 : 1),
        })
      }
      const xy = null && yy
      const Ey = ({ h: t, s: e, l: n, a: o }) => {
        e *= (n < 50 ? n : 100 - n) / 100
        return { h: t, s: e > 0 ? ((2 * e) / (n + e)) * 100 : 0, v: n + e, a: o }
      }
      const Dy = (t) => jy(Oy(t))
      const Sy = ({ h: t, s: e, v: n, a: o }) => {
        const r = ((200 - e) * n) / 100
        return {
          h: wy(t),
          s: wy(r > 0 && r < 200 ? ((e * n) / 100 / (r <= 100 ? r : 200 - r)) * 100 : 0),
          l: wy(r / 2),
          a: wy(o, 2),
        }
      }
      const Ty = (t) => {
        const { h: e, s: n, v: o } = Wy(t)
        return `hsv(${e}, ${n}%, ${o}%)`
      }
      const Py = (t) => {
        const { h: e, s: n, v: o, a: r } = Wy(t)
        return `hsva(${e}, ${n}%, ${o}%, ${r})`
      }
      const By = (t) => {
        const { h: e, s: n, l: o } = Sy(t)
        return `hsl(${e}, ${n}%, ${o}%)`
      }
      const Ry = (t) => {
        const { h: e, s: n, l: o, a: r } = Sy(t)
        return `hsla(${e}, ${n}%, ${o}%, ${r})`
      }
      const Oy = ({ h: t, s: e, v: n, a: o }) => {
        t = (t / 360) * 6
        e = e / 100
        n = n / 100
        const r = Math.floor(t),
          i = n * (1 - e),
          s = n * (1 - (t - r) * e),
          a = n * (1 - (1 - t + r) * e),
          c = r % 6
        return {
          r: wy([n, s, i, i, a, n][c] * 255),
          g: wy([a, n, n, s, i, i][c] * 255),
          b: wy([i, i, a, n, n, s][c] * 255),
          a: wy(o, 2),
        }
      }
      const My = (t) => {
        const { r: e, g: n, b: o } = Oy(t)
        return `rgb(${e}, ${n}, ${o})`
      }
      const Iy = (t) => {
        const { r: e, g: n, b: o, a: r } = Oy(t)
        return `rgba(${e}, ${n}, ${o}, ${r})`
      }
      const zy = (t) => {
        const e =
          /hsva?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i
        const n = e.exec(t)
        if (!n) return { h: 0, s: 0, v: 0, a: 1 }
        return Wy({
          h: Cy(n[1], n[2]),
          s: Number(n[3]),
          v: Number(n[4]),
          a: n[5] === undefined ? 1 : Number(n[5]) / (n[6] ? 100 : 1),
        })
      }
      const Ny = null && zy
      const Fy = (t) => {
        const e =
          /rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i
        const n = e.exec(t)
        if (!n) return { h: 0, s: 0, v: 0, a: 1 }
        return Hy({
          r: Number(n[1]) / (n[2] ? 100 / 255 : 1),
          g: Number(n[3]) / (n[4] ? 100 / 255 : 1),
          b: Number(n[5]) / (n[6] ? 100 / 255 : 1),
          a: n[7] === undefined ? 1 : Number(n[7]) / (n[8] ? 100 : 1),
        })
      }
      const Vy = null && Fy
      const Ly = (t) => {
        const e = t.toString(16)
        return e.length < 2 ? "0" + e : e
      }
      const jy = ({ r: t, g: e, b: n, a: o }) => {
        const r = o < 1 ? Ly(wy(o * 255)) : ""
        return "#" + Ly(t) + Ly(e) + Ly(n) + r
      }
      const Hy = ({ r: t, g: e, b: n, a: o }) => {
        const r = Math.max(t, e, n)
        const i = r - Math.min(t, e, n)
        const s = i ? (r === t ? (e - n) / i : r === e ? 2 + (n - t) / i : 4 + (t - e) / i) : 0
        return {
          h: wy(60 * (s < 0 ? s + 6 : s)),
          s: wy(r ? (i / r) * 100 : 0),
          v: wy((r / 255) * 100),
          a: o,
        }
      }
      const Wy = (t) => ({ h: round(t.h), s: round(t.s), v: round(t.v), a: round(t.a, 2) })
      const qy = ({ r: t, g: e, b: n }) => ({ r: t, g: e, b: n })
      const $y = ({ h: t, s: e, l: n }) => ({ h: t, s: e, l: n })
      const Ky = (t) => {
        const { h: e, s: n, v: o } = Wy(t)
        return { h: e, s: n, v: o }
      }
      const Gy = (t, e) => {
        if (t === e) return true
        for (const n in t) {
          if (t[n] !== e[n]) return false
        }
        return true
      }
      const Uy = (t, e) => t.replace(/\s/g, "") === e.replace(/\s/g, "")
      const Jy = (t, e) => {
        if (t.toLowerCase() === e.toLowerCase()) return true
        return Gy(Ay(t), Ay(e))
      }
      const Zy = {}
      const Yy = (t) => {
        let e = Zy[t]
        if (!e) {
          e = document.createElement("template")
          e.innerHTML = t
          Zy[t] = e
        }
        return e
      }
      const Qy = (t, e, n) => {
        t.dispatchEvent(new CustomEvent(e, { bubbles: true, detail: n }))
      }
      let Xy = false
      const tx = (t) => "touches" in t
      const ex = (t) => {
        if (Xy && !tx(t)) return false
        if (!Xy) Xy = tx(t)
        return true
      }
      const nx = (t, e) => {
        const n = tx(e) ? e.touches[0] : e
        const o = t.el.getBoundingClientRect()
        Qy(
          t.el,
          "move",
          t.getMove({
            x: by((n.pageX - (o.left + window.pageXOffset)) / o.width),
            y: by((n.pageY - (o.top + window.pageYOffset)) / o.height),
          })
        )
      }
      const ox = (t, e) => {
        const n = e.keyCode
        if (n > 40 || (t.xy && n < 37) || n < 33) return
        e.preventDefault()
        Qy(
          t.el,
          "move",
          t.getMove(
            {
              x:
                n === 39
                  ? 0.01
                  : n === 37
                  ? -0.01
                  : n === 34
                  ? 0.05
                  : n === 33
                  ? -0.05
                  : n === 35
                  ? 1
                  : n === 36
                  ? -1
                  : 0,
              y: n === 40 ? 0.01 : n === 38 ? -0.01 : 0,
            },
            true
          )
        )
      }
      class rx {
        constructor(t, e, n, o) {
          const r = Yy(
            `<div role="slider" tabindex="0" part="${e}" ${n}><div part="${e}-pointer"></div></div>`
          )
          t.appendChild(r.content.cloneNode(true))
          const i = t.querySelector(`[part=${e}]`)
          i.addEventListener("mousedown", this)
          i.addEventListener("touchstart", this)
          i.addEventListener("keydown", this)
          this.el = i
          this.xy = o
          this.nodes = [i.firstChild, i]
        }
        set dragging(t) {
          const e = t ? document.addEventListener : document.removeEventListener
          e(Xy ? "touchmove" : "mousemove", this)
          e(Xy ? "touchend" : "mouseup", this)
        }
        handleEvent(t) {
          switch (t.type) {
            case "mousedown":
            case "touchstart":
              t.preventDefault()
              if (!ex(t) || (!Xy && t.button != 0)) return
              this.el.focus()
              nx(this, t)
              this.dragging = true
              break
            case "mousemove":
            case "touchmove":
              t.preventDefault()
              nx(this, t)
              break
            case "mouseup":
            case "touchend":
              this.dragging = false
              break
            case "keydown":
              ox(this, t)
              break
          }
        }
        style(t) {
          t.forEach((t, e) => {
            for (const n in t) {
              this.nodes[e].style.setProperty(n, t[n])
            }
          })
        }
      }
      class ix extends rx {
        constructor(t) {
          super(t, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', false)
        }
        update({ h: t }) {
          this.h = t
          this.style([{ left: `${(t / 360) * 100}%`, color: By({ h: t, s: 100, v: 100, a: 1 }) }])
          this.el.setAttribute("aria-valuenow", `${wy(t)}`)
        }
        getMove(t, e) {
          return { h: e ? by(this.h + t.x * 360, 0, 360) : 360 * t.x }
        }
      }
      class sx extends rx {
        constructor(t) {
          super(t, "saturation", 'aria-label="Color"', true)
        }
        update(t) {
          this.hsva = t
          this.style([
            { top: `${100 - t.v}%`, left: `${t.s}%`, color: By(t) },
            { "background-color": By({ h: t.h, s: 100, v: 100, a: 1 }) },
          ])
          this.el.setAttribute("aria-valuetext", `Saturation ${wy(t.s)}%, Brightness ${wy(t.v)}%`)
        }
        getMove(t, e) {
          return {
            s: e ? by(this.hsva.s + t.x * 100, 0, 100) : t.x * 100,
            v: e ? by(this.hsva.v - t.y * 100, 0, 100) : Math.round(100 - t.y * 100),
          }
        }
      }
      const ax = `:host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}`
      const cx = `[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}`
      const lx = `[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}`
      const dx = Symbol("same")
      const hx = Symbol("color")
      const ux = Symbol("hsva")
      const fx = Symbol("update")
      const px = Symbol("parts")
      const gx = Symbol("css")
      const mx = Symbol("sliders")
      class kx extends HTMLElement {
        static get observedAttributes() {
          return ["color"]
        }
        get [gx]() {
          return [ax, cx, lx]
        }
        get [mx]() {
          return [sx, ix]
        }
        get color() {
          return this[hx]
        }
        set color(t) {
          if (!this[dx](t)) {
            const e = this.colorModel.toHsva(t)
            this[fx](e)
            this[hx] = t
          }
        }
        constructor() {
          super()
          const t = Yy(`<style>${this[gx].join("")}</style>`)
          const e = this.attachShadow({ mode: "open" })
          e.appendChild(t.content.cloneNode(true))
          e.addEventListener("move", this)
          this[px] = this[mx].map((t) => new t(e))
        }
        connectedCallback() {
          if (this.hasOwnProperty("color")) {
            const t = this.color
            delete this["color"]
            this.color = t
          } else if (!this.color) {
            this.color = this.colorModel.defaultColor
          }
        }
        attributeChangedCallback(t, e, n) {
          const o = this.colorModel.fromAttr(n)
          if (!this[dx](o)) {
            this.color = o
          }
        }
        handleEvent(t) {
          const e = this[ux]
          const n = { ...e, ...t.detail }
          this[fx](n)
          let o
          if (!Gy(n, e) && !this[dx]((o = this.colorModel.fromHsva(n)))) {
            this[hx] = o
            Qy(this, "color-changed", { value: o })
          }
        }
        [dx](t) {
          return this.color && this.colorModel.equal(t, this.color)
        }
        [fx](t) {
          this[ux] = t
          this[px].forEach((e) => e.update(t))
        }
      }
      const bx = {
        defaultColor: "#000",
        toHsva: vy,
        fromHsva: ({ h: t, s: e, v: n }) => Dy({ h: t, s: e, v: n, a: 1 }),
        equal: Jy,
        fromAttr: (t) => t,
      }
      class wx extends kx {
        get colorModel() {
          return bx
        }
      }
      class _x extends wx {}
      customElements.define("hex-color-picker", _x)
      var vx = n(191)
      var Ax = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      Ax.insert = "head"
      Ax.singleton = true
      var Cx = Bl()(vx.Z, Ax)
      const yx = vx.Z.locals || {}
      const xx = 150
      class Ex extends (null && View) {
        constructor(t, e) {
          super(t)
          this.set("color", "")
          this.set("_hexColor", "")
          this._format = e.format || "hsl"
          this.hexInputRow = this._createInputRow()
          const n = this.createCollection()
          n.add(this.hexInputRow)
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-color-picker"], tabindex: -1 },
            children: n,
          })
          this._debounceColorPickerEvent = debounce(
            (t) => {
              this.set("color", t)
            },
            xx,
            { leading: true }
          )
          this.on("set:color", (t, e, n) => {
            t.return = convertColor(n, this._format)
          })
          this.on("change:color", () => {
            this._hexColor = Dx(this.color)
          })
          this.on("change:_hexColor", () => {
            if (document.activeElement !== this.picker) {
              this.picker.setAttribute("color", this._hexColor)
            }
            if (Dx(this.color) != Dx(this._hexColor)) {
              this.color = this._hexColor
            }
          })
        }
        render() {
          super.render()
          this.picker = global.document.createElement("hex-color-picker")
          this.picker.setAttribute("class", "hex-color-picker")
          this.picker.setAttribute("tabindex", "-1")
          this._createSlidersView()
          if (this.element) {
            this.element.insertBefore(this.picker, this.hexInputRow.element)
            const t = document.createElement("style")
            t.textContent =
              '[role="slider"]:focus [part$="pointer"] {' +
              "border: 1px solid #fff;" +
              "outline: 1px solid var(--ck-color-focus-border);" +
              "box-shadow: 0 0 0 2px #fff;" +
              "}"
            this.picker.shadowRoot.appendChild(t)
          }
          this.picker.addEventListener("color-changed", (t) => {
            const e = t
            const n = e.detail.value
            this._debounceColorPickerEvent(n)
          })
        }
        focus() {
          if (env.isGecko || env.isiOS || env.isSafari) {
            const t = this.hexInputRow.children.get(1)
            t.focus()
          }
          const t = this.slidersView.first
          t.focus()
        }
        _createSlidersView() {
          const t = [...this.picker.shadowRoot.children]
          const e = t.filter((t) => t.getAttribute("role") === "slider")
          const n = e.map((t) => {
            const e = new Sx(t)
            return e
          })
          this.slidersView = this.createCollection()
          n.forEach((t) => {
            this.slidersView.add(t)
          })
        }
        _createInputRow() {
          const t = new Tx()
          const e = this._createColorInput()
          return new Px(this.locale, [t, e])
        }
        _createColorInput() {
          const t = new LabeledFieldView(this.locale, createLabeledInputText)
          const { t: e } = this.locale
          t.set({ label: e("HEX"), class: "color-picker-hex-input" })
          t.fieldView.bind("value").to(this, "_hexColor", (e) => {
            if (t.isFocused) {
              return t.fieldView.value
            } else {
              return e.startsWith("#") ? e.substring(1) : e
            }
          })
          t.fieldView.on("input", () => {
            const e = t.fieldView.element.value
            if (e) {
              const t = e.trim()
              const n = t.startsWith("#") ? t.substring(1) : t
              const o =
                [3, 4, 6, 8].includes(n.length) &&
                /(([0-9a-fA-F]{2}){3,4}|([0-9a-fA-F]){3,4})/.test(n)
              if (o) {
                this._debounceColorPickerEvent("#" + n)
              }
            }
          })
          return t
        }
      }
      function Dx(t) {
        let e = convertToHex(t)
        if (!e) {
          e = "#000"
        }
        if (e.length === 4) {
          e = "#" + [e[1], e[1], e[2], e[2], e[3], e[3]].join("")
        }
        return e.toLowerCase()
      }
      class Sx extends (null && View) {
        constructor(t) {
          super()
          this.element = t
        }
        focus() {
          this.element.focus()
        }
      }
      class Tx extends (null && View) {
        constructor(t) {
          super(t)
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-color-picker__hash-view"] },
            children: "#",
          })
        }
      }
      class Px extends (null && View) {
        constructor(t, e) {
          super(t)
          this.children = this.createCollection(e)
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-color-picker__row"] },
            children: this.children,
          })
        }
      }
      class Bx {
        constructor(t) {
          this._components = new Map()
          this.editor = t
        }
        *names() {
          for (const t of this._components.values()) {
            yield t.originalName
          }
        }
        add(t, e) {
          this._components.set(Rx(t), { callback: e, originalName: t })
        }
        create(t) {
          if (!this.has(t)) {
            throw new P("componentfactory-item-missing", this, { name: t })
          }
          return this._components.get(Rx(t)).callback(this.editor.locale)
        }
        has(t) {
          return this._components.has(Rx(t))
        }
      }
      function Rx(t) {
        return String(t).toLowerCase()
      }
      var Ox = n(245)
      var Mx = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      Mx.insert = "head"
      Mx.singleton = true
      var Ix = Bl()(Ox.Z, Mx)
      const zx = Ox.Z.locals || {}
      const Nx = gc("px")
      const Fx = Xa.document.body
      class Vx extends zl {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.set("top", 0)
          this.set("left", 0)
          this.set("position", "arrow_nw")
          this.set("isVisible", false)
          this.set("withArrow", true)
          this.set("class", undefined)
          this._pinWhenIsVisibleCallback = null
          this.content = this.createCollection()
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-balloon-panel",
                e.to("position", (t) => `ck-balloon-panel_${t}`),
                e.if("isVisible", "ck-balloon-panel_visible"),
                e.if("withArrow", "ck-balloon-panel_with-arrow"),
                e.to("class"),
              ],
              style: { top: e.to("top", Nx), left: e.to("left", Nx) },
            },
            children: this.content,
          })
        }
        show() {
          this.isVisible = true
        }
        hide() {
          this.isVisible = false
        }
        attachTo(t) {
          this.show()
          const e = Vx.defaultPositions
          const n = Object.assign(
            {},
            {
              element: this.element,
              positions: [
                e.southArrowNorth,
                e.southArrowNorthMiddleWest,
                e.southArrowNorthMiddleEast,
                e.southArrowNorthWest,
                e.southArrowNorthEast,
                e.northArrowSouth,
                e.northArrowSouthMiddleWest,
                e.northArrowSouthMiddleEast,
                e.northArrowSouthWest,
                e.northArrowSouthEast,
                e.viewportStickyNorth,
              ],
              limiter: Fx,
              fitInViewport: true,
            },
            t
          )
          const o = Vx._getOptimalPosition(n)
          const r = parseInt(o.left)
          const i = parseInt(o.top)
          const s = o.name
          const a = o.config || {}
          const { withArrow: c = true } = a
          this.top = i
          this.left = r
          this.position = s
          this.withArrow = c
        }
        pin(t) {
          this.unpin()
          this._pinWhenIsVisibleCallback = () => {
            if (this.isVisible) {
              this._startPinning(t)
            } else {
              this._stopPinning()
            }
          }
          this._startPinning(t)
          this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback)
        }
        unpin() {
          if (this._pinWhenIsVisibleCallback) {
            this._stopPinning()
            this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback)
            this._pinWhenIsVisibleCallback = null
            this.hide()
          }
        }
        _startPinning(t) {
          this.attachTo(t)
          const e = Lx(t.target)
          const n = t.limiter ? Lx(t.limiter) : Fx
          this.listenTo(
            Xa.document,
            "scroll",
            (o, r) => {
              const i = r.target
              const s = e && i.contains(e)
              const a = n && i.contains(n)
              if (s || a || !e || !n) {
                this.attachTo(t)
              }
            },
            { useCapture: true }
          )
          this.listenTo(Xa.window, "resize", () => {
            this.attachTo(t)
          })
        }
        _stopPinning() {
          this.stopListening(Xa.document, "scroll")
          this.stopListening(Xa.window, "resize")
        }
      }
      Vx.arrowSideOffset = 25
      Vx.arrowHeightOffset = 10
      Vx.stickyVerticalOffset = 20
      Vx._getOptimalPosition = Ac
      Vx.defaultPositions = jx()
      function Lx(t) {
        if (ja(t)) {
          return t
        }
        if (rc(t)) {
          return t.commonAncestorContainer
        }
        if (typeof t == "function") {
          return Lx(t())
        }
        return null
      }
      function jx(t = {}) {
        const {
          sideOffset: e = Vx.arrowSideOffset,
          heightOffset: n = Vx.arrowHeightOffset,
          stickyVerticalOffset: o = Vx.stickyVerticalOffset,
          config: r,
        } = t
        return {
          northWestArrowSouthWest: (t, n) => ({
            top: i(t, n),
            left: t.left - e,
            name: "arrow_sw",
            ...(r && { config: r }),
          }),
          northWestArrowSouthMiddleWest: (t, n) => ({
            top: i(t, n),
            left: t.left - n.width * 0.25 - e,
            name: "arrow_smw",
            ...(r && { config: r }),
          }),
          northWestArrowSouth: (t, e) => ({
            top: i(t, e),
            left: t.left - e.width / 2,
            name: "arrow_s",
            ...(r && { config: r }),
          }),
          northWestArrowSouthMiddleEast: (t, n) => ({
            top: i(t, n),
            left: t.left - n.width * 0.75 + e,
            name: "arrow_sme",
            ...(r && { config: r }),
          }),
          northWestArrowSouthEast: (t, n) => ({
            top: i(t, n),
            left: t.left - n.width + e,
            name: "arrow_se",
            ...(r && { config: r }),
          }),
          northArrowSouthWest: (t, n) => ({
            top: i(t, n),
            left: t.left + t.width / 2 - e,
            name: "arrow_sw",
            ...(r && { config: r }),
          }),
          northArrowSouthMiddleWest: (t, n) => ({
            top: i(t, n),
            left: t.left + t.width / 2 - n.width * 0.25 - e,
            name: "arrow_smw",
            ...(r && { config: r }),
          }),
          northArrowSouth: (t, e) => ({
            top: i(t, e),
            left: t.left + t.width / 2 - e.width / 2,
            name: "arrow_s",
            ...(r && { config: r }),
          }),
          northArrowSouthMiddleEast: (t, n) => ({
            top: i(t, n),
            left: t.left + t.width / 2 - n.width * 0.75 + e,
            name: "arrow_sme",
            ...(r && { config: r }),
          }),
          northArrowSouthEast: (t, n) => ({
            top: i(t, n),
            left: t.left + t.width / 2 - n.width + e,
            name: "arrow_se",
            ...(r && { config: r }),
          }),
          northEastArrowSouthWest: (t, n) => ({
            top: i(t, n),
            left: t.right - e,
            name: "arrow_sw",
            ...(r && { config: r }),
          }),
          northEastArrowSouthMiddleWest: (t, n) => ({
            top: i(t, n),
            left: t.right - n.width * 0.25 - e,
            name: "arrow_smw",
            ...(r && { config: r }),
          }),
          northEastArrowSouth: (t, e) => ({
            top: i(t, e),
            left: t.right - e.width / 2,
            name: "arrow_s",
            ...(r && { config: r }),
          }),
          northEastArrowSouthMiddleEast: (t, n) => ({
            top: i(t, n),
            left: t.right - n.width * 0.75 + e,
            name: "arrow_sme",
            ...(r && { config: r }),
          }),
          northEastArrowSouthEast: (t, n) => ({
            top: i(t, n),
            left: t.right - n.width + e,
            name: "arrow_se",
            ...(r && { config: r }),
          }),
          southWestArrowNorthWest: (t) => ({
            top: s(t),
            left: t.left - e,
            name: "arrow_nw",
            ...(r && { config: r }),
          }),
          southWestArrowNorthMiddleWest: (t, n) => ({
            top: s(t),
            left: t.left - n.width * 0.25 - e,
            name: "arrow_nmw",
            ...(r && { config: r }),
          }),
          southWestArrowNorth: (t, e) => ({
            top: s(t),
            left: t.left - e.width / 2,
            name: "arrow_n",
            ...(r && { config: r }),
          }),
          southWestArrowNorthMiddleEast: (t, n) => ({
            top: s(t),
            left: t.left - n.width * 0.75 + e,
            name: "arrow_nme",
            ...(r && { config: r }),
          }),
          southWestArrowNorthEast: (t, n) => ({
            top: s(t),
            left: t.left - n.width + e,
            name: "arrow_ne",
            ...(r && { config: r }),
          }),
          southArrowNorthWest: (t) => ({
            top: s(t),
            left: t.left + t.width / 2 - e,
            name: "arrow_nw",
            ...(r && { config: r }),
          }),
          southArrowNorthMiddleWest: (t, n) => ({
            top: s(t),
            left: t.left + t.width / 2 - n.width * 0.25 - e,
            name: "arrow_nmw",
            ...(r && { config: r }),
          }),
          southArrowNorth: (t, e) => ({
            top: s(t),
            left: t.left + t.width / 2 - e.width / 2,
            name: "arrow_n",
            ...(r && { config: r }),
          }),
          southArrowNorthMiddleEast: (t, n) => ({
            top: s(t),
            left: t.left + t.width / 2 - n.width * 0.75 + e,
            name: "arrow_nme",
            ...(r && { config: r }),
          }),
          southArrowNorthEast: (t, n) => ({
            top: s(t),
            left: t.left + t.width / 2 - n.width + e,
            name: "arrow_ne",
            ...(r && { config: r }),
          }),
          southEastArrowNorthWest: (t) => ({
            top: s(t),
            left: t.right - e,
            name: "arrow_nw",
            ...(r && { config: r }),
          }),
          southEastArrowNorthMiddleWest: (t, n) => ({
            top: s(t),
            left: t.right - n.width * 0.25 - e,
            name: "arrow_nmw",
            ...(r && { config: r }),
          }),
          southEastArrowNorth: (t, e) => ({
            top: s(t),
            left: t.right - e.width / 2,
            name: "arrow_n",
            ...(r && { config: r }),
          }),
          southEastArrowNorthMiddleEast: (t, n) => ({
            top: s(t),
            left: t.right - n.width * 0.75 + e,
            name: "arrow_nme",
            ...(r && { config: r }),
          }),
          southEastArrowNorthEast: (t, n) => ({
            top: s(t),
            left: t.right - n.width + e,
            name: "arrow_ne",
            ...(r && { config: r }),
          }),
          westArrowEast: (t, e) => ({
            top: t.top + t.height / 2 - e.height / 2,
            left: t.left - e.width - n,
            name: "arrow_e",
            ...(r && { config: r }),
          }),
          eastArrowWest: (t, e) => ({
            top: t.top + t.height / 2 - e.height / 2,
            left: t.right + n,
            name: "arrow_w",
            ...(r && { config: r }),
          }),
          viewportStickyNorth: (t, e, n) => {
            if (!t.getIntersection(n)) {
              return null
            }
            return {
              top: n.top + o,
              left: t.left + t.width / 2 - e.width / 2,
              name: "arrowless",
              config: { withArrow: false, ...r },
            }
          },
        }
        function i(t, e) {
          return t.top - e.height - n
        }
        function s(t) {
          return t.bottom + n
        }
      }
      var Hx = n(948)
      var Wx = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      Wx.insert = "head"
      Wx.singleton = true
      var qx = Bl()(Hx.Z, Wx)
      const $x = Hx.Z.locals || {}
      const Kx = "ck-tooltip"
      class Gx extends Ua() {
        constructor(t) {
          super()
          this._currentElementWithTooltip = null
          this._currentTooltipPosition = null
          this._resizeObserver = null
          Gx._editors.add(t)
          if (Gx._instance) {
            return Gx._instance
          }
          Gx._instance = this
          this.tooltipTextView = new zl(t.locale)
          this.tooltipTextView.set("text", "")
          this.tooltipTextView.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-tooltip__text"] },
            children: [{ text: this.tooltipTextView.bindTemplate.to("text") }],
          })
          this.balloonPanelView = new Vx(t.locale)
          this.balloonPanelView.class = Kx
          this.balloonPanelView.content.add(this.tooltipTextView)
          this._pinTooltipDebounced = Zg(this._pinTooltip, 600)
          this.listenTo(Xa.document, "mouseenter", this._onEnterOrFocus.bind(this), {
            useCapture: true,
          })
          this.listenTo(Xa.document, "mouseleave", this._onLeaveOrBlur.bind(this), {
            useCapture: true,
          })
          this.listenTo(Xa.document, "focus", this._onEnterOrFocus.bind(this), { useCapture: true })
          this.listenTo(Xa.document, "blur", this._onLeaveOrBlur.bind(this), { useCapture: true })
          this.listenTo(Xa.document, "scroll", this._onScroll.bind(this), { useCapture: true })
          this._watchdogExcluded = true
        }
        destroy(t) {
          const e = t.ui.view && t.ui.view.body
          Gx._editors.delete(t)
          this.stopListening(t.ui)
          if (e && e.has(this.balloonPanelView)) {
            e.remove(this.balloonPanelView)
          }
          if (!Gx._editors.size) {
            this._unpinTooltip()
            this.balloonPanelView.destroy()
            this.stopListening()
            Gx._instance = null
          }
        }
        static getPositioningFunctions(t) {
          const e = Gx.defaultBalloonPositions
          return {
            s: [e.southArrowNorth, e.southArrowNorthEast, e.southArrowNorthWest],
            n: [e.northArrowSouth],
            e: [e.eastArrowWest],
            w: [e.westArrowEast],
            sw: [e.southArrowNorthEast],
            se: [e.southArrowNorthWest],
          }[t]
        }
        _onEnterOrFocus(t, { target: e }) {
          const n = Ux(e)
          if (!n) {
            return
          }
          if (n === this._currentElementWithTooltip) {
            return
          }
          this._unpinTooltip()
          this._pinTooltipDebounced(n, Jx(n))
        }
        _onLeaveOrBlur(t, { target: e, relatedTarget: n }) {
          if (t.name === "mouseleave") {
            if (!ja(e)) {
              return
            }
            if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) {
              return
            }
            const t = Ux(e)
            const o = Ux(n)
            if (t && t !== o) {
              this._unpinTooltip()
            }
          } else {
            if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) {
              return
            }
            this._unpinTooltip()
          }
        }
        _onScroll(t, { target: e }) {
          if (!this._currentElementWithTooltip) {
            return
          }
          if (
            e.contains(this.balloonPanelView.element) &&
            e.contains(this._currentElementWithTooltip)
          ) {
            return
          }
          this._unpinTooltip()
        }
        _pinTooltip(t, { text: e, position: n, cssClass: o }) {
          const r = hl(Gx._editors.values()).ui.view.body
          if (!r.has(this.balloonPanelView)) {
            r.add(this.balloonPanelView)
          }
          this.tooltipTextView.text = e
          this.balloonPanelView.pin({ target: t, positions: Gx.getPositioningFunctions(n) })
          this._resizeObserver = new fc(t, () => {
            if (!_c(t)) {
              this._unpinTooltip()
            }
          })
          this.balloonPanelView.class = [Kx, o].filter((t) => t).join(" ")
          for (const t of Gx._editors) {
            this.listenTo(t.ui, "update", this._updateTooltipPosition.bind(this), {
              priority: "low",
            })
          }
          this._currentElementWithTooltip = t
          this._currentTooltipPosition = n
        }
        _unpinTooltip() {
          this._pinTooltipDebounced.cancel()
          this.balloonPanelView.unpin()
          for (const t of Gx._editors) {
            this.stopListening(t.ui, "update")
          }
          this._currentElementWithTooltip = null
          this._currentTooltipPosition = null
          if (this._resizeObserver) {
            this._resizeObserver.destroy()
          }
        }
        _updateTooltipPosition() {
          if (!_c(this._currentElementWithTooltip)) {
            this._unpinTooltip()
            return
          }
          this.balloonPanelView.pin({
            target: this._currentElementWithTooltip,
            positions: Gx.getPositioningFunctions(this._currentTooltipPosition),
          })
        }
      }
      Gx.defaultBalloonPositions = jx({ heightOffset: 5, sideOffset: 13 })
      Gx._editors = new Set()
      Gx._instance = null
      function Ux(t) {
        if (!ja(t)) {
          return null
        }
        return t.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])")
      }
      function Jx(t) {
        return {
          text: t.dataset.ckeTooltipText,
          position: t.dataset.ckeTooltipPosition || "s",
          cssClass: t.dataset.ckeTooltipClass || "",
        }
      }
      var Zx = "Expected a function"
      function Yx(t, e, n) {
        var o = true,
          r = true
        if (typeof t != "function") {
          throw new TypeError(Zx)
        }
        if (ot(n)) {
          o = "leading" in n ? !!n.leading : o
          r = "trailing" in n ? !!n.trailing : r
        }
        return Zg(t, e, { leading: o, maxWait: e, trailing: r })
      }
      const Qx = Yx
      const Xx =
        '<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></svg>\n'
      const tE = 53
      const eE = 10
      const nE = 50
      const oE = 350
      const rE = "Powered by"
      const iE = { top: -99999, left: -99999, name: "invalid", config: { withArrow: false } }
      class sE extends Ua() {
        constructor(t) {
          super()
          this.editor = t
          this._balloonView = null
          this._lastFocusedEditableElement = null
          this._showBalloonThrottled = Qx(this._showBalloon.bind(this), 50, { leading: true })
          t.on("ready", this._handleEditorReady.bind(this))
        }
        destroy() {
          const t = this._balloonView
          if (t) {
            t.unpin()
            this._balloonView = null
          }
          this._showBalloonThrottled.cancel()
          this.stopListening()
        }
        _handleEditorReady() {
          const t = this.editor
          const e = !!t.config.get("ui.poweredBy.forceVisible")
          if (!e && wl(t.config.get("licenseKey")) === "VALID") {
            return
          }
          if (!t.ui.view) {
            return
          }
          t.ui.focusTracker.on("change:isFocused", (t, e, n) => {
            this._updateLastFocusedEditableElement()
            if (n) {
              this._showBalloon()
            } else {
              this._hideBalloon()
            }
          })
          t.ui.focusTracker.on("change:focusedElement", (t, e, n) => {
            this._updateLastFocusedEditableElement()
            if (n) {
              this._showBalloon()
            }
          })
          t.ui.on("update", () => {
            this._showBalloonThrottled()
          })
        }
        _createBalloonView() {
          const t = this.editor
          const e = (this._balloonView = new Vx())
          const n = uE(t)
          const o = new aE(t.locale, n.label)
          e.content.add(o)
          e.set({ class: "ck-powered-by-balloon" })
          t.ui.view.body.add(e)
          t.ui.focusTracker.add(e.element)
          this._balloonView = e
        }
        _showBalloon() {
          if (!this._lastFocusedEditableElement) {
            return
          }
          const t = cE(this.editor, this._lastFocusedEditableElement)
          if (t) {
            if (!this._balloonView) {
              this._createBalloonView()
            }
            this._balloonView.pin(t)
          }
        }
        _hideBalloon() {
          if (this._balloonView) {
            this._balloonView.unpin()
          }
        }
        _updateLastFocusedEditableElement() {
          const t = this.editor
          const e = t.ui.focusTracker.isFocused
          const n = t.ui.focusTracker.focusedElement
          if (!e || !n) {
            this._lastFocusedEditableElement = null
            return
          }
          const o = Array.from(t.ui.getEditableElementsNames()).map((e) =>
            t.ui.getEditableElement(e)
          )
          if (o.includes(n)) {
            this._lastFocusedEditableElement = n
          } else {
            this._lastFocusedEditableElement = o[0]
          }
        }
      }
      class aE extends zl {
        constructor(t, e) {
          super(t)
          const n = new md()
          const o = this.bindTemplate
          n.set({ content: Xx, isColorInherited: false })
          n.extendTemplate({ attributes: { style: { width: tE + "px", height: eE + "px" } } })
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-powered-by"], "aria-hidden": true },
            children: [
              {
                tag: "a",
                attributes: {
                  href:
                    "https://ckeditor.com/?utm_source=ckeditor&" +
                    "utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo",
                  target: "_blank",
                  tabindex: "-1",
                },
                children: [
                  ...(e
                    ? [
                        {
                          tag: "span",
                          attributes: { class: ["ck", "ck-powered-by__label"] },
                          children: [e],
                        },
                      ]
                    : []),
                  n,
                ],
                on: { dragstart: o.to((t) => t.preventDefault()) },
              },
            ],
          })
        }
      }
      function cE(t, e) {
        const n = uE(t)
        const o = n.side === "right" ? lE(e, n) : dE(e, n)
        return { target: e, positions: [o] }
      }
      function lE(t, e) {
        return hE(t, e, (t, n) => t.left + t.width - n.width - e.horizontalOffset)
      }
      function dE(t, e) {
        return hE(t, e, (t) => t.left + e.horizontalOffset)
      }
      function hE(t, e, n) {
        return (o, r) => {
          const i = o.getVisible()
          if (!i) {
            return iE
          }
          if (o.width < oE || o.height < nE) {
            return iE
          }
          let s
          if (e.position === "inside") {
            s = o.bottom - r.height
          } else {
            s = o.bottom - r.height / 2
          }
          s -= e.verticalOffset
          const a = n(o, r)
          if (e.position === "inside") {
            const t = r.clone().moveTo(a, s)
            if (t.getIntersectionArea(i) < t.getArea()) {
              return iE
            }
          } else {
            const e = tc(t)
            if (e) {
              const t = new ac(e)
              if (i.bottom + r.height / 2 > t.bottom) {
                return iE
              }
            }
          }
          return {
            top: s,
            left: a,
            name: `position_${e.position}-side_${e.side}`,
            config: { withArrow: false },
          }
        }
      }
      function uE(t) {
        const e = t.config.get("ui.poweredBy")
        const n = (e && e.position) || "border"
        return {
          position: n,
          label: rE,
          verticalOffset: n === "inside" ? 5 : 0,
          horizontalOffset: 5,
          side: t.locale.contentLanguageDirection === "ltr" ? "right" : "left",
          ...e,
        }
      }
      class fE extends dt() {
        constructor(t) {
          super()
          this.isReady = false
          this._editableElementsMap = new Map()
          this._focusableToolbarDefinitions = []
          const e = t.editing.view
          this.editor = t
          this.componentFactory = new Bx(t)
          this.focusTracker = new ul()
          this.tooltipManager = new Gx(t)
          this.poweredBy = new sE(t)
          this.set("viewportOffset", this._readViewportOffsetFromConfig())
          this.once("ready", () => {
            this.isReady = true
          })
          this.listenTo(e.document, "layoutChanged", this.update.bind(this))
          this.listenTo(e, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this))
          this._initFocusTracking()
        }
        get element() {
          return null
        }
        update() {
          this.fire("update")
        }
        destroy() {
          this.stopListening()
          this.focusTracker.destroy()
          this.tooltipManager.destroy(this.editor)
          this.poweredBy.destroy()
          for (const t of this._editableElementsMap.values()) {
            t.ckeditorInstance = null
            this.editor.keystrokes.stopListening(t)
          }
          this._editableElementsMap = new Map()
          this._focusableToolbarDefinitions = []
        }
        setEditableElement(t, e) {
          this._editableElementsMap.set(t, e)
          if (!e.ckeditorInstance) {
            e.ckeditorInstance = this.editor
          }
          this.focusTracker.add(e)
          const n = () => {
            if (this.editor.editing.view.getDomRoot(t)) {
              return
            }
            this.editor.keystrokes.listenTo(e)
          }
          if (this.isReady) {
            n()
          } else {
            this.once("ready", n)
          }
        }
        removeEditableElement(t) {
          const e = this._editableElementsMap.get(t)
          if (!e) {
            return
          }
          this._editableElementsMap.delete(t)
          this.editor.keystrokes.stopListening(e)
          this.focusTracker.remove(e)
          e.ckeditorInstance = null
        }
        getEditableElement(t = "main") {
          return this._editableElementsMap.get(t)
        }
        getEditableElementsNames() {
          return this._editableElementsMap.keys()
        }
        addToolbar(t, e = {}) {
          if (t.isRendered) {
            this.focusTracker.add(t.element)
            this.editor.keystrokes.listenTo(t.element)
          } else {
            t.once("render", () => {
              this.focusTracker.add(t.element)
              this.editor.keystrokes.listenTo(t.element)
            })
          }
          this._focusableToolbarDefinitions.push({ toolbarView: t, options: e })
        }
        get _editableElements() {
          console.warn(
            "editor-ui-deprecated-editable-elements: " +
              "The EditorUI#_editableElements property has been deprecated and will be removed in the near future.",
            { editorUI: this }
          )
          return this._editableElementsMap
        }
        _readViewportOffsetFromConfig() {
          const t = this.editor
          const e = t.config.get("ui.viewportOffset")
          if (e) {
            return e
          }
          const n = t.config.get("toolbar.viewportTopOffset")
          if (n) {
            console.warn(
              "editor-ui-deprecated-viewport-offset-config: " +
                "The `toolbar.vieportTopOffset` configuration option is deprecated. " +
                "It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."
            )
            return { top: n }
          }
          return { top: 0 }
        }
        _initFocusTracking() {
          const t = this.editor
          const e = t.editing.view
          let n
          let o
          t.keystrokes.set("Alt+F10", (t, r) => {
            const i = this.focusTracker.focusedElement
            if (
              Array.from(this._editableElementsMap.values()).includes(i) &&
              !Array.from(e.domRoots.values()).includes(i)
            ) {
              n = i
            }
            const s = this._getCurrentFocusedToolbarDefinition()
            if (!s || !o) {
              o = this._getFocusableCandidateToolbarDefinitions()
            }
            for (let t = 0; t < o.length; t++) {
              const t = o.shift()
              o.push(t)
              if (t !== s && this._focusFocusableCandidateToolbar(t)) {
                if (s && s.options.afterBlur) {
                  s.options.afterBlur()
                }
                break
              }
            }
            r()
          })
          t.keystrokes.set("Esc", (e, o) => {
            const r = this._getCurrentFocusedToolbarDefinition()
            if (!r) {
              return
            }
            if (n) {
              n.focus()
              n = null
            } else {
              t.editing.view.focus()
            }
            if (r.options.afterBlur) {
              r.options.afterBlur()
            }
            o()
          })
        }
        _getFocusableCandidateToolbarDefinitions() {
          const t = []
          for (const e of this._focusableToolbarDefinitions) {
            const { toolbarView: n, options: o } = e
            if (_c(n.element) || o.beforeFocus) {
              t.push(e)
            }
          }
          t.sort((t, e) => pE(t) - pE(e))
          return t
        }
        _getCurrentFocusedToolbarDefinition() {
          for (const t of this._focusableToolbarDefinitions) {
            if (
              t.toolbarView.element &&
              t.toolbarView.element.contains(this.focusTracker.focusedElement)
            ) {
              return t
            }
          }
          return null
        }
        _focusFocusableCandidateToolbar(t) {
          const {
            toolbarView: e,
            options: { beforeFocus: n },
          } = t
          if (n) {
            n()
          }
          if (!_c(e.element)) {
            return false
          }
          e.focus()
          return true
        }
        _handleScrollToTheSelection(t, e) {
          const n = { top: 0, bottom: 0, left: 0, right: 0, ...this.viewportOffset }
          e.viewportOffset.top += n.top
          e.viewportOffset.bottom += n.bottom
          e.viewportOffset.left += n.left
          e.viewportOffset.right += n.right
        }
      }
      function pE(t) {
        const { toolbarView: e, options: n } = t
        let o = 10
        if (_c(e.element)) {
          o--
        }
        if (n.isContextual) {
          o--
        }
        return o
      }
      var gE = n(547)
      var mE = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      mE.insert = "head"
      mE.singleton = true
      var kE = Bl()(gE.Z, mE)
      const bE = gE.Z.locals || {}
      class wE extends zl {
        constructor(t) {
          super(t)
          this.body = new hd(t)
        }
        render() {
          super.render()
          this.body.attachToDom()
        }
        destroy() {
          this.body.detachFromDom()
          return super.destroy()
        }
      }
      class _E extends wE {
        constructor(t) {
          super(t)
          this.top = this.createCollection()
          this.main = this.createCollection()
          this._voiceLabelView = this._createVoiceLabel()
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"],
              role: "application",
              dir: t.uiLanguageDirection,
              lang: t.uiLanguage,
              "aria-labelledby": this._voiceLabelView.id,
            },
            children: [
              this._voiceLabelView,
              {
                tag: "div",
                attributes: {
                  class: ["ck", "ck-editor__top", "ck-reset_all"],
                  role: "presentation",
                },
                children: this.top,
              },
              {
                tag: "div",
                attributes: { class: ["ck", "ck-editor__main"], role: "presentation" },
                children: this.main,
              },
            ],
          })
        }
        _createVoiceLabel() {
          const t = this.t
          const e = new Gd()
          e.text = t("Rich Text Editor")
          e.extendTemplate({ attributes: { class: "ck-voice-label" } })
          return e
        }
      }
      class vE extends zl {
        constructor(t, e, n) {
          super(t)
          this.name = null
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"],
              lang: t.contentLanguage,
              dir: t.contentLanguageDirection,
            },
          })
          this.set("isFocused", false)
          this._editableElement = n
          this._hasExternalElement = !!this._editableElement
          this._editingView = e
        }
        render() {
          super.render()
          if (this._hasExternalElement) {
            this.template.apply((this.element = this._editableElement))
          } else {
            this._editableElement = this.element
          }
          this.on("change:isFocused", () => this._updateIsFocusedClasses())
          this._updateIsFocusedClasses()
        }
        destroy() {
          if (this._hasExternalElement) {
            this.template.revert(this._editableElement)
          }
          super.destroy()
        }
        get hasExternalElement() {
          return this._hasExternalElement
        }
        _updateIsFocusedClasses() {
          const t = this._editingView
          if (t.isRenderingInProgress) {
            n(this)
          } else {
            e(this)
          }
          function e(e) {
            t.change((n) => {
              const o = t.document.getRoot(e.name)
              n.addClass(e.isFocused ? "ck-focused" : "ck-blurred", o)
              n.removeClass(e.isFocused ? "ck-blurred" : "ck-focused", o)
            })
          }
          function n(o) {
            t.once("change:isRenderingInProgress", (t, r, i) => {
              if (!i) {
                e(o)
              } else {
                n(o)
              }
            })
          }
        }
      }
      class AE extends vE {
        constructor(t, e, n, o = {}) {
          super(t, e, n)
          const r = t.t
          this.extendTemplate({
            attributes: { role: "textbox", class: "ck-editor__editable_inline" },
          })
          this._generateLabel = o.label || (() => r("Editor editing area: %0", this.name))
        }
        render() {
          super.render()
          const t = this._editingView
          t.change((e) => {
            const n = t.document.getRoot(this.name)
            e.setAttribute("aria-label", this._generateLabel(this), n)
          })
        }
      }
      var CE = n(523)
      var yE = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      yE.insert = "head"
      yE.singleton = true
      var xE = Bl()(CE.Z, yE)
      const EE = CE.Z.locals || {}
      class DE extends (null && View) {
        constructor(t, e = {}) {
          super(t)
          const n = this.bindTemplate
          this.set("label", e.label || "")
          this.set("class", e.class || null)
          this.children = this.createCollection()
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-form__header", n.to("class")] },
            children: this.children,
          })
          const o = new View(t)
          o.setTemplate({
            tag: "h2",
            attributes: { class: ["ck", "ck-form__header__label"] },
            children: [{ text: n.to("label") }],
          })
          this.children.add(o)
        }
      }
      class SE extends (null && View) {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.setTemplate({
            tag: "iframe",
            attributes: {
              class: ["ck", "ck-reset_all"],
              sandbox: "allow-same-origin allow-scripts",
            },
            on: { load: e.to("loaded") },
          })
        }
        render() {
          return new Promise((t) => {
            this.on("loaded", t)
            return super.render()
          })
        }
      }
      class TE extends (null && ContextPlugin) {
        static get pluginName() {
          return "Notification"
        }
        init() {
          this.on(
            "show:warning",
            (t, e) => {
              window.alert(e.message)
            },
            { priority: "lowest" }
          )
        }
        showSuccess(t, e = {}) {
          this._showNotification({
            message: t,
            type: "success",
            namespace: e.namespace,
            title: e.title,
          })
        }
        showInfo(t, e = {}) {
          this._showNotification({
            message: t,
            type: "info",
            namespace: e.namespace,
            title: e.title,
          })
        }
        showWarning(t, e = {}) {
          this._showNotification({
            message: t,
            type: "warning",
            namespace: e.namespace,
            title: e.title,
          })
        }
        _showNotification(t) {
          const e = t.namespace ? `show:${t.type}:${t.namespace}` : `show:${t.type}`
          this.fire(e, { message: t.message, type: t.type, title: t.title || "" })
        }
      }
      class PE extends dt() {
        constructor(t, e) {
          super()
          if (e) {
            Dg(this, e)
          }
          if (t) {
            this.set(t)
          }
        }
      }
      var BE = n(757)
      var RE = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      RE.insert = "head"
      RE.singleton = true
      var OE = Bl()(BE.Z, RE)
      const ME = BE.Z.locals || {}
      var IE = n(553)
      var zE = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      zE.insert = "head"
      zE.singleton = true
      var NE = Bl()(IE.Z, zE)
      const FE = IE.Z.locals || {}
      const VE = gc("px")
      class LE extends (null && Plugin) {
        static get pluginName() {
          return "ContextualBalloon"
        }
        constructor(t) {
          super(t)
          this._viewToStack = new Map()
          this._idToStack = new Map()
          this._view = null
          this._rotatorView = null
          this._fakePanelsView = null
          this.positionLimiter = () => {
            const t = this.editor.editing.view
            const e = t.document
            const n = e.selection.editableElement
            if (n) {
              return t.domConverter.mapViewToDom(n.root)
            }
            return null
          }
          this.set("visibleView", null)
          this.set("_numberOfStacks", 0)
          this.set("_singleViewMode", false)
        }
        destroy() {
          super.destroy()
          if (this._view) {
            this._view.destroy()
          }
          if (this._rotatorView) {
            this._rotatorView.destroy()
          }
          if (this._fakePanelsView) {
            this._fakePanelsView.destroy()
          }
        }
        get view() {
          if (!this._view) {
            this._createPanelView()
          }
          return this._view
        }
        hasView(t) {
          return Array.from(this._viewToStack.keys()).includes(t)
        }
        add(t) {
          if (!this._view) {
            this._createPanelView()
          }
          if (this.hasView(t.view)) {
            throw new CKEditorError("contextualballoon-add-view-exist", [this, t])
          }
          const e = t.stackId || "main"
          if (!this._idToStack.has(e)) {
            this._idToStack.set(e, new Map([[t.view, t]]))
            this._viewToStack.set(t.view, this._idToStack.get(e))
            this._numberOfStacks = this._idToStack.size
            if (!this._visibleStack || t.singleViewMode) {
              this.showStack(e)
            }
            return
          }
          const n = this._idToStack.get(e)
          if (t.singleViewMode) {
            this.showStack(e)
          }
          n.set(t.view, t)
          this._viewToStack.set(t.view, n)
          if (n === this._visibleStack) {
            this._showView(t)
          }
        }
        remove(t) {
          if (!this.hasView(t)) {
            throw new CKEditorError("contextualballoon-remove-view-not-exist", [this, t])
          }
          const e = this._viewToStack.get(t)
          if (this._singleViewMode && this.visibleView === t) {
            this._singleViewMode = false
          }
          if (this.visibleView === t) {
            if (e.size === 1) {
              if (this._idToStack.size > 1) {
                this._showNextStack()
              } else {
                this.view.hide()
                this.visibleView = null
                this._rotatorView.hideView()
              }
            } else {
              this._showView(Array.from(e.values())[e.size - 2])
            }
          }
          if (e.size === 1) {
            this._idToStack.delete(this._getStackId(e))
            this._numberOfStacks = this._idToStack.size
          } else {
            e.delete(t)
          }
          this._viewToStack.delete(t)
        }
        updatePosition(t) {
          if (t) {
            this._visibleStack.get(this.visibleView).position = t
          }
          this.view.pin(this._getBalloonPosition())
          this._fakePanelsView.updatePosition()
        }
        showStack(t) {
          this.visibleStack = t
          const e = this._idToStack.get(t)
          if (!e) {
            throw new CKEditorError("contextualballoon-showstack-stack-not-exist", this)
          }
          if (this._visibleStack === e) {
            return
          }
          this._showView(Array.from(e.values()).pop())
        }
        _createPanelView() {
          this._view = new BalloonPanelView(this.editor.locale)
          this.editor.ui.view.body.add(this._view)
          this.editor.ui.focusTracker.add(this._view.element)
          this._rotatorView = this._createRotatorView()
          this._fakePanelsView = this._createFakePanelsView()
        }
        get _visibleStack() {
          return this._viewToStack.get(this.visibleView)
        }
        _getStackId(t) {
          const e = Array.from(this._idToStack.entries()).find((e) => e[1] === t)
          return e[0]
        }
        _showNextStack() {
          const t = Array.from(this._idToStack.values())
          let e = t.indexOf(this._visibleStack) + 1
          if (!t[e]) {
            e = 0
          }
          this.showStack(this._getStackId(t[e]))
        }
        _showPrevStack() {
          const t = Array.from(this._idToStack.values())
          let e = t.indexOf(this._visibleStack) - 1
          if (!t[e]) {
            e = t.length - 1
          }
          this.showStack(this._getStackId(t[e]))
        }
        _createRotatorView() {
          const t = new jE(this.editor.locale)
          const e = this.editor.locale.t
          this.view.content.add(t)
          t.bind("isNavigationVisible").to(
            this,
            "_numberOfStacks",
            this,
            "_singleViewMode",
            (t, e) => !e && t > 1
          )
          t.on("change:isNavigationVisible", () => this.updatePosition(), { priority: "low" })
          t.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (t, n) => {
            if (n < 2) {
              return ""
            }
            const o = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1
            return e("%0 of %1", [o, n])
          })
          t.buttonNextView.on("execute", () => {
            if (t.focusTracker.isFocused) {
              this.editor.editing.view.focus()
            }
            this._showNextStack()
          })
          t.buttonPrevView.on("execute", () => {
            if (t.focusTracker.isFocused) {
              this.editor.editing.view.focus()
            }
            this._showPrevStack()
          })
          return t
        }
        _createFakePanelsView() {
          const t = new HE(this.editor.locale, this.view)
          t.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (t, e) => {
            const n = !e && t >= 2
            return n ? Math.min(t - 1, 2) : 0
          })
          t.listenTo(this.view, "change:top", () => t.updatePosition())
          t.listenTo(this.view, "change:left", () => t.updatePosition())
          this.editor.ui.view.body.add(t)
          return t
        }
        _showView({
          view: t,
          balloonClassName: e = "",
          withArrow: n = true,
          singleViewMode: o = false,
        }) {
          this.view.class = e
          this.view.withArrow = n
          this._rotatorView.showView(t)
          this.visibleView = t
          this.view.pin(this._getBalloonPosition())
          this._fakePanelsView.updatePosition()
          if (o) {
            this._singleViewMode = true
          }
        }
        _getBalloonPosition() {
          let t = Array.from(this._visibleStack.values()).pop().position
          if (t) {
            if (!t.limiter) {
              t = Object.assign({}, t, { limiter: this.positionLimiter })
            }
            t = Object.assign({}, t, { viewportOffsetConfig: this.editor.ui.viewportOffset })
          }
          return t
        }
      }
      class jE extends (null && View) {
        constructor(t) {
          super(t)
          const e = t.t
          const n = this.bindTemplate
          this.set("isNavigationVisible", true)
          this.focusTracker = new FocusTracker()
          this.buttonPrevView = this._createButtonView(e("Previous"), prevIcon)
          this.buttonNextView = this._createButtonView(e("Next"), nextIcon)
          this.content = this.createCollection()
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-balloon-rotator"], "z-index": "-1" },
            children: [
              {
                tag: "div",
                attributes: {
                  class: [
                    "ck-balloon-rotator__navigation",
                    n.to("isNavigationVisible", (t) => (t ? "" : "ck-hidden")),
                  ],
                },
                children: [
                  this.buttonPrevView,
                  {
                    tag: "span",
                    attributes: { class: ["ck-balloon-rotator__counter"] },
                    children: [{ text: n.to("counter") }],
                  },
                  this.buttonNextView,
                ],
              },
              {
                tag: "div",
                attributes: { class: "ck-balloon-rotator__content" },
                children: this.content,
              },
            ],
          })
        }
        render() {
          super.render()
          this.focusTracker.add(this.element)
        }
        destroy() {
          super.destroy()
          this.focusTracker.destroy()
        }
        showView(t) {
          this.hideView()
          this.content.add(t)
        }
        hideView() {
          this.content.clear()
        }
        _createButtonView(t, e) {
          const n = new ButtonView(this.locale)
          n.set({ label: t, icon: e, tooltip: true })
          return n
        }
      }
      class HE extends (null && View) {
        constructor(t, e) {
          super(t)
          const n = this.bindTemplate
          this.set("top", 0)
          this.set("left", 0)
          this.set("height", 0)
          this.set("width", 0)
          this.set("numberOfPanels", 0)
          this.content = this.createCollection()
          this._balloonPanelView = e
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck-fake-panel", n.to("numberOfPanels", (t) => (t ? "" : "ck-hidden"))],
              style: {
                top: n.to("top", VE),
                left: n.to("left", VE),
                width: n.to("width", VE),
                height: n.to("height", VE),
              },
            },
            children: this.content,
          })
          this.on("change:numberOfPanels", (t, e, n, o) => {
            if (n > o) {
              this._addPanels(n - o)
            } else {
              this._removePanels(o - n)
            }
            this.updatePosition()
          })
        }
        _addPanels(t) {
          while (t--) {
            const t = new View()
            t.setTemplate({ tag: "div" })
            this.content.add(t)
            this.registerChild(t)
          }
        }
        _removePanels(t) {
          while (t--) {
            const t = this.content.last
            this.content.remove(t)
            this.deregisterChild(t)
            t.destroy()
          }
        }
        updatePosition() {
          if (this.numberOfPanels) {
            const { top: t, left: e } = this._balloonPanelView
            const { width: n, height: o } = new Rect(this._balloonPanelView.element)
            Object.assign(this, { top: t, left: e, width: n, height: o })
          }
        }
      }
      var WE = n(609)
      var qE = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      qE.insert = "head"
      qE.singleton = true
      var $E = Bl()(WE.Z, qE)
      const KE = WE.Z.locals || {}
      const GE = gc("px")
      class UE extends zl {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.set("isActive", false)
          this.set("isSticky", false)
          this.set("limiterElement", null)
          this.set("limiterBottomOffset", 50)
          this.set("viewportTopOffset", 0)
          this.set("_marginLeft", null)
          this.set("_isStickyToTheLimiter", false)
          this.set("_hasViewportTopOffset", false)
          this.content = this.createCollection()
          this._contentPanelPlaceholder = new Fl({
            tag: "div",
            attributes: {
              class: ["ck", "ck-sticky-panel__placeholder"],
              style: {
                display: e.to("isSticky", (t) => (t ? "block" : "none")),
                height: e.to("isSticky", (t) => (t ? GE(this._panelRect.height) : null)),
              },
            },
          }).render()
          this._contentPanel = new Fl({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-sticky-panel__content",
                e.if("isSticky", "ck-sticky-panel__content_sticky"),
                e.if("_isStickyToTheLimiter", "ck-sticky-panel__content_sticky_bottom-limit"),
              ],
              style: {
                width: e.to("isSticky", (t) =>
                  t ? GE(this._contentPanelPlaceholder.getBoundingClientRect().width) : null
                ),
                top: e.to("_hasViewportTopOffset", (t) => (t ? GE(this.viewportTopOffset) : null)),
                bottom: e.to("_isStickyToTheLimiter", (t) =>
                  t ? GE(this.limiterBottomOffset) : null
                ),
                marginLeft: e.to("_marginLeft"),
              },
            },
            children: this.content,
          }).render()
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-sticky-panel"] },
            children: [this._contentPanelPlaceholder, this._contentPanel],
          })
        }
        render() {
          super.render()
          this._checkIfShouldBeSticky()
          this.listenTo(Xa.window, "scroll", () => {
            this._checkIfShouldBeSticky()
          })
          this.listenTo(this, "change:isActive", () => {
            this._checkIfShouldBeSticky()
          })
        }
        _checkIfShouldBeSticky() {
          const t = (this._panelRect = this._contentPanel.getBoundingClientRect())
          let e
          if (!this.limiterElement) {
            this.isSticky = false
          } else {
            e = this._limiterRect = this.limiterElement.getBoundingClientRect()
            this.isSticky =
              this.isActive &&
              e.top < this.viewportTopOffset &&
              this._panelRect.height + this.limiterBottomOffset < e.height
          }
          if (this.isSticky) {
            this._isStickyToTheLimiter =
              e.bottom < t.height + this.limiterBottomOffset + this.viewportTopOffset
            this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset
            this._marginLeft = this._isStickyToTheLimiter ? null : GE(-Xa.window.scrollX)
          } else {
            this._isStickyToTheLimiter = false
            this._hasViewportTopOffset = false
            this._marginLeft = null
          }
        }
      }
      const JE = gc("px")
      class ZE extends (null && Plugin) {
        static get pluginName() {
          return "BalloonToolbar"
        }
        static get requires() {
          return [ContextualBalloon]
        }
        constructor(t) {
          super(t)
          this._resizeObserver = null
          this._balloonConfig = normalizeToolbarConfig(t.config.get("balloonToolbar"))
          this.toolbarView = this._createToolbarView()
          this.focusTracker = new FocusTracker()
          t.ui.once("ready", () => {
            this.focusTracker.add(t.ui.getEditableElement())
            this.focusTracker.add(this.toolbarView.element)
          })
          t.ui.addToolbar(this.toolbarView, {
            beforeFocus: () => this.show(true),
            afterBlur: () => this.hide(),
            isContextual: true,
          })
          this._balloon = t.plugins.get(ContextualBalloon)
          this._fireSelectionChangeDebounced = debounce(
            () => this.fire("_selectionChangeDebounced"),
            200
          )
          this.decorate("show")
        }
        init() {
          const t = this.editor
          const e = t.model.document.selection
          this.listenTo(this.focusTracker, "change:isFocused", (t, e, n) => {
            const o = this._balloon.visibleView === this.toolbarView
            if (!n && o) {
              this.hide()
            } else if (n) {
              this.show()
            }
          })
          this.listenTo(e, "change:range", (t, n) => {
            if (n.directChange || e.isCollapsed) {
              this.hide()
            }
            this._fireSelectionChangeDebounced()
          })
          this.listenTo(this, "_selectionChangeDebounced", () => {
            if (this.editor.editing.view.document.isFocused) {
              this.show()
            }
          })
          if (!this._balloonConfig.shouldNotGroupWhenFull) {
            this.listenTo(t, "ready", () => {
              const e = t.ui.view.editable.element
              this._resizeObserver = new ResizeObserver(e, (t) => {
                this.toolbarView.maxWidth = JE(t.contentRect.width * 0.9)
              })
            })
          }
          this.listenTo(this.toolbarView, "groupedItemsUpdate", () => {
            this._updatePosition()
          })
        }
        afterInit() {
          const t = this.editor.ui.componentFactory
          this.toolbarView.fillFromConfig(this._balloonConfig, t)
        }
        _createToolbarView() {
          const t = this.editor.locale.t
          const e = !this._balloonConfig.shouldNotGroupWhenFull
          const n = new ToolbarView(this.editor.locale, {
            shouldGroupWhenFull: e,
            isFloating: true,
          })
          n.ariaLabel = t("Editor contextual toolbar")
          n.render()
          return n
        }
        show(t = false) {
          const e = this.editor
          const n = e.model.document.selection
          const o = e.model.schema
          if (this._balloon.hasView(this.toolbarView)) {
            return
          }
          if (n.isCollapsed && !t) {
            return
          }
          if (YE(n, o)) {
            return
          }
          if (
            Array.from(this.toolbarView.items).every(
              (t) => t.isEnabled !== undefined && !t.isEnabled
            )
          ) {
            return
          }
          this.listenTo(this.editor.ui, "update", () => {
            this._updatePosition()
          })
          this._balloon.add({
            view: this.toolbarView,
            position: this._getBalloonPositionData(),
            balloonClassName: "ck-toolbar-container",
          })
        }
        hide() {
          if (this._balloon.hasView(this.toolbarView)) {
            this.stopListening(this.editor.ui, "update")
            this._balloon.remove(this.toolbarView)
          }
        }
        _getBalloonPositionData() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          const o = n.selection
          const r = n.selection.isBackward
          return {
            target: () => {
              const t = r ? o.getFirstRange() : o.getLastRange()
              const n = Rect.getDomRangeRects(e.domConverter.viewRangeToDom(t))
              if (r) {
                return n[0]
              } else {
                if (n.length > 1 && n[n.length - 1].width === 0) {
                  n.pop()
                }
                return n[n.length - 1]
              }
            },
            positions: this._getBalloonPositions(r),
          }
        }
        _updatePosition() {
          this._balloon.updatePosition(this._getBalloonPositionData())
        }
        destroy() {
          super.destroy()
          this.stopListening()
          this._fireSelectionChangeDebounced.cancel()
          this.toolbarView.destroy()
          this.focusTracker.destroy()
          if (this._resizeObserver) {
            this._resizeObserver.destroy()
          }
        }
        _getBalloonPositions(t) {
          const e = env.isSafari && env.isiOS
          const n = e
            ? generatePositions({
                heightOffset: Math.max(
                  BalloonPanelView.arrowHeightOffset,
                  Math.round(20 / global.window.visualViewport.scale)
                ),
              })
            : BalloonPanelView.defaultPositions
          return t
            ? [
                n.northWestArrowSouth,
                n.northWestArrowSouthWest,
                n.northWestArrowSouthEast,
                n.northWestArrowSouthMiddleEast,
                n.northWestArrowSouthMiddleWest,
                n.southWestArrowNorth,
                n.southWestArrowNorthWest,
                n.southWestArrowNorthEast,
                n.southWestArrowNorthMiddleWest,
                n.southWestArrowNorthMiddleEast,
              ]
            : [
                n.southEastArrowNorth,
                n.southEastArrowNorthEast,
                n.southEastArrowNorthWest,
                n.southEastArrowNorthMiddleEast,
                n.southEastArrowNorthMiddleWest,
                n.northEastArrowSouth,
                n.northEastArrowSouthEast,
                n.northEastArrowSouthWest,
                n.northEastArrowSouthMiddleEast,
                n.northEastArrowSouthMiddleWest,
              ]
        }
      }
      function YE(t, e) {
        if (t.rangeCount === 1) {
          return false
        }
        return [...t.getRanges()].every((t) => {
          const n = t.getContainedElement()
          return n && e.isSelectable(n)
        })
      }
      var QE = n(706)
      var XE = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      XE.insert = "head"
      XE.singleton = true
      var tD = Bl()(QE.Z, XE)
      const eD = QE.Z.locals || {}
      const nD = gc("px")
      class oD extends (null && ButtonView) {
        constructor(t) {
          super(t)
          const e = this.bindTemplate
          this.isVisible = false
          this.isToggleable = true
          this.set("top", 0)
          this.set("left", 0)
          this.extendTemplate({
            attributes: {
              class: "ck-block-toolbar-button",
              style: { top: e.to("top", (t) => nD(t)), left: e.to("left", (t) => nD(t)) },
            },
          })
        }
      }
      const rD = gc("px")
      const { pilcrow: iD } = yC
      class sD extends (null && Plugin) {
        static get pluginName() {
          return "BlockToolbar"
        }
        constructor(t) {
          super(t)
          this._resizeObserver = null
          this._blockToolbarConfig = normalizeToolbarConfig(this.editor.config.get("blockToolbar"))
          this.toolbarView = this._createToolbarView()
          this.panelView = this._createPanelView()
          this.buttonView = this._createButtonView()
          clickOutsideHandler({
            emitter: this.panelView,
            contextElements: [this.panelView.element, this.buttonView.element],
            activator: () => this.panelView.isVisible,
            callback: () => this._hidePanel(),
          })
        }
        init() {
          const t = this.editor
          this.listenTo(t.model.document.selection, "change:range", (t, e) => {
            if (e.directChange) {
              this._hidePanel()
            }
          })
          this.listenTo(t.ui, "update", () => this._updateButton())
          this.listenTo(t, "change:isReadOnly", () => this._updateButton(), { priority: "low" })
          this.listenTo(t.ui.focusTracker, "change:isFocused", () => this._updateButton())
          this.listenTo(this.buttonView, "change:isVisible", (t, e, n) => {
            if (n) {
              this.buttonView.listenTo(window, "resize", () => this._updateButton())
            } else {
              this.buttonView.stopListening(window, "resize")
              this._hidePanel()
            }
          })
          t.ui.addToolbar(this.toolbarView, {
            beforeFocus: () => this._showPanel(),
            afterBlur: () => this._hidePanel(),
          })
        }
        afterInit() {
          this.toolbarView.fillFromConfig(this._blockToolbarConfig, this.editor.ui.componentFactory)
          for (const t of this.toolbarView.items) {
            t.on("execute", () => this._hidePanel(true), { priority: "high" })
          }
        }
        destroy() {
          super.destroy()
          this.panelView.destroy()
          this.buttonView.destroy()
          this.toolbarView.destroy()
          if (this._resizeObserver) {
            this._resizeObserver.destroy()
          }
        }
        _createToolbarView() {
          const t = this.editor.locale.t
          const e = !this._blockToolbarConfig.shouldNotGroupWhenFull
          const n = new ToolbarView(this.editor.locale, {
            shouldGroupWhenFull: e,
            isFloating: true,
          })
          n.ariaLabel = t("Editor block content toolbar")
          return n
        }
        _createPanelView() {
          const t = this.editor
          const e = new BalloonPanelView(t.locale)
          e.content.add(this.toolbarView)
          e.class = "ck-toolbar-container"
          t.ui.view.body.add(e)
          t.ui.focusTracker.add(e.element)
          this.toolbarView.keystrokes.set("Esc", (t, e) => {
            this._hidePanel(true)
            e()
          })
          return e
        }
        _createButtonView() {
          const t = this.editor
          const e = t.t
          const n = new BlockButtonView(t.locale)
          n.set({ label: e("Edit block"), icon: iD, withText: false })
          n.bind("isOn").to(this.panelView, "isVisible")
          n.bind("tooltip").to(this.panelView, "isVisible", (t) => !t)
          this.listenTo(n, "execute", () => {
            if (!this.panelView.isVisible) {
              this._showPanel()
            } else {
              this._hidePanel(true)
            }
          })
          t.ui.view.body.add(n)
          t.ui.focusTracker.add(n.element)
          return n
        }
        _updateButton() {
          const t = this.editor
          const e = t.model
          const n = t.editing.view
          if (!t.ui.focusTracker.isFocused) {
            this._hideButton()
            return
          }
          if (!t.model.canEditAt(t.model.document.selection)) {
            this._hideButton()
            return
          }
          const o = Array.from(e.document.selection.getSelectedBlocks())[0]
          if (!o || Array.from(this.toolbarView.items).every((t) => !t.isEnabled)) {
            this._hideButton()
            return
          }
          const r = n.domConverter.mapViewToDom(t.editing.mapper.toViewElement(o))
          this.buttonView.isVisible = true
          this._setupToolbarResize()
          this._attachButtonToElement(r)
          if (this.panelView.isVisible) {
            this._showPanel()
          }
        }
        _hideButton() {
          this.buttonView.isVisible = false
        }
        _showPanel() {
          if (!this.buttonView.isVisible) {
            return
          }
          const t = this.panelView.isVisible
          this.panelView.show()
          const e = this._getSelectedEditableElement()
          this.toolbarView.maxWidth = this._getToolbarMaxWidth(e)
          this.panelView.pin({ target: this.buttonView.element, limiter: e })
          if (!t) {
            this.toolbarView.items.get(0).focus()
          }
        }
        _getSelectedEditableElement() {
          const t = this.editor.model.document.selection.getFirstRange().root.rootName
          return this.editor.ui.getEditableElement(t)
        }
        _hidePanel(t) {
          this.panelView.isVisible = false
          if (t) {
            this.editor.editing.view.focus()
          }
        }
        _attachButtonToElement(t) {
          const e = window.getComputedStyle(t)
          const n = new Rect(this._getSelectedEditableElement())
          const o = parseInt(e.paddingTop, 10)
          const r = parseInt(e.lineHeight, 10) || parseInt(e.fontSize, 10) * 1.2
          const i = getOptimalPosition({
            element: this.buttonView.element,
            target: t,
            positions: [
              (t, e) => {
                let i
                if (this.editor.locale.uiLanguageDirection === "ltr") {
                  i = n.left - e.width
                } else {
                  i = n.right
                }
                return { top: t.top + o + (r - e.height) / 2, left: i }
              },
            ],
          })
          this.buttonView.top = i.top
          this.buttonView.left = i.left
        }
        _setupToolbarResize() {
          const t = this._getSelectedEditableElement()
          if (!this._blockToolbarConfig.shouldNotGroupWhenFull) {
            if (this._resizeObserver && this._resizeObserver.element !== t) {
              this._resizeObserver.destroy()
              this._resizeObserver = null
            }
            if (!this._resizeObserver) {
              this._resizeObserver = new ResizeObserver(t, () => {
                this.toolbarView.maxWidth = this._getToolbarMaxWidth(t)
              })
            }
          }
        }
        _getToolbarMaxWidth(t) {
          const e = new Rect(t)
          const n = new Rect(this.buttonView.element)
          const o = this.editor.locale.uiLanguageDirection === "rtl"
          const r = o ? n.left - e.right + n.width : e.left - n.left
          return rD(e.width + r)
        }
      }
      const aD =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.209 18.717A8.5 8.5 0 1 1 18.686 9.6h-.008l.002.12a3 3 0 0 1-2.866 2.997h-.268l-.046-.002v.002h-4.791a2 2 0 1 0 0 4 1 1 0 1 1-.128 1.992 8.665 8.665 0 0 1-.372.008Zm-3.918-7.01a1.25 1.25 0 1 0-2.415-.648 1.25 1.25 0 0 0 2.415.647ZM5.723 8.18a1.25 1.25 0 1 0 .647-2.414 1.25 1.25 0 0 0-.647 2.414ZM9.76 6.155a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Zm4.028 1.759a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Z"/></svg>'
      const cD = { colorPaletteIcon: aD }
      class lD extends fE {
        constructor(t, e) {
          super(t)
          this.view = e
          this._toolbarConfig = _h(t.config.get("toolbar"))
          this._elementReplacer = new vt()
          this.listenTo(
            t.editing.view,
            "scrollToTheSelection",
            this._handleScrollToTheSelectionWithStickyPanel.bind(this)
          )
        }
        get element() {
          return this.view.element
        }
        init(t) {
          const e = this.editor
          const n = this.view
          const o = e.editing.view
          const r = n.editable
          const i = o.document.getRoot()
          r.name = i.rootName
          n.render()
          const s = r.element
          this.setEditableElement(r.name, s)
          n.editable.bind("isFocused").to(this.focusTracker)
          o.attachDomRoot(s)
          if (t) {
            this._elementReplacer.replace(t, this.element)
          }
          this._initPlaceholder()
          this._initToolbar()
          this.fire("ready")
        }
        destroy() {
          super.destroy()
          const t = this.view
          const e = this.editor.editing.view
          this._elementReplacer.restore()
          e.detachDomRoot(t.editable.name)
          t.destroy()
        }
        _initToolbar() {
          const t = this.view
          t.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused")
          t.stickyPanel.limiterElement = t.element
          t.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({ top: t }) => t || 0)
          t.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory)
          this.addToolbar(t.toolbar)
        }
        _initPlaceholder() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document.getRoot()
          const o = t.sourceElement
          let r
          const i = t.config.get("placeholder")
          if (i) {
            r = typeof i === "string" ? i : i[this.view.editable.name]
          }
          if (!r && o && o.tagName.toLowerCase() === "textarea") {
            r = o.getAttribute("placeholder")
          }
          if (r) {
            Mh({ view: e, element: n, text: r, isDirectHost: false, keepOnFocus: true })
          }
        }
        _handleScrollToTheSelectionWithStickyPanel(t, e, n) {
          const o = this.view.stickyPanel
          if (o.isSticky) {
            const t = new ac(o.element).height
            e.viewportOffset.top += t
          } else {
            const t = () => {
              this.editor.editing.view.scrollToTheSelection(n)
            }
            this.listenTo(o, "change:isSticky", t)
            setTimeout(() => {
              this.stopListening(o, "change:isSticky", t)
            }, 20)
          }
        }
      }
      var dD = n(638)
      var hD = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      hD.insert = "head"
      hD.singleton = true
      var uD = Bl()(dD.Z, hD)
      const fD = dD.Z.locals || {}
      class pD extends _E {
        constructor(t, e, n = {}) {
          super(t)
          this.stickyPanel = new UE(t)
          this.toolbar = new BC(t, { shouldGroupWhenFull: n.shouldToolbarGroupWhenFull })
          this.editable = new AE(t, e)
        }
        render() {
          super.render()
          this.stickyPanel.content.add(this.toolbar)
          this.top.add(this.stickyPanel)
          this.main.add(this.editable)
        }
      }
      class gD {
        constructor(t) {
          this.crashes = []
          this.state = "initializing"
          this._now = Date.now
          this.crashes = []
          this._crashNumberLimit = typeof t.crashNumberLimit === "number" ? t.crashNumberLimit : 3
          this._minimumNonErrorTimePeriod =
            typeof t.minimumNonErrorTimePeriod === "number" ? t.minimumNonErrorTimePeriod : 5e3
          this._boundErrorHandler = (t) => {
            const e = "error" in t ? t.error : t.reason
            if (e instanceof Error) {
              this._handleError(e, t)
            }
          }
          this._listeners = {}
          if (!this._restart) {
            throw new Error(
              "The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. " +
                "Please, use `EditorWatchdog` if you have used the `Watchdog` class previously."
            )
          }
        }
        destroy() {
          this._stopErrorHandling()
          this._listeners = {}
        }
        on(t, e) {
          if (!this._listeners[t]) {
            this._listeners[t] = []
          }
          this._listeners[t].push(e)
        }
        off(t, e) {
          this._listeners[t] = this._listeners[t].filter((t) => t !== e)
        }
        _fire(t, ...e) {
          const n = this._listeners[t] || []
          for (const t of n) {
            t.apply(this, [null, ...e])
          }
        }
        _startErrorHandling() {
          window.addEventListener("error", this._boundErrorHandler)
          window.addEventListener("unhandledrejection", this._boundErrorHandler)
        }
        _stopErrorHandling() {
          window.removeEventListener("error", this._boundErrorHandler)
          window.removeEventListener("unhandledrejection", this._boundErrorHandler)
        }
        _handleError(t, e) {
          if (this._shouldReactToError(t)) {
            this.crashes.push({
              message: t.message,
              stack: t.stack,
              filename: e instanceof ErrorEvent ? e.filename : undefined,
              lineno: e instanceof ErrorEvent ? e.lineno : undefined,
              colno: e instanceof ErrorEvent ? e.colno : undefined,
              date: this._now(),
            })
            const n = this._shouldRestart()
            this.state = "crashed"
            this._fire("stateChange")
            this._fire("error", { error: t, causesRestart: n })
            if (n) {
              this._restart()
            } else {
              this.state = "crashedPermanently"
              this._fire("stateChange")
            }
          }
        }
        _shouldReactToError(t) {
          return (
            t.is &&
            t.is("CKEditorError") &&
            t.context !== undefined &&
            t.context !== null &&
            this.state === "ready" &&
            this._isErrorComingFromThisItem(t)
          )
        }
        _shouldRestart() {
          if (this.crashes.length <= this._crashNumberLimit) {
            return true
          }
          const t = this.crashes[this.crashes.length - 1].date
          const e = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date
          const n = (t - e) / this._crashNumberLimit
          return n > this._minimumNonErrorTimePeriod
        }
      }
      function mD(t, e = new Set()) {
        const n = [t]
        const o = new Set()
        let r = 0
        while (n.length > r) {
          const t = n[r++]
          if (o.has(t) || !kD(t) || e.has(t)) {
            continue
          }
          o.add(t)
          if (Symbol.iterator in t) {
            try {
              for (const e of t) {
                n.push(e)
              }
            } catch (t) {}
          } else {
            for (const e in t) {
              if (e === "defaultValue") {
                continue
              }
              n.push(t[e])
            }
          }
        }
        return o
      }
      function kD(t) {
        const e = Object.prototype.toString.call(t)
        const n = typeof t
        return !(
          n === "number" ||
          n === "boolean" ||
          n === "string" ||
          n === "symbol" ||
          n === "function" ||
          e === "[object Date]" ||
          e === "[object RegExp]" ||
          e === "[object Module]" ||
          t === undefined ||
          t === null ||
          t._watchdogExcluded ||
          t instanceof EventTarget ||
          t instanceof Event
        )
      }
      function bD(t, e, n = new Set()) {
        if (t === e && _D(t)) {
          return true
        }
        const o = mD(t, n)
        const r = mD(e, n)
        for (const t of o) {
          if (r.has(t)) {
            return true
          }
        }
        return false
      }
      function wD(t, e, n) {
        const { subNodes: o, prevNodeMap: r } = getSubNodes(t, n.subNodes)
        const { subNodes: i, prevNodeMap: s } = getSubNodes(e, n.subNodes)
        for (const n of o) {
          if (i.has(n)) {
            const o = []
            o.push(n)
            let i = r.get(n)
            while (i && i !== t) {
              o.push(i)
              i = r.get(i)
            }
            i = s.get(n)
            while (i && i !== e) {
              o.unshift(i)
              i = s.get(i)
            }
            console.log("--------")
            console.log({ target1: t })
            console.log({ sharedNode: n })
            console.log({ target2: e })
            console.log({ connection: o })
            return true
          }
        }
        return false
      }
      function _D(t) {
        return typeof t === "object" && t !== null
      }
      class vD extends gD {
        constructor(t, e = {}) {
          super(e)
          this._editor = null
          this._throttledSave = Qx(
            this._save.bind(this),
            typeof e.saveInterval === "number" ? e.saveInterval : 5e3
          )
          if (t) {
            this._creator = (e, n) => t.create(e, n)
          }
          this._destructor = (t) => t.destroy()
        }
        get editor() {
          return this._editor
        }
        get _item() {
          return this._editor
        }
        setCreator(t) {
          this._creator = t
        }
        setDestructor(t) {
          this._destructor = t
        }
        _restart() {
          return Promise.resolve()
            .then(() => {
              this.state = "initializing"
              this._fire("stateChange")
              return this._destroy()
            })
            .catch((t) => {
              console.error("An error happened during the editor destroying.", t)
            })
            .then(() => {
              if (typeof this._elementOrData === "string") {
                return this.create(this._data, this._config, this._config.context)
              } else {
                const t = Object.assign({}, this._config, { initialData: this._data })
                return this.create(this._elementOrData, t, t.context)
              }
            })
            .then(() => {
              this._fire("restart")
            })
        }
        create(t = this._elementOrData, e = this._config, n) {
          return Promise.resolve()
            .then(() => {
              super._startErrorHandling()
              this._elementOrData = t
              this._config = this._cloneEditorConfiguration(e) || {}
              this._config.context = n
              return this._creator(t, this._config)
            })
            .then((t) => {
              this._editor = t
              t.model.document.on("change:data", this._throttledSave)
              this._lastDocumentVersion = t.model.document.version
              this._data = this._getData()
              this.state = "ready"
              this._fire("stateChange")
            })
        }
        destroy() {
          return Promise.resolve().then(() => {
            this.state = "destroyed"
            this._fire("stateChange")
            super.destroy()
            return this._destroy()
          })
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling()
            this._throttledSave.flush()
            const t = this._editor
            this._editor = null
            t.model.document.off("change:data", this._throttledSave)
            return this._destructor(t)
          })
        }
        _save() {
          const t = this._editor.model.document.version
          try {
            this._data = this._getData()
            this._lastDocumentVersion = t
          } catch (t) {
            console.error(
              t,
              "An error happened during restoring editor data. " +
                "Editor will be restored from the previously saved data."
            )
          }
        }
        _setExcludedProperties(t) {
          this._excludedProps = t
        }
        _getData() {
          const t = {}
          for (const e of this._editor.model.document.getRootNames()) {
            t[e] = this._editor.data.get({ rootName: e })
          }
          return t
        }
        _isErrorComingFromThisItem(t) {
          return bD(this._editor, t.context, this._excludedProps)
        }
        _cloneEditorConfiguration(t) {
          return Va(t, (t, e) => {
            if (ja(t)) {
              return t
            }
            if (e === "context") {
              return t
            }
          })
        }
      }
      const AD = Symbol("MainQueueId")
      class CD extends gD {
        constructor(t, e = {}) {
          super(e)
          this._watchdogs = new Map()
          this._context = null
          this._contextProps = new Set()
          this._actionQueues = new yD()
          this._watchdogConfig = e
          this._creator = (e) => t.create(e)
          this._destructor = (t) => t.destroy()
          this._actionQueues.onEmpty(() => {
            if (this.state === "initializing") {
              this.state = "ready"
              this._fire("stateChange")
            }
          })
        }
        setCreator(t) {
          this._creator = t
        }
        setDestructor(t) {
          this._destructor = t
        }
        get context() {
          return this._context
        }
        create(t = {}) {
          return this._actionQueues.enqueue(AD, () => {
            this._contextConfig = t
            return this._create()
          })
        }
        getItem(t) {
          const e = this._getWatchdog(t)
          return e._item
        }
        getItemState(t) {
          const e = this._getWatchdog(t)
          return e.state
        }
        add(t) {
          const e = xD(t)
          return Promise.all(
            e.map((t) =>
              this._actionQueues.enqueue(t.id, () => {
                if (this.state === "destroyed") {
                  throw new Error("Cannot add items to destroyed watchdog.")
                }
                if (!this._context) {
                  throw new Error(
                    "Context was not created yet. You should call the `ContextWatchdog#create()` method first."
                  )
                }
                let e
                if (this._watchdogs.has(t.id)) {
                  throw new Error(`Item with the given id is already added: '${t.id}'.`)
                }
                if (t.type === "editor") {
                  e = new vD(null, this._watchdogConfig)
                  e.setCreator(t.creator)
                  e._setExcludedProperties(this._contextProps)
                  if (t.destructor) {
                    e.setDestructor(t.destructor)
                  }
                  this._watchdogs.set(t.id, e)
                  e.on("error", (n, { error: o, causesRestart: r }) => {
                    this._fire("itemError", { itemId: t.id, error: o })
                    if (!r) {
                      return
                    }
                    this._actionQueues.enqueue(
                      t.id,
                      () =>
                        new Promise((n) => {
                          const o = () => {
                            e.off("restart", o)
                            this._fire("itemRestart", { itemId: t.id })
                            n()
                          }
                          e.on("restart", o)
                        })
                    )
                  })
                  return e.create(t.sourceElementOrData, t.config, this._context)
                } else {
                  throw new Error(`Not supported item type: '${t.type}'.`)
                }
              })
            )
          )
        }
        remove(t) {
          const e = xD(t)
          return Promise.all(
            e.map((t) =>
              this._actionQueues.enqueue(t, () => {
                const e = this._getWatchdog(t)
                this._watchdogs.delete(t)
                return e.destroy()
              })
            )
          )
        }
        destroy() {
          return this._actionQueues.enqueue(AD, () => {
            this.state = "destroyed"
            this._fire("stateChange")
            super.destroy()
            return this._destroy()
          })
        }
        _restart() {
          return this._actionQueues.enqueue(AD, () => {
            this.state = "initializing"
            this._fire("stateChange")
            return this._destroy()
              .catch((t) => {
                console.error("An error happened during destroying the context or items.", t)
              })
              .then(() => this._create())
              .then(() => this._fire("restart"))
          })
        }
        _create() {
          return Promise.resolve()
            .then(() => {
              this._startErrorHandling()
              return this._creator(this._contextConfig)
            })
            .then((t) => {
              this._context = t
              this._contextProps = mD(this._context)
              return Promise.all(
                Array.from(this._watchdogs.values()).map((t) => {
                  t._setExcludedProperties(this._contextProps)
                  return t.create(undefined, undefined, this._context)
                })
              )
            })
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling()
            const t = this._context
            this._context = null
            this._contextProps = new Set()
            return Promise.all(Array.from(this._watchdogs.values()).map((t) => t.destroy())).then(
              () => this._destructor(t)
            )
          })
        }
        _getWatchdog(t) {
          const e = this._watchdogs.get(t)
          if (!e) {
            throw new Error(`Item with the given id was not registered: ${t}.`)
          }
          return e
        }
        _isErrorComingFromThisItem(t) {
          for (const e of this._watchdogs.values()) {
            if (e._isErrorComingFromThisItem(t)) {
              return false
            }
          }
          return bD(this._context, t.context)
        }
      }
      class yD {
        constructor() {
          this._onEmptyCallbacks = []
          this._queues = new Map()
          this._activeActions = 0
        }
        onEmpty(t) {
          this._onEmptyCallbacks.push(t)
        }
        enqueue(t, e) {
          const n = t === AD
          this._activeActions++
          if (!this._queues.get(t)) {
            this._queues.set(t, Promise.resolve())
          }
          const o = n
            ? Promise.all(this._queues.values())
            : Promise.all([this._queues.get(AD), this._queues.get(t)])
          const r = o.then(e)
          const i = r.catch(() => {})
          this._queues.set(t, i)
          return r.finally(() => {
            this._activeActions--
            if (this._queues.get(t) === i && this._activeActions === 0) {
              this._onEmptyCallbacks.forEach((t) => t())
            }
          })
        }
      }
      function xD(t) {
        return Array.isArray(t) ? t : [t]
      }
      class ED extends LA(jA(NA)) {
        constructor(t, e = {}) {
          if (!SD(t) && e.initialData !== undefined) {
            throw new P("editor-create-initial-data", null)
          }
          super(e)
          if (this.config.get("initialData") === undefined) {
            this.config.set("initialData", DD(t))
          }
          if (SD(t)) {
            this.sourceElement = t
          }
          this.model.document.createRoot()
          const n = !this.config.get("toolbar.shouldNotGroupWhenFull")
          const o = new pD(this.locale, this.editing.view, { shouldToolbarGroupWhenFull: n })
          this.ui = new lD(this, o)
          FA(this)
        }
        destroy() {
          if (this.sourceElement) {
            this.updateSourceElement()
          }
          this.ui.destroy()
          return super.destroy()
        }
        static create(t, e = {}) {
          return new Promise((n) => {
            const o = new this(t, e)
            n(
              o
                .initPlugins()
                .then(() => o.ui.init(SD(t) ? t : null))
                .then(() => o.data.init(o.config.get("initialData")))
                .then(() => o.fire("ready"))
                .then(() => o)
            )
          })
        }
      }
      ED.Context = Dh
      ED.EditorWatchdog = vD
      ED.ContextWatchdog = CD
      function DD(t) {
        return SD(t) ? nc(t) : t
      }
      function SD(t) {
        return ja(t)
      }
      class TD extends Tg {
        constructor(t) {
          super(t)
          this.domEventType = [
            "paste",
            "copy",
            "cut",
            "drop",
            "dragover",
            "dragstart",
            "dragend",
            "dragenter",
            "dragleave",
          ]
          const e = this.document
          this.listenTo(e, "paste", n("clipboardInput"), { priority: "low" })
          this.listenTo(e, "drop", n("clipboardInput"), { priority: "low" })
          this.listenTo(e, "dragover", n("dragging"), { priority: "low" })
          function n(t) {
            return (n, o) => {
              o.preventDefault()
              const r = o.dropRange ? [o.dropRange] : null
              const i = new C(e, t)
              e.fire(i, {
                dataTransfer: o.dataTransfer,
                method: n.name,
                targetRanges: r,
                target: o.target,
                domEvent: o.domEvent,
              })
              if (i.stop.called) {
                o.stopPropagation()
              }
            }
          }
        }
        onDomEvent(t) {
          const e = "clipboardData" in t ? t.clipboardData : t.dataTransfer
          const n = t.type == "drop" || t.type == "paste"
          const o = { dataTransfer: new nk(e, { cacheFiles: n }) }
          if (t.type == "drop" || t.type == "dragover") {
            o.dropRange = PD(this.view, t)
          }
          this.fire(t.type, t, o)
        }
      }
      function PD(t, e) {
        const n = e.target.ownerDocument
        const o = e.clientX
        const r = e.clientY
        let i
        if (n.caretRangeFromPoint && n.caretRangeFromPoint(o, r)) {
          i = n.caretRangeFromPoint(o, r)
        } else if (e.rangeParent) {
          i = n.createRange()
          i.setStart(e.rangeParent, e.rangeOffset)
          i.collapse(true)
        }
        if (i) {
          return t.domConverter.domRangeToView(i)
        }
        return null
      }
      function BD(t) {
        t = t
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\r?\n\r?\n/g, "</p><p>")
          .replace(/\r?\n/g, "<br>")
          .replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;")
          .replace(/^\s/, "&nbsp;")
          .replace(/\s$/, "&nbsp;")
          .replace(/\s\s/g, " &nbsp;")
        if (t.includes("</p><p>") || t.includes("<br>")) {
          t = `<p>${t}</p>`
        }
        return t
      }
      function RD(t) {
        return t
          .replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (t, e) => {
            if (e.length == 1) {
              return " "
            }
            return e
          })
          .replace(/<!--[\s\S]*?-->/g, "")
      }
      const OD = ["figcaption", "li"]
      function MD(t) {
        let e = ""
        if (t.is("$text") || t.is("$textProxy")) {
          e = t.data
        } else if (t.is("element", "img") && t.hasAttribute("alt")) {
          e = t.getAttribute("alt")
        } else if (t.is("element", "br")) {
          e = "\n"
        } else {
          let n = null
          for (const o of t.getChildren()) {
            const t = MD(o)
            if (n && (n.is("containerElement") || o.is("containerElement"))) {
              if (OD.includes(n.name) || OD.includes(o.name)) {
                e += "\n"
              } else {
                e += "\n\n"
              }
            }
            e += t
            n = o
          }
        }
        return e
      }
      class ID extends vh {
        static get pluginName() {
          return "ClipboardPipeline"
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          e.addObserver(TD)
          this._setupPasteDrop()
          this._setupCopyCut()
        }
        _setupPasteDrop() {
          const t = this.editor
          const e = t.model
          const n = t.editing.view
          const o = n.document
          this.listenTo(
            o,
            "clipboardInput",
            (e, n) => {
              if (n.method == "paste" && !t.model.canEditAt(t.model.document.selection)) {
                e.stop()
              }
            },
            { priority: "highest" }
          )
          this.listenTo(
            o,
            "clipboardInput",
            (t, e) => {
              const o = e.dataTransfer
              let r
              if (e.content) {
                r = e.content
              } else {
                let t = ""
                if (o.getData("text/html")) {
                  t = RD(o.getData("text/html"))
                } else if (o.getData("text/plain")) {
                  t = BD(o.getData("text/plain"))
                }
                r = this.editor.data.htmlProcessor.toView(t)
              }
              const i = new C(this, "inputTransformation")
              this.fire(i, {
                content: r,
                dataTransfer: o,
                targetRanges: e.targetRanges,
                method: e.method,
              })
              if (i.stop.called) {
                t.stop()
              }
              n.scrollToTheSelection()
            },
            { priority: "low" }
          )
          this.listenTo(
            this,
            "inputTransformation",
            (t, n) => {
              if (n.content.isEmpty) {
                return
              }
              const o = this.editor.data
              const r = o.toModel(n.content, "$clipboardHolder")
              if (r.childCount == 0) {
                return
              }
              t.stop()
              e.change(() => {
                this.fire("contentInsertion", {
                  content: r,
                  method: n.method,
                  dataTransfer: n.dataTransfer,
                  targetRanges: n.targetRanges,
                })
              })
            },
            { priority: "low" }
          )
          this.listenTo(
            this,
            "contentInsertion",
            (t, n) => {
              n.resultRange = e.insertContent(n.content)
            },
            { priority: "low" }
          )
        }
        _setupCopyCut() {
          const t = this.editor
          const e = t.model.document
          const n = t.editing.view
          const o = n.document
          const r = (n, r) => {
            const i = r.dataTransfer
            r.preventDefault()
            const s = t.data.toView(t.model.getSelectedContent(e.selection))
            o.fire("clipboardOutput", { dataTransfer: i, content: s, method: n.name })
          }
          this.listenTo(o, "copy", r, { priority: "low" })
          this.listenTo(
            o,
            "cut",
            (e, n) => {
              if (!t.model.canEditAt(t.model.document.selection)) {
                n.preventDefault()
              } else {
                r(e, n)
              }
            },
            { priority: "low" }
          )
          this.listenTo(
            o,
            "clipboardOutput",
            (n, o) => {
              if (!o.content.isEmpty) {
                o.dataTransfer.setData(
                  "text/html",
                  this.editor.data.htmlProcessor.toData(o.content)
                )
                o.dataTransfer.setData("text/plain", MD(o.content))
              }
              if (o.method == "cut") {
                t.model.deleteContent(e.selection)
              }
            },
            { priority: "low" }
          )
        }
      }
      class zD {
        constructor(t, e = 20) {
          this._batch = null
          this.model = t
          this._size = 0
          this.limit = e
          this._isLocked = false
          this._changeCallback = (t, e) => {
            if (e.isLocal && e.isUndoable && e !== this._batch) {
              this._reset(true)
            }
          }
          this._selectionChangeCallback = () => {
            this._reset()
          }
          this.model.document.on("change", this._changeCallback)
          this.model.document.selection.on("change:range", this._selectionChangeCallback)
          this.model.document.selection.on("change:attribute", this._selectionChangeCallback)
        }
        get batch() {
          if (!this._batch) {
            this._batch = this.model.createBatch({ isTyping: true })
          }
          return this._batch
        }
        get size() {
          return this._size
        }
        input(t) {
          this._size += t
          if (this._size >= this.limit) {
            this._reset(true)
          }
        }
        get isLocked() {
          return this._isLocked
        }
        lock() {
          this._isLocked = true
        }
        unlock() {
          this._isLocked = false
        }
        destroy() {
          this.model.document.off("change", this._changeCallback)
          this.model.document.selection.off("change:range", this._selectionChangeCallback)
          this.model.document.selection.off("change:attribute", this._selectionChangeCallback)
        }
        _reset(t = false) {
          if (!this.isLocked || t) {
            this._batch = null
            this._size = 0
          }
        }
      }
      class ND extends Ch {
        constructor(t, e) {
          super(t)
          this._buffer = new zD(t.model, e)
          this._isEnabledBasedOnSelection = false
        }
        get buffer() {
          return this._buffer
        }
        destroy() {
          super.destroy()
          this._buffer.destroy()
        }
        execute(t = {}) {
          const e = this.editor.model
          const n = e.document
          const o = t.text || ""
          const r = o.length
          let i = n.selection
          if (t.selection) {
            i = t.selection
          } else if (t.range) {
            i = e.createSelection(t.range)
          }
          if (!e.canEditAt(i)) {
            return
          }
          const s = t.resultRange
          e.enqueueChange(this._buffer.batch, (t) => {
            this._buffer.lock()
            e.deleteContent(i)
            if (o) {
              e.insertContent(t.createText(o, n.selection.getAttributes()), i)
            }
            if (s) {
              t.setSelection(s)
            } else if (!i.is("documentSelection")) {
              t.setSelection(i)
            }
            this._buffer.unlock()
            this._buffer.input(r)
          })
        }
      }
      const FD = ["insertText", "insertReplacementText"]
      class VD extends xg {
        constructor(t) {
          super(t)
          if (i.isAndroid) {
            FD.push("insertCompositionText")
          }
          const e = t.document
          e.on("beforeinput", (n, o) => {
            if (!this.isEnabled) {
              return
            }
            const { data: r, targetRanges: i, inputType: s, domEvent: a } = o
            if (!FD.includes(s)) {
              return
            }
            const c = new C(e, "insertText")
            e.fire(c, new Sg(t, a, { text: r, selection: t.createSelection(i) }))
            if (c.stop.called) {
              n.stop()
            }
          })
          e.on(
            "compositionend",
            (n, { data: o, domEvent: r }) => {
              if (!this.isEnabled || i.isAndroid) {
                return
              }
              if (!o) {
                return
              }
              e.fire("insertText", new Sg(t, r, { text: o, selection: e.selection }))
            },
            { priority: "lowest" }
          )
        }
        observe() {}
        stopObserving() {}
      }
      class LD extends vh {
        static get pluginName() {
          return "Input"
        }
        init() {
          const t = this.editor
          const e = t.model
          const n = t.editing.view
          const o = e.document.selection
          n.addObserver(VD)
          const r = new ND(t, t.config.get("typing.undoStep") || 20)
          t.commands.add("insertText", r)
          t.commands.add("input", r)
          this.listenTo(n.document, "insertText", (o, r) => {
            if (!n.document.isComposing) {
              r.preventDefault()
            }
            const { text: s, selection: a, resultRange: c } = r
            const l = Array.from(a.getRanges()).map((e) => t.editing.mapper.toModelRange(e))
            let d = s
            if (i.isAndroid) {
              const t = Array.from(l[0].getItems()).reduce(
                (t, e) => t + (e.is("$textProxy") ? e.data : ""),
                ""
              )
              if (t) {
                if (t.length <= d.length) {
                  if (d.startsWith(t)) {
                    d = d.substring(t.length)
                    l[0].start = l[0].start.getShiftedBy(t.length)
                  }
                } else {
                  if (t.startsWith(d)) {
                    l[0].start = l[0].start.getShiftedBy(d.length)
                    d = ""
                  }
                }
              }
            }
            const h = { text: d, selection: e.createSelection(l) }
            if (c) {
              h.resultRange = t.editing.mapper.toModelRange(c)
            }
            t.execute("insertText", h)
          })
          if (i.isAndroid) {
            this.listenTo(n.document, "keydown", (t, i) => {
              if (o.isCollapsed || i.keyCode != 229 || !n.document.isComposing) {
                return
              }
              jD(e, r)
            })
          } else {
            this.listenTo(n.document, "compositionstart", () => {
              if (o.isCollapsed) {
                return
              }
              jD(e, r)
            })
          }
        }
      }
      function jD(t, e) {
        if (!e.isEnabled) {
          return
        }
        const n = e.buffer
        n.lock()
        t.enqueueChange(n.batch, () => {
          t.deleteContent(t.document.selection)
        })
        n.unlock()
      }
      class HD extends Ch {
        constructor(t, e) {
          super(t)
          this.direction = e
          this._buffer = new zD(t.model, t.config.get("typing.undoStep"))
          this._isEnabledBasedOnSelection = false
        }
        get buffer() {
          return this._buffer
        }
        execute(t = {}) {
          const e = this.editor.model
          const n = e.document
          e.enqueueChange(this._buffer.batch, (o) => {
            this._buffer.lock()
            const r = o.createSelection(t.selection || n.selection)
            if (!e.canEditAt(r)) {
              return
            }
            const i = t.sequence || 1
            const s = r.isCollapsed
            if (r.isCollapsed) {
              e.modifySelection(r, {
                direction: this.direction,
                unit: t.unit,
                treatEmojiAsSingleUnit: true,
              })
            }
            if (this._shouldEntireContentBeReplacedWithParagraph(i)) {
              this._replaceEntireContentWithParagraph(o)
              return
            }
            if (this._shouldReplaceFirstBlockWithParagraph(r, i)) {
              this.editor.execute("paragraph", { selection: r })
              return
            }
            if (r.isCollapsed) {
              return
            }
            let a = 0
            r.getFirstRange()
              .getMinimalFlatRanges()
              .forEach((t) => {
                a += At(
                  t.getWalker({ singleCharacters: true, ignoreElementEnd: true, shallow: true })
                )
              })
            e.deleteContent(r, { doNotResetEntireContent: s, direction: this.direction })
            this._buffer.input(a)
            o.setSelection(r)
            this._buffer.unlock()
          })
        }
        _shouldEntireContentBeReplacedWithParagraph(t) {
          if (t > 1) {
            return false
          }
          const e = this.editor.model
          const n = e.document
          const o = n.selection
          const r = e.schema.getLimitElement(o)
          const i = o.isCollapsed && o.containsEntireContent(r)
          if (!i) {
            return false
          }
          if (!e.schema.checkChild(r, "paragraph")) {
            return false
          }
          const s = r.getChild(0)
          if (s && s.is("element", "paragraph")) {
            return false
          }
          return true
        }
        _replaceEntireContentWithParagraph(t) {
          const e = this.editor.model
          const n = e.document
          const o = n.selection
          const r = e.schema.getLimitElement(o)
          const i = t.createElement("paragraph")
          t.remove(t.createRangeIn(r))
          t.insert(i, r)
          t.setSelection(i, 0)
        }
        _shouldReplaceFirstBlockWithParagraph(t, e) {
          const n = this.editor.model
          if (e > 1 || this.direction != "backward") {
            return false
          }
          if (!t.isCollapsed) {
            return false
          }
          const o = t.getFirstPosition()
          const r = n.schema.getLimitElement(o)
          const i = r.getChild(0)
          if (o.parent != i) {
            return false
          }
          if (!t.containsEntireContent(i)) {
            return false
          }
          if (!n.schema.checkChild(r, "paragraph")) {
            return false
          }
          if (i.name == "paragraph") {
            return false
          }
          return true
        }
      }
      const WD = "character"
      const qD = "word"
      const $D = "codePoint"
      const KD = "selection"
      const GD = "backward"
      const UD = "forward"
      const JD = {
        deleteContent: { unit: KD, direction: GD },
        deleteContentBackward: { unit: $D, direction: GD },
        deleteWordBackward: { unit: qD, direction: GD },
        deleteHardLineBackward: { unit: KD, direction: GD },
        deleteSoftLineBackward: { unit: KD, direction: GD },
        deleteContentForward: { unit: WD, direction: UD },
        deleteWordForward: { unit: qD, direction: UD },
        deleteHardLineForward: { unit: KD, direction: UD },
        deleteSoftLineForward: { unit: KD, direction: UD },
      }
      class ZD extends xg {
        constructor(t) {
          super(t)
          const e = t.document
          let n = 0
          e.on("keydown", () => {
            n++
          })
          e.on("keyup", () => {
            n = 0
          })
          e.on("beforeinput", (o, r) => {
            if (!this.isEnabled) {
              return
            }
            const { targetRanges: s, domEvent: a, inputType: c } = r
            const l = JD[c]
            if (!l) {
              return
            }
            const d = { direction: l.direction, unit: l.unit, sequence: n }
            if (d.unit == KD) {
              d.selectionToRemove = t.createSelection(s[0])
            }
            if (c === "deleteContentBackward") {
              if (i.isAndroid) {
                d.sequence = 1
              }
              if (QD(s)) {
                d.unit = KD
                d.selectionToRemove = t.createSelection(s)
              }
            }
            const h = new lp(e, "delete", s[0])
            e.fire(h, new Sg(t, a, d))
            if (h.stop.called) {
              o.stop()
            }
          })
          if (i.isBlink) {
            YD(this)
          }
        }
        observe() {}
        stopObserving() {}
      }
      function YD(t) {
        const e = t.view
        const n = e.document
        let o = null
        let r = false
        n.on("keydown", (t, { keyCode: e }) => {
          o = e
          r = false
        })
        n.on("keyup", (a, { keyCode: c, domEvent: l }) => {
          const d = n.selection
          const h = t.isEnabled && c == o && i(c) && !d.isCollapsed && !r
          o = null
          if (h) {
            const t = d.getFirstRange()
            const o = new lp(n, "delete", t)
            const r = { unit: KD, direction: s(c), selectionToRemove: d }
            n.fire(o, new Sg(e, l, r))
          }
        })
        n.on(
          "beforeinput",
          (t, { inputType: e }) => {
            const n = JD[e]
            const a = i(o) && n && n.direction == s(o)
            if (a) {
              r = true
            }
          },
          { priority: "high" }
        )
        n.on(
          "beforeinput",
          (t, { inputType: e, data: n }) => {
            const r = o == Wc.delete && e == "insertText" && n == ""
            if (r) {
              t.stop()
            }
          },
          { priority: "high" }
        )
        function i(t) {
          return t == Wc.backspace || t == Wc.delete
        }
        function s(t) {
          return t == Wc.backspace ? GD : UD
        }
      }
      function QD(t) {
        if (t.length != 1 || t[0].isCollapsed) {
          return false
        }
        const e = t[0].getWalker({
          direction: "backward",
          singleCharacters: true,
          ignoreElementEnd: true,
        })
        let n = 0
        for (const { nextPosition: t } of e) {
          if (!t.parent.is("$text")) {
            n++
          } else {
            const e = t.parent.data
            const o = t.offset
            if (Cl(e, o) || yl(e, o) || El(e, o)) {
              continue
            }
            n++
          }
          if (n > 1) {
            return true
          }
        }
        return false
      }
      class XD extends vh {
        static get pluginName() {
          return "Delete"
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          const o = t.model.document
          e.addObserver(ZD)
          this._undoOnBackspace = false
          const r = new HD(t, "forward")
          t.commands.add("deleteForward", r)
          t.commands.add("forwardDelete", r)
          t.commands.add("delete", new HD(t, "backward"))
          this.listenTo(
            n,
            "delete",
            (o, r) => {
              if (!n.isComposing) {
                r.preventDefault()
              }
              const { direction: i, sequence: s, selectionToRemove: a, unit: c } = r
              const l = i === "forward" ? "deleteForward" : "delete"
              const d = { sequence: s }
              if (c == "selection") {
                const e = Array.from(a.getRanges()).map((e) => t.editing.mapper.toModelRange(e))
                d.selection = t.model.createSelection(e)
              } else {
                d.unit = c
              }
              t.execute(l, d)
              e.scrollToTheSelection()
            },
            { priority: "low" }
          )
          if (this.editor.plugins.has("UndoEditing")) {
            this.listenTo(
              n,
              "delete",
              (e, n) => {
                if (
                  this._undoOnBackspace &&
                  n.direction == "backward" &&
                  n.sequence == 1 &&
                  n.unit == "codePoint"
                ) {
                  this._undoOnBackspace = false
                  t.execute("undo")
                  n.preventDefault()
                  e.stop()
                }
              },
              { context: "$capture" }
            )
            this.listenTo(o, "change", () => {
              this._undoOnBackspace = false
            })
          }
        }
        requestUndoOnBackspace() {
          if (this.editor.plugins.has("UndoEditing")) {
            this._undoOnBackspace = true
          }
        }
      }
      class tS extends vh {
        static get requires() {
          return [LD, XD]
        }
        static get pluginName() {
          return "Typing"
        }
      }
      function eS(t, e) {
        let n = t.start
        const o = Array.from(t.getWalker({ ignoreElementEnd: false })).reduce((t, { item: o }) => {
          if (!(o.is("$text") || o.is("$textProxy"))) {
            n = e.createPositionAfter(o)
            return ""
          }
          return t + o.data
        }, "")
        return { text: o, range: e.createRange(n, t.end) }
      }
      class nS extends dt() {
        constructor(t, e) {
          super()
          this.model = t
          this.testCallback = e
          this._hasMatch = false
          this.set("isEnabled", true)
          this.on("change:isEnabled", () => {
            if (this.isEnabled) {
              this._startListening()
            } else {
              this.stopListening(t.document.selection)
              this.stopListening(t.document)
            }
          })
          this._startListening()
        }
        get hasMatch() {
          return this._hasMatch
        }
        _startListening() {
          const t = this.model
          const e = t.document
          this.listenTo(e.selection, "change:range", (t, { directChange: n }) => {
            if (!n) {
              return
            }
            if (!e.selection.isCollapsed) {
              if (this.hasMatch) {
                this.fire("unmatched")
                this._hasMatch = false
              }
              return
            }
            this._evaluateTextBeforeSelection("selection")
          })
          this.listenTo(e, "change:data", (t, e) => {
            if (e.isUndo || !e.isLocal) {
              return
            }
            this._evaluateTextBeforeSelection("data", { batch: e })
          })
        }
        _evaluateTextBeforeSelection(t, e = {}) {
          const n = this.model
          const o = n.document
          const r = o.selection
          const i = n.createRange(n.createPositionAt(r.focus.parent, 0), r.focus)
          const { text: s, range: a } = eS(i, n)
          const c = this.testCallback(s)
          if (!c && this.hasMatch) {
            this.fire("unmatched")
          }
          this._hasMatch = !!c
          if (c) {
            const n = Object.assign(e, { text: s, range: a })
            if (typeof c == "object") {
              Object.assign(n, c)
            }
            this.fire(`matched:${t}`, n)
          }
        }
      }
      class oS extends (null && Plugin) {
        static get pluginName() {
          return "TwoStepCaretMovement"
        }
        constructor(t) {
          super(t)
          this.attributes = new Set()
          this._overrideUid = null
        }
        init() {
          const t = this.editor
          const e = t.model
          const n = t.editing.view
          const o = t.locale
          const r = e.document.selection
          this.listenTo(
            n.document,
            "arrowKey",
            (t, e) => {
              if (!r.isCollapsed) {
                return
              }
              if (e.shiftKey || e.altKey || e.ctrlKey) {
                return
              }
              const n = e.keyCode == keyCodes.arrowright
              const i = e.keyCode == keyCodes.arrowleft
              if (!n && !i) {
                return
              }
              const s = o.contentLanguageDirection
              let a = false
              if ((s === "ltr" && n) || (s === "rtl" && i)) {
                a = this._handleForwardMovement(e)
              } else {
                a = this._handleBackwardMovement(e)
              }
              if (a === true) {
                t.stop()
              }
            },
            { context: "$text", priority: "highest" }
          )
          this._isNextGravityRestorationSkipped = false
          this.listenTo(r, "change:range", (t, e) => {
            if (this._isNextGravityRestorationSkipped) {
              this._isNextGravityRestorationSkipped = false
              return
            }
            if (!this._isGravityOverridden) {
              return
            }
            if (!e.directChange && cS(r.getFirstPosition(), this.attributes)) {
              return
            }
            this._restoreGravity()
          })
        }
        registerAttribute(t) {
          this.attributes.add(t)
        }
        _handleForwardMovement(t) {
          const e = this.attributes
          const n = this.editor.model
          const o = n.document.selection
          const r = o.getFirstPosition()
          if (this._isGravityOverridden) {
            return false
          }
          if (r.isAtStart && rS(o, e)) {
            return false
          }
          if (cS(r, e)) {
            sS(t)
            this._overrideGravity()
            return true
          }
          return false
        }
        _handleBackwardMovement(t) {
          const e = this.attributes
          const n = this.editor.model
          const o = n.document.selection
          const r = o.getFirstPosition()
          if (this._isGravityOverridden) {
            sS(t)
            this._restoreGravity()
            iS(n, e, r)
            return true
          } else {
            if (r.isAtStart) {
              if (rS(o, e)) {
                sS(t)
                iS(n, e, r)
                return true
              }
              return false
            }
            if (aS(r, e)) {
              if (r.isAtEnd && !rS(o, e) && cS(r, e)) {
                sS(t)
                iS(n, e, r)
                return true
              }
              this._isNextGravityRestorationSkipped = true
              this._overrideGravity()
              return false
            }
          }
          return false
        }
        get _isGravityOverridden() {
          return !!this._overrideUid
        }
        _overrideGravity() {
          this._overrideUid = this.editor.model.change((t) => t.overrideSelectionGravity())
        }
        _restoreGravity() {
          this.editor.model.change((t) => {
            t.restoreSelectionGravity(this._overrideUid)
            this._overrideUid = null
          })
        }
      }
      function rS(t, e) {
        for (const n of e) {
          if (t.hasAttribute(n)) {
            return true
          }
        }
        return false
      }
      function iS(t, e, n) {
        const o = n.nodeBefore
        t.change((t) => {
          if (o) {
            t.setSelectionAttribute(o.getAttributes())
          } else {
            t.removeSelectionAttribute(e)
          }
        })
      }
      function sS(t) {
        t.preventDefault()
      }
      function aS(t, e) {
        const n = t.getShiftedBy(-1)
        return cS(n, e)
      }
      function cS(t, e) {
        const { nodeBefore: n, nodeAfter: o } = t
        for (const t of e) {
          const e = n ? n.getAttribute(t) : undefined
          const r = o ? o.getAttribute(t) : undefined
          if (r !== e) {
            return true
          }
        }
        return false
      }
      const lS = {
        copyright: { from: "(c)", to: "©" },
        registeredTrademark: { from: "(r)", to: "®" },
        trademark: { from: "(tm)", to: "™" },
        oneHalf: { from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "½", null] },
        oneThird: { from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "⅓", null] },
        twoThirds: { from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "⅔", null] },
        oneForth: { from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "¼", null] },
        threeQuarters: { from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "¾", null] },
        lessThanOrEqual: { from: "<=", to: "≤" },
        greaterThanOrEqual: { from: ">=", to: "≥" },
        notEqual: { from: "!=", to: "≠" },
        arrowLeft: { from: "<-", to: "←" },
        arrowRight: { from: "->", to: "→" },
        horizontalEllipsis: { from: "...", to: "…" },
        enDash: { from: /(^| )(--)( )$/, to: [null, "–", null] },
        emDash: { from: /(^| )(---)( )$/, to: [null, "—", null] },
        quotesPrimary: { from: mS('"'), to: [null, "“", null, "”"] },
        quotesSecondary: { from: mS("'"), to: [null, "‘", null, "’"] },
        quotesPrimaryEnGb: { from: mS("'"), to: [null, "‘", null, "’"] },
        quotesSecondaryEnGb: { from: mS('"'), to: [null, "“", null, "”"] },
        quotesPrimaryPl: { from: mS('"'), to: [null, "„", null, "”"] },
        quotesSecondaryPl: { from: mS("'"), to: [null, "‚", null, "’"] },
      }
      const dS = {
        symbols: ["copyright", "registeredTrademark", "trademark"],
        mathematical: [
          "oneHalf",
          "oneThird",
          "twoThirds",
          "oneForth",
          "threeQuarters",
          "lessThanOrEqual",
          "greaterThanOrEqual",
          "notEqual",
          "arrowLeft",
          "arrowRight",
        ],
        typography: ["horizontalEllipsis", "enDash", "emDash"],
        quotes: ["quotesPrimary", "quotesSecondary"],
      }
      const hS = null && ["symbols", "mathematical", "typography", "quotes"]
      class uS extends (null && Plugin) {
        static get requires() {
          return ["Delete", "Input"]
        }
        static get pluginName() {
          return "TextTransformation"
        }
        constructor(t) {
          super(t)
          t.config.define("typing", { transformations: { include: hS } })
        }
        init() {
          const t = this.editor.model
          const e = t.document.selection
          e.on("change:range", () => {
            this.isEnabled = !e.anchor.parent.is("element", "codeBlock")
          })
          this._enableTransformationWatchers()
        }
        _enableTransformationWatchers() {
          const t = this.editor
          const e = t.model
          const n = t.plugins.get("Delete")
          const o = kS(t.config.get("typing.transformations"))
          const r = (t) => {
            for (const e of o) {
              const n = e.from
              const o = n.test(t)
              if (o) {
                return { normalizedTransformation: e }
              }
            }
          }
          const i = new TextWatcher(t.model, r)
          i.on("matched:data", (t, o) => {
            if (!o.batch.isTyping) {
              return
            }
            const { from: r, to: i } = o.normalizedTransformation
            const s = r.exec(o.text)
            const a = i(s.slice(1))
            const c = o.range
            let l = s.index
            e.enqueueChange((t) => {
              for (let n = 1; n < s.length; n++) {
                const o = s[n]
                const r = a[n - 1]
                if (r == null) {
                  l += o.length
                  continue
                }
                const i = c.start.getShiftedBy(l)
                const d = e.createRange(i, i.getShiftedBy(o.length))
                const h = gS(i)
                e.insertContent(t.createText(r, h), d)
                l += r.length
              }
              e.enqueueChange(() => {
                n.requestUndoOnBackspace()
              })
            })
          })
          i.bind("isEnabled").to(this)
        }
      }
      function fS(t) {
        if (typeof t == "string") {
          return new RegExp(`(${escapeRegExp(t)})$`)
        }
        return t
      }
      function pS(t) {
        if (typeof t == "string") {
          return () => [t]
        } else if (t instanceof Array) {
          return () => t
        }
        return t
      }
      function gS(t) {
        const e = t.textNode ? t.textNode : t.nodeAfter
        return e.getAttributes()
      }
      function mS(t) {
        return new RegExp(`(^|\\s)(${t})([^${t}]*)(${t})$`)
      }
      function kS(t) {
        const e = t.extra || []
        const n = t.remove || []
        const o = (t) => !n.includes(t)
        const r = t.include.concat(e).filter(o)
        return bS(r)
          .filter(o)
          .map((t) => (typeof t == "string" && lS[t] ? lS[t] : t))
          .filter((t) => typeof t === "object")
          .map((t) => ({ from: fS(t.from), to: pS(t.to) }))
      }
      function bS(t) {
        const e = new Set()
        for (const n of t) {
          if (typeof n == "string" && dS[n]) {
            for (const t of dS[n]) {
              e.add(t)
            }
          } else {
            e.add(n)
          }
        }
        return Array.from(e)
      }
      function* wS(t, e) {
        for (const n of e) {
          if (n && t.getAttributeProperties(n[0]).copyOnEnter) {
            yield n
          }
        }
      }
      class _S extends Ch {
        execute() {
          this.editor.model.change((t) => {
            this.enterBlock(t)
            this.fire("afterExecute", { writer: t })
          })
        }
        enterBlock(t) {
          const e = this.editor.model
          const n = e.document.selection
          const o = e.schema
          const r = n.isCollapsed
          const i = n.getFirstRange()
          const s = i.start.parent
          const a = i.end.parent
          if (o.isLimit(s) || o.isLimit(a)) {
            if (!r && s == a) {
              e.deleteContent(n)
            }
            return false
          }
          if (r) {
            const e = wS(t.model.schema, n.getAttributes())
            vS(t, i.start)
            t.setSelectionAttribute(e)
            return true
          } else {
            const o = !(i.start.isAtStart && i.end.isAtEnd)
            const r = s == a
            e.deleteContent(n, { leaveUnmerged: o })
            if (o) {
              if (r) {
                vS(t, n.focus)
                return true
              } else {
                t.setSelection(a, 0)
              }
            }
          }
          return false
        }
      }
      function vS(t, e) {
        t.split(e)
        t.setSelection(e.parent.nextSibling, 0)
      }
      const AS = { insertParagraph: { isSoft: false }, insertLineBreak: { isSoft: true } }
      class CS extends xg {
        constructor(t) {
          super(t)
          const e = this.document
          let n = false
          e.on("keydown", (t, e) => {
            n = e.shiftKey
          })
          e.on("beforeinput", (o, r) => {
            if (!this.isEnabled) {
              return
            }
            let s = r.inputType
            if (i.isSafari && n && s == "insertParagraph") {
              s = "insertLineBreak"
            }
            const a = r.domEvent
            const c = AS[s]
            if (!c) {
              return
            }
            const l = new lp(e, "enter", r.targetRanges[0])
            e.fire(l, new Sg(t, a, { isSoft: c.isSoft }))
            if (l.stop.called) {
              o.stop()
            }
          })
        }
        observe() {}
        stopObserving() {}
      }
      class yS extends vh {
        static get pluginName() {
          return "Enter"
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          e.addObserver(CS)
          t.commands.add("enter", new _S(t))
          this.listenTo(
            n,
            "enter",
            (o, r) => {
              if (!n.isComposing) {
                r.preventDefault()
              }
              if (r.isSoft) {
                return
              }
              t.execute("enter")
              e.scrollToTheSelection()
            },
            { priority: "low" }
          )
        }
      }
      class xS extends Ch {
        execute() {
          const t = this.editor.model
          const e = t.document
          t.change((n) => {
            DS(t, n, e.selection)
            this.fire("afterExecute", { writer: n })
          })
        }
        refresh() {
          const t = this.editor.model
          const e = t.document
          this.isEnabled = ES(t.schema, e.selection)
        }
      }
      function ES(t, e) {
        if (e.rangeCount > 1) {
          return false
        }
        const n = e.anchor
        if (!n || !t.checkChild(n, "softBreak")) {
          return false
        }
        const o = e.getFirstRange()
        const r = o.start.parent
        const i = o.end.parent
        if ((TS(r, t) || TS(i, t)) && r !== i) {
          return false
        }
        return true
      }
      function DS(t, e, n) {
        const o = n.isCollapsed
        const r = n.getFirstRange()
        const i = r.start.parent
        const s = r.end.parent
        const a = i == s
        if (o) {
          const o = wS(t.schema, n.getAttributes())
          SS(t, e, r.end)
          e.removeSelectionAttribute(n.getAttributeKeys())
          e.setSelectionAttribute(o)
        } else {
          const o = !(r.start.isAtStart && r.end.isAtEnd)
          t.deleteContent(n, { leaveUnmerged: o })
          if (a) {
            SS(t, e, n.focus)
          } else {
            if (o) {
              e.setSelection(s, 0)
            }
          }
        }
      }
      function SS(t, e, n) {
        const o = e.createElement("softBreak")
        t.insertContent(o, n)
        e.setSelection(o, "after")
      }
      function TS(t, e) {
        if (t.is("rootElement")) {
          return false
        }
        return e.isLimit(t) || TS(t.parent, e)
      }
      class PS extends vh {
        static get pluginName() {
          return "ShiftEnter"
        }
        init() {
          const t = this.editor
          const e = t.model.schema
          const n = t.conversion
          const o = t.editing.view
          const r = o.document
          e.register("softBreak", { allowWhere: "$text", isInline: true })
          n.for("upcast").elementToElement({ model: "softBreak", view: "br" })
          n.for("downcast").elementToElement({
            model: "softBreak",
            view: (t, { writer: e }) => e.createEmptyElement("br"),
          })
          o.addObserver(CS)
          t.commands.add("shiftEnter", new xS(t))
          this.listenTo(
            r,
            "enter",
            (e, n) => {
              if (!r.isComposing) {
                n.preventDefault()
              }
              if (!n.isSoft) {
                return
              }
              t.execute("shiftEnter")
              o.scrollToTheSelection()
            },
            { priority: "low" }
          )
        }
      }
      class BS extends q() {
        constructor() {
          super(...arguments)
          this._stack = []
        }
        add(t, e) {
          const n = this._stack
          const o = n[0]
          this._insertDescriptor(t)
          const r = n[0]
          if (o !== r && !RS(o, r)) {
            this.fire("change:top", { oldDescriptor: o, newDescriptor: r, writer: e })
          }
        }
        remove(t, e) {
          const n = this._stack
          const o = n[0]
          this._removeDescriptor(t)
          const r = n[0]
          if (o !== r && !RS(o, r)) {
            this.fire("change:top", { oldDescriptor: o, newDescriptor: r, writer: e })
          }
        }
        _insertDescriptor(t) {
          const e = this._stack
          const n = e.findIndex((e) => e.id === t.id)
          if (RS(t, e[n])) {
            return
          }
          if (n > -1) {
            e.splice(n, 1)
          }
          let o = 0
          while (e[o] && OS(e[o], t)) {
            o++
          }
          e.splice(o, 0, t)
        }
        _removeDescriptor(t) {
          const e = this._stack
          const n = e.findIndex((e) => e.id === t)
          if (n > -1) {
            e.splice(n, 1)
          }
        }
      }
      function RS(t, e) {
        return t && e && t.priority == e.priority && MS(t.classes) == MS(e.classes)
      }
      function OS(t, e) {
        if (t.priority > e.priority) {
          return true
        } else if (t.priority < e.priority) {
          return false
        }
        return MS(t.classes) > MS(e.classes)
      }
      function MS(t) {
        return Array.isArray(t) ? t.sort().join(",") : t
      }
      const IS = "ck-widget"
      const zS = "ck-widget_selected"
      function NS(t) {
        if (!t.is("element")) {
          return false
        }
        return !!t.getCustomProperty("widget")
      }
      function FS(t, e, n = {}) {
        if (!t.is("containerElement")) {
          throw new CKEditorError("widget-to-widget-wrong-element-type", null, { element: t })
        }
        e.setAttribute("contenteditable", "false", t)
        e.addClass(IS, t)
        e.setCustomProperty("widget", true, t)
        t.getFillerOffset = GS
        e.setCustomProperty("widgetLabel", [], t)
        if (n.label) {
          HS(t, n.label)
        }
        if (n.hasSelectionHandle) {
          US(t, e)
        }
        jS(t, e)
        return t
      }
      function VS(t, e, n) {
        if (e.classes) {
          n.addClass(toArray(e.classes), t)
        }
        if (e.attributes) {
          for (const o in e.attributes) {
            n.setAttribute(o, e.attributes[o], t)
          }
        }
      }
      function LS(t, e, n) {
        if (e.classes) {
          n.removeClass(toArray(e.classes), t)
        }
        if (e.attributes) {
          for (const o in e.attributes) {
            n.removeAttribute(o, t)
          }
        }
      }
      function jS(t, e, n = VS, o = LS) {
        const r = new HighlightStack()
        r.on("change:top", (e, r) => {
          if (r.oldDescriptor) {
            o(t, r.oldDescriptor, r.writer)
          }
          if (r.newDescriptor) {
            n(t, r.newDescriptor, r.writer)
          }
        })
        const i = (t, e, n) => r.add(e, n)
        const s = (t, e, n) => r.remove(e, n)
        e.setCustomProperty("addHighlight", i, t)
        e.setCustomProperty("removeHighlight", s, t)
      }
      function HS(t, e) {
        const n = t.getCustomProperty("widgetLabel")
        n.push(e)
      }
      function WS(t) {
        const e = t.getCustomProperty("widgetLabel")
        return e.reduce((t, e) => {
          if (typeof e === "function") {
            return t ? t + ". " + e() : e()
          } else {
            return t ? t + ". " + e : e
          }
        }, "")
      }
      function qS(t, e, n = {}) {
        e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t)
        e.setAttribute("role", "textbox", t)
        if (n.label) {
          e.setAttribute("aria-label", n.label, t)
        }
        e.setAttribute("contenteditable", t.isReadOnly ? "false" : "true", t)
        t.on("change:isReadOnly", (n, o, r) => {
          e.setAttribute("contenteditable", r ? "false" : "true", t)
        })
        t.on("change:isFocused", (n, o, r) => {
          if (r) {
            e.addClass("ck-editor__nested-editable_focused", t)
          } else {
            e.removeClass("ck-editor__nested-editable_focused", t)
          }
        })
        jS(t, e)
        return t
      }
      function $S(t, e) {
        const n = t.getSelectedElement()
        if (n) {
          const o = getTypeAroundFakeCaretPosition(t)
          if (o) {
            return e.createRange(e.createPositionAt(n, o))
          }
        }
        return engineFindOptimalInsertionRange(t, e)
      }
      function KS(t, e) {
        return (n, o) => {
          const { mapper: r, viewPosition: i } = o
          const s = r.findMappedViewAncestor(i)
          if (!e(s)) {
            return
          }
          const a = r.toModelElement(s)
          o.modelPosition = t.createPositionAt(a, i.isAtStart ? "before" : "after")
        }
      }
      function GS() {
        return null
      }
      function US(t, e) {
        const n = e.createUIElement(
          "div",
          { class: "ck ck-widget__selection-handle" },
          function (t) {
            const e = this.toDomElement(t)
            const n = new IconView()
            n.set("content", dragHandleIcon)
            n.render()
            e.appendChild(n.element)
            return e
          }
        )
        e.insert(e.createPositionAt(t, 0), n)
        e.addClass(["ck-widget_with-selection-handle"], t)
      }
      const JS = "widget-type-around"
      function ZS(t, e, n) {
        return !!t && NS(t) && !n.isInline(e)
      }
      function YS(t) {
        return t.closest(".ck-widget__type-around__button")
      }
      function QS(t) {
        return t.classList.contains("ck-widget__type-around__button_before") ? "before" : "after"
      }
      function XS(t, e) {
        const n = t.closest(".ck-widget")
        return e.mapDomToView(n)
      }
      function tT(t) {
        return t.getAttribute(JS)
      }
      const eT =
        '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>'
      var nT = n(137)
      var oT = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      oT.insert = "head"
      oT.singleton = true
      var rT = Bl()(nT.Z, oT)
      const iT = nT.Z.locals || {}
      const sT = ["before", "after"]
      const aT = new DOMParser().parseFromString(eT, "image/svg+xml").firstChild
      const cT = "ck-widget__type-around_disabled"
      class lT extends vh {
        constructor() {
          super(...arguments)
          this._currentFakeCaretModelElement = null
        }
        static get pluginName() {
          return "WidgetTypeAround"
        }
        static get requires() {
          return [yS, XD]
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          this.on("change:isEnabled", (n, o, r) => {
            e.change((t) => {
              for (const n of e.document.roots) {
                if (r) {
                  t.removeClass(cT, n)
                } else {
                  t.addClass(cT, n)
                }
              }
            })
            if (!r) {
              t.model.change((t) => {
                t.removeSelectionAttribute(JS)
              })
            }
          })
          this._enableTypeAroundUIInjection()
          this._enableInsertingParagraphsOnButtonClick()
          this._enableInsertingParagraphsOnEnterKeypress()
          this._enableInsertingParagraphsOnTypingKeystroke()
          this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows()
          this._enableDeleteIntegration()
          this._enableInsertContentIntegration()
          this._enableInsertObjectIntegration()
          this._enableDeleteContentIntegration()
        }
        destroy() {
          super.destroy()
          this._currentFakeCaretModelElement = null
        }
        _insertParagraph(t, e) {
          const n = this.editor
          const o = n.editing.view
          const r = n.model.schema.getAttributesWithProperty(t, "copyOnReplace", true)
          n.execute("insertParagraph", { position: n.model.createPositionAt(t, e), attributes: r })
          o.focus()
          o.scrollToTheSelection()
        }
        _listenToIfEnabled(t, e, n, o) {
          this.listenTo(
            t,
            e,
            (...t) => {
              if (this.isEnabled) {
                n(...t)
              }
            },
            o
          )
        }
        _insertParagraphAccordingToFakeCaretPosition() {
          const t = this.editor
          const e = t.model
          const n = e.document.selection
          const o = tT(n)
          if (!o) {
            return false
          }
          const r = n.getSelectedElement()
          this._insertParagraph(r, o)
          return true
        }
        _enableTypeAroundUIInjection() {
          const t = this.editor
          const e = t.model.schema
          const n = t.locale.t
          const o = {
            before: n("Insert paragraph before block"),
            after: n("Insert paragraph after block"),
          }
          t.editing.downcastDispatcher.on(
            "insert",
            (t, r, i) => {
              const s = i.mapper.toViewElement(r.item)
              if (!s) {
                return
              }
              if (ZS(s, r.item, e)) {
                dT(i.writer, o, s)
                const t = s.getCustomProperty("widgetLabel")
                t.push(() =>
                  this.isEnabled
                    ? n(
                        "Press Enter to type after or press Shift + Enter to type before the widget"
                      )
                    : ""
                )
              }
            },
            { priority: "low" }
          )
        }
        _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
          const t = this.editor
          const e = t.model
          const n = e.document.selection
          const o = e.schema
          const r = t.editing.view
          this._listenToIfEnabled(
            r.document,
            "arrowKey",
            (t, e) => {
              this._handleArrowKeyPress(t, e)
            },
            { context: [NS, "$text"], priority: "high" }
          )
          this._listenToIfEnabled(n, "change:range", (e, n) => {
            if (!n.directChange) {
              return
            }
            t.model.change((t) => {
              t.removeSelectionAttribute(JS)
            })
          })
          this._listenToIfEnabled(e.document, "change:data", () => {
            const e = n.getSelectedElement()
            if (e) {
              const n = t.editing.mapper.toViewElement(e)
              if (ZS(n, e, o)) {
                return
              }
            }
            t.model.change((t) => {
              t.removeSelectionAttribute(JS)
            })
          })
          this._listenToIfEnabled(t.editing.downcastDispatcher, "selection", (t, e, n) => {
            const r = n.writer
            if (this._currentFakeCaretModelElement) {
              const t = n.mapper.toViewElement(this._currentFakeCaretModelElement)
              if (t) {
                r.removeClass(sT.map(i), t)
                this._currentFakeCaretModelElement = null
              }
            }
            const s = e.selection.getSelectedElement()
            if (!s) {
              return
            }
            const a = n.mapper.toViewElement(s)
            if (!ZS(a, s, o)) {
              return
            }
            const c = tT(e.selection)
            if (!c) {
              return
            }
            r.addClass(i(c), a)
            this._currentFakeCaretModelElement = s
          })
          this._listenToIfEnabled(t.ui.focusTracker, "change:isFocused", (e, n, o) => {
            if (!o) {
              t.model.change((t) => {
                t.removeSelectionAttribute(JS)
              })
            }
          })
          function i(t) {
            return `ck-widget_type-around_show-fake-caret_${t}`
          }
        }
        _handleArrowKeyPress(t, e) {
          const n = this.editor
          const o = n.model
          const r = o.document.selection
          const i = o.schema
          const s = n.editing.view
          const a = e.keyCode
          const c = Yc(a, n.locale.contentLanguageDirection)
          const l = s.document.selection.getSelectedElement()
          const d = n.editing.mapper.toModelElement(l)
          let h
          if (ZS(l, d, i)) {
            h = this._handleArrowKeyPressOnSelectedWidget(c)
          } else if (r.isCollapsed) {
            h = this._handleArrowKeyPressWhenSelectionNextToAWidget(c)
          } else if (!e.shiftKey) {
            h = this._handleArrowKeyPressWhenNonCollapsedSelection(c)
          }
          if (h) {
            e.preventDefault()
            t.stop()
          }
        }
        _handleArrowKeyPressOnSelectedWidget(t) {
          const e = this.editor
          const n = e.model
          const o = n.document.selection
          const r = tT(o)
          return n.change((e) => {
            if (r) {
              const n = r === (t ? "after" : "before")
              if (!n) {
                e.removeSelectionAttribute(JS)
                return true
              }
            } else {
              e.setSelectionAttribute(JS, t ? "after" : "before")
              return true
            }
            return false
          })
        }
        _handleArrowKeyPressWhenSelectionNextToAWidget(t) {
          const e = this.editor
          const n = e.model
          const o = n.schema
          const r = e.plugins.get("Widget")
          const i = r._getObjectElementNextToSelection(t)
          const s = e.editing.mapper.toViewElement(i)
          if (ZS(s, i, o)) {
            n.change((e) => {
              r._setSelectionOverElement(i)
              e.setSelectionAttribute(JS, t ? "before" : "after")
            })
            return true
          }
          return false
        }
        _handleArrowKeyPressWhenNonCollapsedSelection(t) {
          const e = this.editor
          const n = e.model
          const o = n.schema
          const r = e.editing.mapper
          const i = n.document.selection
          const s = t ? i.getLastPosition().nodeBefore : i.getFirstPosition().nodeAfter
          const a = r.toViewElement(s)
          if (ZS(a, s, o)) {
            n.change((e) => {
              e.setSelection(s, "on")
              e.setSelectionAttribute(JS, t ? "after" : "before")
            })
            return true
          }
          return false
        }
        _enableInsertingParagraphsOnButtonClick() {
          const t = this.editor
          const e = t.editing.view
          this._listenToIfEnabled(e.document, "mousedown", (n, o) => {
            const r = YS(o.domTarget)
            if (!r) {
              return
            }
            const i = QS(r)
            const s = XS(r, e.domConverter)
            const a = t.editing.mapper.toModelElement(s)
            this._insertParagraph(a, i)
            o.preventDefault()
            n.stop()
          })
        }
        _enableInsertingParagraphsOnEnterKeypress() {
          const t = this.editor
          const e = t.model.document.selection
          const n = t.editing.view
          this._listenToIfEnabled(
            n.document,
            "enter",
            (n, o) => {
              if (n.eventPhase != "atTarget") {
                return
              }
              const r = e.getSelectedElement()
              const i = t.editing.mapper.toViewElement(r)
              const s = t.model.schema
              let a
              if (this._insertParagraphAccordingToFakeCaretPosition()) {
                a = true
              } else if (ZS(i, r, s)) {
                this._insertParagraph(r, o.isSoft ? "before" : "after")
                a = true
              }
              if (a) {
                o.preventDefault()
                n.stop()
              }
            },
            { context: NS }
          )
        }
        _enableInsertingParagraphsOnTypingKeystroke() {
          const t = this.editor
          const e = t.editing.view.document
          this._listenToIfEnabled(
            e,
            "insertText",
            (t, n) => {
              if (this._insertParagraphAccordingToFakeCaretPosition()) {
                n.selection = e.selection
              }
            },
            { priority: "high" }
          )
          if (i.isAndroid) {
            this._listenToIfEnabled(e, "keydown", (t, e) => {
              if (e.keyCode == 229) {
                this._insertParagraphAccordingToFakeCaretPosition()
              }
            })
          } else {
            this._listenToIfEnabled(
              e,
              "compositionstart",
              () => {
                this._insertParagraphAccordingToFakeCaretPosition()
              },
              { priority: "high" }
            )
          }
        }
        _enableDeleteIntegration() {
          const t = this.editor
          const e = t.editing.view
          const n = t.model
          const o = n.schema
          this._listenToIfEnabled(
            e.document,
            "delete",
            (e, r) => {
              if (e.eventPhase != "atTarget") {
                return
              }
              const i = tT(n.document.selection)
              if (!i) {
                return
              }
              const s = r.direction
              const a = n.document.selection.getSelectedElement()
              const c = i === "before"
              const l = s == "forward"
              const d = c === l
              if (d) {
                t.execute("delete", { selection: n.createSelection(a, "on") })
              } else {
                const e = o.getNearestSelectionRange(n.createPositionAt(a, i), s)
                if (e) {
                  if (!e.isCollapsed) {
                    n.change((n) => {
                      n.setSelection(e)
                      t.execute(l ? "deleteForward" : "delete")
                    })
                  } else {
                    const r = n.createSelection(e.start)
                    n.modifySelection(r, { direction: s })
                    if (!r.focus.isEqual(e.start)) {
                      n.change((n) => {
                        n.setSelection(e)
                        t.execute(l ? "deleteForward" : "delete")
                      })
                    } else {
                      const t = fT(o, e.start.parent)
                      n.deleteContent(n.createSelection(t, "on"), { doNotAutoparagraph: true })
                    }
                  }
                }
              }
              r.preventDefault()
              e.stop()
            },
            { context: NS }
          )
        }
        _enableInsertContentIntegration() {
          const t = this.editor
          const e = this.editor.model
          const n = e.document.selection
          this._listenToIfEnabled(
            t.model,
            "insertContent",
            (t, [o, r]) => {
              if (r && !r.is("documentSelection")) {
                return
              }
              const i = tT(n)
              if (!i) {
                return
              }
              t.stop()
              return e.change((t) => {
                const r = n.getSelectedElement()
                const s = e.createPositionAt(r, i)
                const a = t.createSelection(s)
                const c = e.insertContent(o, a)
                t.setSelection(a)
                return c
              })
            },
            { priority: "high" }
          )
        }
        _enableInsertObjectIntegration() {
          const t = this.editor
          const e = this.editor.model
          const n = e.document.selection
          this._listenToIfEnabled(
            t.model,
            "insertObject",
            (t, e) => {
              const [, o, r = {}] = e
              if (o && !o.is("documentSelection")) {
                return
              }
              const i = tT(n)
              if (!i) {
                return
              }
              r.findOptimalPosition = i
              e[3] = r
            },
            { priority: "high" }
          )
        }
        _enableDeleteContentIntegration() {
          const t = this.editor
          const e = this.editor.model
          const n = e.document.selection
          this._listenToIfEnabled(
            t.model,
            "deleteContent",
            (t, [e]) => {
              if (e && !e.is("documentSelection")) {
                return
              }
              const o = tT(n)
              if (o) {
                t.stop()
              }
            },
            { priority: "high" }
          )
        }
      }
      function dT(t, e, n) {
        const o = t.createUIElement(
          "div",
          { class: "ck ck-reset_all ck-widget__type-around" },
          function (t) {
            const n = this.toDomElement(t)
            hT(n, e)
            uT(n)
            return n
          }
        )
        t.insert(t.createPositionAt(n, "end"), o)
      }
      function hT(t, e) {
        for (const n of sT) {
          const o = new Fl({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-widget__type-around__button",
                `ck-widget__type-around__button_${n}`,
              ],
              title: e[n],
              "aria-hidden": "true",
            },
            children: [t.ownerDocument.importNode(aT, true)],
          })
          t.appendChild(o.render())
        }
      }
      function uT(t) {
        const e = new Fl({
          tag: "div",
          attributes: { class: ["ck", "ck-widget__type-around__fake-caret"] },
        })
        t.appendChild(e.render())
      }
      function fT(t, e) {
        let n = e
        for (const o of e.getAncestors({ parentFirst: true })) {
          if (o.childCount > 1 || t.isLimit(o)) {
            break
          }
          n = o
        }
        return n
      }
      function pT(t) {
        const e = t.model
        return (n, o) => {
          const r = o.keyCode == Wc.arrowup
          const i = o.keyCode == Wc.arrowdown
          const s = o.shiftKey
          const a = e.document.selection
          if (!r && !i) {
            return
          }
          const c = i
          if (s && wT(a, c)) {
            return
          }
          const l = gT(t, a, c)
          if (!l) {
            return
          }
          if (l.isCollapsed) {
            if (a.isCollapsed) {
              return
            } else if (s) {
              return
            }
          }
          if (l.isCollapsed || bT(t, l, c)) {
            e.change((t) => {
              const n = c ? l.end : l.start
              if (s) {
                const o = e.createSelection(a.anchor)
                o.setFocus(n)
                t.setSelection(o)
              } else {
                t.setSelection(n)
              }
            })
            n.stop()
            o.preventDefault()
            o.stopPropagation()
          }
        }
      }
      function gT(t, e, n) {
        const o = t.model
        if (n) {
          const t = e.isCollapsed ? e.focus : e.getLastPosition()
          const n = mT(o, t, "forward")
          if (!n) {
            return null
          }
          const r = o.createRange(t, n)
          const i = kT(o.schema, r, "backward")
          if (i) {
            return o.createRange(t, i)
          }
          return null
        } else {
          const t = e.isCollapsed ? e.focus : e.getFirstPosition()
          const n = mT(o, t, "backward")
          if (!n) {
            return null
          }
          const r = o.createRange(n, t)
          const i = kT(o.schema, r, "forward")
          if (i) {
            return o.createRange(i, t)
          }
          return null
        }
      }
      function mT(t, e, n) {
        const o = t.schema
        const r = t.createRangeIn(e.root)
        const i = n == "forward" ? "elementStart" : "elementEnd"
        for (const { previousPosition: t, item: s, type: a } of r.getWalker({
          startPosition: e,
          direction: n,
        })) {
          if (o.isLimit(s) && !o.isInline(s)) {
            return t
          }
          if (a == i && o.isBlock(s)) {
            return null
          }
        }
        return null
      }
      function kT(t, e, n) {
        const o = n == "backward" ? e.end : e.start
        if (t.checkChild(o, "$text")) {
          return o
        }
        for (const { nextPosition: o } of e.getWalker({ direction: n })) {
          if (t.checkChild(o, "$text")) {
            return o
          }
        }
        return null
      }
      function bT(t, e, n) {
        const o = t.model
        const r = t.view.domConverter
        if (n) {
          const t = o.createSelection(e.start)
          o.modifySelection(t)
          if (!t.focus.isAtEnd && !e.start.isEqual(t.focus)) {
            e = o.createRange(t.focus, e.end)
          }
        }
        const i = t.mapper.toViewRange(e)
        const s = r.viewRangeToDom(i)
        const a = ac.getDomRangeRects(s)
        let c
        for (const t of a) {
          if (c === undefined) {
            c = Math.round(t.bottom)
            continue
          }
          if (Math.round(t.top) >= c) {
            return false
          }
          c = Math.max(c, Math.round(t.bottom))
        }
        return true
      }
      function wT(t, e) {
        return !t.isCollapsed && t.isBackward == e
      }
      var _T = n(507)
      var vT = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      vT.insert = "head"
      vT.singleton = true
      var AT = Bl()(_T.Z, vT)
      const CT = _T.Z.locals || {}
      class yT extends vh {
        constructor() {
          super(...arguments)
          this._previouslySelected = new Set()
        }
        static get pluginName() {
          return "Widget"
        }
        static get requires() {
          return [lT, XD]
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          this.editor.editing.downcastDispatcher.on("selection", (e, n, o) => {
            const r = o.writer
            const i = n.selection
            if (i.isCollapsed) {
              return
            }
            const s = i.getSelectedElement()
            if (!s) {
              return
            }
            const a = t.editing.mapper.toViewElement(s)
            if (!NS(a)) {
              return
            }
            if (!o.consumable.consume(i, "selection")) {
              return
            }
            r.setSelection(r.createRangeOn(a), { fake: true, label: WS(a) })
          })
          this.editor.editing.downcastDispatcher.on(
            "selection",
            (t, e, n) => {
              this._clearPreviouslySelectedWidgets(n.writer)
              const o = n.writer
              const r = o.document.selection
              let i = null
              for (const t of r.getRanges()) {
                for (const e of t) {
                  const t = e.item
                  if (NS(t) && !ET(t, i)) {
                    o.addClass(zS, t)
                    this._previouslySelected.add(t)
                    i = t
                  }
                }
              }
            },
            { priority: "low" }
          )
          e.addObserver(Hv)
          this.listenTo(n, "mousedown", (...t) => this._onMousedown(...t))
          this.listenTo(
            n,
            "arrowKey",
            (...t) => {
              this._handleSelectionChangeOnArrowKeyPress(...t)
            },
            { context: [NS, "$text"] }
          )
          this.listenTo(
            n,
            "arrowKey",
            (...t) => {
              this._preventDefaultOnArrowKeyPress(...t)
            },
            { context: "$root" }
          )
          this.listenTo(n, "arrowKey", pT(this.editor.editing), { context: "$text" })
          this.listenTo(
            n,
            "delete",
            (t, e) => {
              if (this._handleDelete(e.direction == "forward")) {
                e.preventDefault()
                t.stop()
              }
            },
            { context: "$root" }
          )
        }
        _onMousedown(t, e) {
          const n = this.editor
          const o = n.editing.view
          const r = o.document
          let s = e.target
          if (xT(s)) {
            if ((i.isSafari || i.isGecko) && e.domEvent.detail >= 3) {
              const t = n.editing.mapper
              const o = s.is("attributeElement")
                ? s.findAncestor((t) => !t.is("attributeElement"))
                : s
              const r = t.toModelElement(o)
              e.preventDefault()
              this.editor.model.change((t) => {
                t.setSelection(r, "in")
              })
            }
            return
          }
          if (!NS(s)) {
            s = s.findAncestor(NS)
            if (!s) {
              return
            }
          }
          if (i.isAndroid) {
            e.preventDefault()
          }
          if (!r.isFocused) {
            o.focus()
          }
          const a = n.editing.mapper.toModelElement(s)
          this._setSelectionOverElement(a)
        }
        _handleSelectionChangeOnArrowKeyPress(t, e) {
          const n = e.keyCode
          const o = this.editor.model
          const r = o.schema
          const i = o.document.selection
          const s = i.getSelectedElement()
          const a = Jc(n, this.editor.locale.contentLanguageDirection)
          const c = a == "down" || a == "right"
          const l = a == "up" || a == "down"
          if (s && r.isObject(s)) {
            const n = c ? i.getLastPosition() : i.getFirstPosition()
            const s = r.getNearestSelectionRange(n, c ? "forward" : "backward")
            if (s) {
              o.change((t) => {
                t.setSelection(s)
              })
              e.preventDefault()
              t.stop()
            }
            return
          }
          if (!i.isCollapsed && !e.shiftKey) {
            const n = i.getFirstPosition()
            const s = i.getLastPosition()
            const a = n.nodeAfter
            const l = s.nodeBefore
            if ((a && r.isObject(a)) || (l && r.isObject(l))) {
              o.change((t) => {
                t.setSelection(c ? s : n)
              })
              e.preventDefault()
              t.stop()
            }
            return
          }
          if (!i.isCollapsed) {
            return
          }
          const d = this._getObjectElementNextToSelection(c)
          if (d && r.isObject(d)) {
            if (r.isInline(d) && l) {
              return
            }
            this._setSelectionOverElement(d)
            e.preventDefault()
            t.stop()
          }
        }
        _preventDefaultOnArrowKeyPress(t, e) {
          const n = this.editor.model
          const o = n.schema
          const r = n.document.selection.getSelectedElement()
          if (r && o.isObject(r)) {
            e.preventDefault()
            t.stop()
          }
        }
        _handleDelete(t) {
          const e = this.editor.model.document
          const n = e.selection
          if (!this.editor.model.canEditAt(n)) {
            return
          }
          if (!n.isCollapsed) {
            return
          }
          const o = this._getObjectElementNextToSelection(t)
          if (o) {
            this.editor.model.change((t) => {
              let e = n.anchor.parent
              while (e.isEmpty) {
                const n = e
                e = n.parent
                t.remove(n)
              }
              this._setSelectionOverElement(o)
            })
            return true
          }
        }
        _setSelectionOverElement(t) {
          this.editor.model.change((e) => {
            e.setSelection(e.createRangeOn(t))
          })
        }
        _getObjectElementNextToSelection(t) {
          const e = this.editor.model
          const n = e.schema
          const o = e.document.selection
          const r = e.createSelection(o)
          e.modifySelection(r, { direction: t ? "forward" : "backward" })
          if (r.isEqual(o)) {
            return null
          }
          const i = t ? r.focus.nodeBefore : r.focus.nodeAfter
          if (!!i && n.isObject(i)) {
            return i
          }
          return null
        }
        _clearPreviouslySelectedWidgets(t) {
          for (const e of this._previouslySelected) {
            t.removeClass(zS, e)
          }
          this._previouslySelected.clear()
        }
      }
      function xT(t) {
        let e = t
        while (e) {
          if (e.is("editableElement") && !e.is("rootElement")) {
            return true
          }
          if (NS(e)) {
            return false
          }
          e = e.parent
        }
        return false
      }
      function ET(t, e) {
        if (!e) {
          return false
        }
        return Array.from(t.getAncestors()).includes(e)
      }
      class DT extends (null && Plugin) {
        constructor() {
          super(...arguments)
          this._toolbarDefinitions = new Map()
        }
        static get requires() {
          return [ContextualBalloon]
        }
        static get pluginName() {
          return "WidgetToolbarRepository"
        }
        init() {
          const t = this.editor
          if (t.plugins.has("BalloonToolbar")) {
            const e = t.plugins.get("BalloonToolbar")
            this.listenTo(
              e,
              "show",
              (e) => {
                if (PT(t.editing.view.document.selection)) {
                  e.stop()
                }
              },
              { priority: "high" }
            )
          }
          this._balloon = this.editor.plugins.get("ContextualBalloon")
          this.on("change:isEnabled", () => {
            this._updateToolbarsVisibility()
          })
          this.listenTo(t.ui, "update", () => {
            this._updateToolbarsVisibility()
          })
          this.listenTo(
            t.ui.focusTracker,
            "change:isFocused",
            () => {
              this._updateToolbarsVisibility()
            },
            { priority: "low" }
          )
        }
        destroy() {
          super.destroy()
          for (const t of this._toolbarDefinitions.values()) {
            t.view.destroy()
          }
        }
        register(
          t,
          {
            ariaLabel: e,
            items: n,
            getRelatedElement: o,
            balloonClassName: r = "ck-toolbar-container",
          }
        ) {
          if (!n.length) {
            logWarning("widget-toolbar-no-items", { toolbarId: t })
            return
          }
          const i = this.editor
          const s = i.t
          const a = new ToolbarView(i.locale)
          a.ariaLabel = e || s("Widget toolbar")
          if (this._toolbarDefinitions.has(t)) {
            throw new CKEditorError("widget-toolbar-duplicated", this, { toolbarId: t })
          }
          const c = {
            view: a,
            getRelatedElement: o,
            balloonClassName: r,
            itemsConfig: n,
            initialized: false,
          }
          i.ui.addToolbar(a, {
            isContextual: true,
            beforeFocus: () => {
              const t = o(i.editing.view.document.selection)
              if (t) {
                this._showToolbar(c, t)
              }
            },
            afterBlur: () => {
              this._hideToolbar(c)
            },
          })
          this._toolbarDefinitions.set(t, c)
        }
        _updateToolbarsVisibility() {
          let t = 0
          let e = null
          let n = null
          for (const o of this._toolbarDefinitions.values()) {
            const r = o.getRelatedElement(this.editor.editing.view.document.selection)
            if (!this.isEnabled || !r) {
              if (this._isToolbarInBalloon(o)) {
                this._hideToolbar(o)
              }
            } else if (!this.editor.ui.focusTracker.isFocused) {
              if (this._isToolbarVisible(o)) {
                this._hideToolbar(o)
              }
            } else {
              const i = r.getAncestors().length
              if (i > t) {
                t = i
                e = r
                n = o
              }
            }
          }
          if (n) {
            this._showToolbar(n, e)
          }
        }
        _hideToolbar(t) {
          this._balloon.remove(t.view)
          this.stopListening(this._balloon, "change:visibleView")
        }
        _showToolbar(t, e) {
          if (this._isToolbarVisible(t)) {
            ST(this.editor, e)
          } else if (!this._isToolbarInBalloon(t)) {
            if (!t.initialized) {
              t.initialized = true
              t.view.fillFromConfig(t.itemsConfig, this.editor.ui.componentFactory)
            }
            this._balloon.add({
              view: t.view,
              position: TT(this.editor, e),
              balloonClassName: t.balloonClassName,
            })
            this.listenTo(this._balloon, "change:visibleView", () => {
              for (const t of this._toolbarDefinitions.values()) {
                if (this._isToolbarVisible(t)) {
                  const e = t.getRelatedElement(this.editor.editing.view.document.selection)
                  ST(this.editor, e)
                }
              }
            })
          }
        }
        _isToolbarVisible(t) {
          return this._balloon.visibleView === t.view
        }
        _isToolbarInBalloon(t) {
          return this._balloon.hasView(t.view)
        }
      }
      function ST(t, e) {
        const n = t.plugins.get("ContextualBalloon")
        const o = TT(t, e)
        n.updatePosition(o)
      }
      function TT(t, e) {
        const n = t.editing.view
        const o = BalloonPanelView.defaultPositions
        return {
          target: n.domConverter.mapViewToDom(e),
          positions: [
            o.northArrowSouth,
            o.northArrowSouthWest,
            o.northArrowSouthEast,
            o.southArrowNorth,
            o.southArrowNorthWest,
            o.southArrowNorthEast,
            o.viewportStickyNorth,
          ],
        }
      }
      function PT(t) {
        const e = t.getSelectedElement()
        return !!(e && isWidget(e))
      }
      class BT extends dt() {
        constructor(t) {
          super()
          this.set("activeHandlePosition", null)
          this.set("proposedWidthPercents", null)
          this.set("proposedWidth", null)
          this.set("proposedHeight", null)
          this.set("proposedHandleHostWidth", null)
          this.set("proposedHandleHostHeight", null)
          this._options = t
          this._referenceCoordinates = null
        }
        get originalWidth() {
          return this._originalWidth
        }
        get originalHeight() {
          return this._originalHeight
        }
        get originalWidthPercents() {
          return this._originalWidthPercents
        }
        get aspectRatio() {
          return this._aspectRatio
        }
        begin(t, e, n) {
          const o = new ac(e)
          this.activeHandlePosition = IT(t)
          this._referenceCoordinates = OT(e, zT(this.activeHandlePosition))
          this._originalWidth = o.width
          this._originalHeight = o.height
          this._aspectRatio = o.width / o.height
          const r = n.style.width
          if (r && r.match(/^\d+(\.\d*)?%$/)) {
            this._originalWidthPercents = parseFloat(r)
          } else {
            this._originalWidthPercents = RT(n, o)
          }
        }
        update(t) {
          this.proposedWidth = t.width
          this.proposedHeight = t.height
          this.proposedWidthPercents = t.widthPercents
          this.proposedHandleHostWidth = t.handleHostWidth
          this.proposedHandleHostHeight = t.handleHostHeight
        }
      }
      function RT(t, e) {
        const n = t.parentElement
        let o = parseFloat(n.ownerDocument.defaultView.getComputedStyle(n).width)
        const r = 5
        let i = 0
        let s = n
        while (isNaN(o)) {
          s = s.parentElement
          if (++i > r) {
            return 0
          }
          o = parseFloat(n.ownerDocument.defaultView.getComputedStyle(s).width)
        }
        return (e.width / o) * 100
      }
      function OT(t, e) {
        const n = new ac(t)
        const o = e.split("-")
        const r = { x: o[1] == "right" ? n.right : n.left, y: o[0] == "bottom" ? n.bottom : n.top }
        r.x += t.ownerDocument.defaultView.scrollX
        r.y += t.ownerDocument.defaultView.scrollY
        return r
      }
      function MT(t) {
        return `ck-widget__resizer__handle-${t}`
      }
      function IT(t) {
        const e = ["top-left", "top-right", "bottom-right", "bottom-left"]
        for (const n of e) {
          if (t.classList.contains(MT(n))) {
            return n
          }
        }
      }
      function zT(t) {
        const e = t.split("-")
        const n = { top: "bottom", bottom: "top", left: "right", right: "left" }
        return `${n[e[0]]}-${n[e[1]]}`
      }
      class NT extends zl {
        constructor() {
          super()
          const t = this.bindTemplate
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-size-view",
                t.to("_viewPosition", (t) => (t ? `ck-orientation-${t}` : "")),
              ],
              style: { display: t.if("_isVisible", "none", (t) => !t) },
            },
            children: [{ text: t.to("_label") }],
          })
        }
        _bindToState(t, e) {
          this.bind("_isVisible").to(
            e,
            "proposedWidth",
            e,
            "proposedHeight",
            (t, e) => t !== null && e !== null
          )
          this.bind("_label").to(
            e,
            "proposedHandleHostWidth",
            e,
            "proposedHandleHostHeight",
            e,
            "proposedWidthPercents",
            (e, n, o) => {
              if (t.unit === "px") {
                return `${e}×${n}`
              } else {
                return `${o}%`
              }
            }
          )
          this.bind("_viewPosition").to(
            e,
            "activeHandlePosition",
            e,
            "proposedHandleHostWidth",
            e,
            "proposedHandleHostHeight",
            (t, e, n) => (e < 50 || n < 50 ? "above-center" : t)
          )
        }
        _dismiss() {
          this.unbind()
          this._isVisible = false
        }
      }
      class FT extends dt() {
        constructor(t) {
          super()
          this._viewResizerWrapper = null
          this._options = t
          this.set("isEnabled", true)
          this.set("isSelected", false)
          this.bind("isVisible").to(this, "isEnabled", this, "isSelected", (t, e) => t && e)
          this.decorate("begin")
          this.decorate("cancel")
          this.decorate("commit")
          this.decorate("updateSize")
          this.on(
            "commit",
            (t) => {
              if (!this.state.proposedWidth && !this.state.proposedWidthPercents) {
                this._cleanup()
                t.stop()
              }
            },
            { priority: "high" }
          )
        }
        get state() {
          return this._state
        }
        show() {
          const t = this._options.editor.editing.view
          t.change((t) => {
            t.removeClass("ck-hidden", this._viewResizerWrapper)
          })
        }
        hide() {
          const t = this._options.editor.editing.view
          t.change((t) => {
            t.addClass("ck-hidden", this._viewResizerWrapper)
          })
        }
        attach() {
          const t = this
          const e = this._options.viewElement
          const n = this._options.editor.editing.view
          n.change((n) => {
            const o = n.createUIElement(
              "div",
              { class: "ck ck-reset_all ck-widget__resizer" },
              function (e) {
                const n = this.toDomElement(e)
                t._appendHandles(n)
                t._appendSizeUI(n)
                return n
              }
            )
            n.insert(n.createPositionAt(e, "end"), o)
            n.addClass("ck-widget_with-resizer", e)
            this._viewResizerWrapper = o
            if (!this.isVisible) {
              this.hide()
            }
          })
          this.on("change:isVisible", () => {
            if (this.isVisible) {
              this.show()
              this.redraw()
            } else {
              this.hide()
            }
          })
        }
        begin(t) {
          this._state = new BT(this._options)
          this._sizeView._bindToState(this._options, this.state)
          this._initialViewWidth = this._options.viewElement.getStyle("width")
          this.state.begin(t, this._getHandleHost(), this._getResizeHost())
        }
        updateSize(t) {
          const e = this._proposeNewSize(t)
          const n = this._options.editor.editing.view
          n.change((t) => {
            const n = this._options.unit || "%"
            const o = (n === "%" ? e.widthPercents : e.width) + n
            t.setStyle("width", o, this._options.viewElement)
          })
          const o = this._getHandleHost()
          const r = new ac(o)
          const i = Math.round(r.width)
          const s = Math.round(r.height)
          const a = new ac(o)
          e.width = Math.round(a.width)
          e.height = Math.round(a.height)
          this.redraw(r)
          this.state.update({ ...e, handleHostWidth: i, handleHostHeight: s })
        }
        commit() {
          const t = this._options.unit || "%"
          const e = (t === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + t
          this._options.editor.editing.view.change(() => {
            this._cleanup()
            this._options.onCommit(e)
          })
        }
        cancel() {
          this._cleanup()
        }
        destroy() {
          this.cancel()
        }
        redraw(t) {
          const e = this._domResizerWrapper
          if (!jT(e)) {
            return
          }
          const n = e.parentElement
          const o = this._getHandleHost()
          const r = this._viewResizerWrapper
          const i = [
            r.getStyle("width"),
            r.getStyle("height"),
            r.getStyle("left"),
            r.getStyle("top"),
          ]
          let s
          if (n.isSameNode(o)) {
            const e = t || new ac(o)
            s = [e.width + "px", e.height + "px", undefined, undefined]
          } else {
            s = [
              o.offsetWidth + "px",
              o.offsetHeight + "px",
              o.offsetLeft + "px",
              o.offsetTop + "px",
            ]
          }
          if (Ct(i, s) !== "same") {
            this._options.editor.editing.view.change((t) => {
              t.setStyle({ width: s[0], height: s[1], left: s[2], top: s[3] }, r)
            })
          }
        }
        containsHandle(t) {
          return this._domResizerWrapper.contains(t)
        }
        static isResizeHandle(t) {
          return t.classList.contains("ck-widget__resizer__handle")
        }
        _cleanup() {
          this._sizeView._dismiss()
          const t = this._options.editor.editing.view
          t.change((t) => {
            t.setStyle("width", this._initialViewWidth, this._options.viewElement)
          })
        }
        _proposeNewSize(t) {
          const e = this.state
          const n = LT(t)
          const o = this._options.isCentered ? this._options.isCentered(this) : true
          const r = {
            x: e._referenceCoordinates.x - (n.x + e.originalWidth),
            y: n.y - e.originalHeight - e._referenceCoordinates.y,
          }
          if (o && e.activeHandlePosition.endsWith("-right")) {
            r.x = n.x - (e._referenceCoordinates.x + e.originalWidth)
          }
          if (o) {
            r.x *= 2
          }
          let i = Math.abs(e.originalWidth + r.x)
          let s = Math.abs(e.originalHeight + r.y)
          const a = i / e.aspectRatio > s ? "width" : "height"
          if (a == "width") {
            s = i / e.aspectRatio
          } else {
            i = s * e.aspectRatio
          }
          return {
            width: Math.round(i),
            height: Math.round(s),
            widthPercents: Math.min(
              Math.round((e.originalWidthPercents / e.originalWidth) * i * 100) / 100,
              100
            ),
          }
        }
        _getResizeHost() {
          const t = this._domResizerWrapper.parentElement
          return this._options.getResizeHost(t)
        }
        _getHandleHost() {
          const t = this._domResizerWrapper.parentElement
          return this._options.getHandleHost(t)
        }
        get _domResizerWrapper() {
          return this._options.editor.editing.view.domConverter.mapViewToDom(
            this._viewResizerWrapper
          )
        }
        _appendHandles(t) {
          const e = ["top-left", "top-right", "bottom-right", "bottom-left"]
          for (const n of e) {
            t.appendChild(
              new Fl({
                tag: "div",
                attributes: { class: `ck-widget__resizer__handle ${VT(n)}` },
              }).render()
            )
          }
        }
        _appendSizeUI(t) {
          this._sizeView = new NT()
          this._sizeView.render()
          t.appendChild(this._sizeView.element)
        }
      }
      function VT(t) {
        return `ck-widget__resizer__handle-${t}`
      }
      function LT(t) {
        return { x: t.pageX, y: t.pageY }
      }
      function jT(t) {
        return t && t.ownerDocument && t.ownerDocument.contains(t)
      }
      var HT = n(263)
      var WT = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      WT.insert = "head"
      WT.singleton = true
      var qT = Bl()(HT.Z, WT)
      const $T = HT.Z.locals || {}
      class KT extends (null && Plugin) {
        constructor() {
          super(...arguments)
          this._resizers = new Map()
        }
        static get pluginName() {
          return "WidgetResize"
        }
        init() {
          const t = this.editor.editing
          const e = global.window.document
          this.set("selectedResizer", null)
          this.set("_activeResizer", null)
          t.view.addObserver(MouseObserver)
          this._observer = new (DomEmitterMixin())()
          this.listenTo(t.view.document, "mousedown", this._mouseDownListener.bind(this), {
            priority: "high",
          })
          this._observer.listenTo(e, "mousemove", this._mouseMoveListener.bind(this))
          this._observer.listenTo(e, "mouseup", this._mouseUpListener.bind(this))
          this._redrawSelectedResizerThrottled = throttle(() => this.redrawSelectedResizer(), 200)
          this.editor.ui.on("update", this._redrawSelectedResizerThrottled)
          this.editor.model.document.on(
            "change",
            () => {
              for (const [t, e] of this._resizers) {
                if (!t.isAttached()) {
                  this._resizers.delete(t)
                  e.destroy()
                }
              }
            },
            { priority: "lowest" }
          )
          this._observer.listenTo(global.window, "resize", this._redrawSelectedResizerThrottled)
          const n = this.editor.editing.view.document.selection
          n.on("change", () => {
            const t = n.getSelectedElement()
            const e = this.getResizerByViewElement(t) || null
            if (e) {
              this.select(e)
            } else {
              this.deselect()
            }
          })
        }
        redrawSelectedResizer() {
          if (this.selectedResizer && this.selectedResizer.isVisible) {
            this.selectedResizer.redraw()
          }
        }
        destroy() {
          super.destroy()
          this._observer.stopListening()
          for (const t of this._resizers.values()) {
            t.destroy()
          }
          this._redrawSelectedResizerThrottled.cancel()
        }
        select(t) {
          this.deselect()
          this.selectedResizer = t
          this.selectedResizer.isSelected = true
        }
        deselect() {
          if (this.selectedResizer) {
            this.selectedResizer.isSelected = false
          }
          this.selectedResizer = null
        }
        attachTo(t) {
          const e = new Resizer(t)
          const n = this.editor.plugins
          e.attach()
          if (n.has("WidgetToolbarRepository")) {
            const t = n.get("WidgetToolbarRepository")
            e.on(
              "begin",
              () => {
                t.forceDisabled("resize")
              },
              { priority: "lowest" }
            )
            e.on(
              "cancel",
              () => {
                t.clearForceDisabled("resize")
              },
              { priority: "highest" }
            )
            e.on(
              "commit",
              () => {
                t.clearForceDisabled("resize")
              },
              { priority: "highest" }
            )
          }
          this._resizers.set(t.viewElement, e)
          const o = this.editor.editing.view.document.selection
          const r = o.getSelectedElement()
          if (this.getResizerByViewElement(r) == e) {
            this.select(e)
          }
          return e
        }
        getResizerByViewElement(t) {
          return this._resizers.get(t)
        }
        _getResizerByHandle(t) {
          for (const e of this._resizers.values()) {
            if (e.containsHandle(t)) {
              return e
            }
          }
        }
        _mouseDownListener(t, e) {
          const n = e.domTarget
          if (!Resizer.isResizeHandle(n)) {
            return
          }
          this._activeResizer = this._getResizerByHandle(n) || null
          if (this._activeResizer) {
            this._activeResizer.begin(n)
            t.stop()
            e.preventDefault()
          }
        }
        _mouseMoveListener(t, e) {
          if (this._activeResizer) {
            this._activeResizer.updateSize(e)
          }
        }
        _mouseUpListener() {
          if (this._activeResizer) {
            this._activeResizer.commit()
            this._activeResizer = null
          }
        }
      }
      var GT = n(390)
      var UT = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }
      UT.insert = "head"
      UT.singleton = true
      var JT = Bl()(GT.Z, UT)
      const ZT = GT.Z.locals || {}
      class YT extends vh {
        static get pluginName() {
          return "DragDrop"
        }
        static get requires() {
          return [ID, yT]
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          this._draggedRange = null
          this._draggingUid = ""
          this._draggableElement = null
          this._updateDropMarkerThrottled = Qx((t) => this._updateDropMarker(t), 40)
          this._removeDropMarkerDelayed = bl(() => this._removeDropMarker(), 40)
          this._clearDraggableAttributesDelayed = bl(() => this._clearDraggableAttributes(), 40)
          if (t.plugins.has("DragDropExperimental")) {
            this.forceDisabled("DragDropExperimental")
            return
          }
          e.addObserver(TD)
          e.addObserver(Hv)
          this._setupDragging()
          this._setupContentInsertionIntegration()
          this._setupClipboardInputIntegration()
          this._setupDropMarker()
          this._setupDraggableAttributeHandling()
          this.listenTo(t, "change:isReadOnly", (t, e, n) => {
            if (n) {
              this.forceDisabled("readOnlyMode")
            } else {
              this.clearForceDisabled("readOnlyMode")
            }
          })
          this.on("change:isEnabled", (t, e, n) => {
            if (!n) {
              this._finalizeDragging(false)
            }
          })
          if (i.isAndroid) {
            this.forceDisabled("noAndroidSupport")
          }
        }
        destroy() {
          if (this._draggedRange) {
            this._draggedRange.detach()
            this._draggedRange = null
          }
          this._updateDropMarkerThrottled.cancel()
          this._removeDropMarkerDelayed.cancel()
          this._clearDraggableAttributesDelayed.cancel()
          return super.destroy()
        }
        _setupDragging() {
          const t = this.editor
          const e = t.model
          const n = e.document
          const o = t.editing.view
          const r = o.document
          this.listenTo(
            r,
            "dragstart",
            (o, i) => {
              const s = n.selection
              if (i.target && i.target.is("editableElement")) {
                i.preventDefault()
                return
              }
              const a = i.target ? iP(i.target) : null
              if (a) {
                const n = t.editing.mapper.toModelElement(a)
                this._draggedRange = qk.fromRange(e.createRangeOn(n))
                if (t.plugins.has("WidgetToolbarRepository")) {
                  const e = t.plugins.get("WidgetToolbarRepository")
                  e.forceDisabled("dragDrop")
                }
              } else if (!r.selection.isCollapsed) {
                const t = r.selection.getSelectedElement()
                if (!t || !NS(t)) {
                  this._draggedRange = qk.fromRange(s.getFirstRange())
                }
              }
              if (!this._draggedRange) {
                i.preventDefault()
                return
              }
              this._draggingUid = x()
              const c = this.isEnabled && t.model.canEditAt(this._draggedRange)
              i.dataTransfer.effectAllowed = c ? "copyMove" : "copy"
              i.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid)
              const l = e.createSelection(this._draggedRange.toRange())
              const d = t.data.toView(e.getSelectedContent(l))
              r.fire("clipboardOutput", {
                dataTransfer: i.dataTransfer,
                content: d,
                method: "dragstart",
              })
              if (!c) {
                this._draggedRange.detach()
                this._draggedRange = null
                this._draggingUid = ""
              }
            },
            { priority: "low" }
          )
          this.listenTo(
            r,
            "dragend",
            (t, e) => {
              this._finalizeDragging(
                !e.dataTransfer.isCanceled && e.dataTransfer.dropEffect == "move"
              )
            },
            { priority: "low" }
          )
          this.listenTo(r, "dragenter", () => {
            if (!this.isEnabled) {
              return
            }
            o.focus()
          })
          this.listenTo(r, "dragleave", () => {
            this._removeDropMarkerDelayed()
          })
          this.listenTo(
            r,
            "dragging",
            (e, n) => {
              if (!this.isEnabled) {
                n.dataTransfer.dropEffect = "none"
                return
              }
              this._removeDropMarkerDelayed.cancel()
              const o = QT(t, n.targetRanges, n.target)
              if (!t.model.canEditAt(o)) {
                n.dataTransfer.dropEffect = "none"
                return
              }
              if (!this._draggedRange) {
                n.dataTransfer.dropEffect = "copy"
              }
              if (!i.isGecko) {
                if (n.dataTransfer.effectAllowed == "copy") {
                  n.dataTransfer.dropEffect = "copy"
                } else if (["all", "copyMove"].includes(n.dataTransfer.effectAllowed)) {
                  n.dataTransfer.dropEffect = "move"
                }
              }
              if (o) {
                this._updateDropMarkerThrottled(o)
              }
            },
            { priority: "low" }
          )
        }
        _setupClipboardInputIntegration() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          this.listenTo(
            n,
            "clipboardInput",
            (e, n) => {
              if (n.method != "drop") {
                return
              }
              const o = QT(t, n.targetRanges, n.target)
              this._removeDropMarker()
              if (!o || !t.model.canEditAt(o)) {
                this._finalizeDragging(false)
                e.stop()
                return
              }
              if (
                this._draggedRange &&
                this._draggingUid != n.dataTransfer.getData("application/ckeditor5-dragging-uid")
              ) {
                this._draggedRange.detach()
                this._draggedRange = null
                this._draggingUid = ""
              }
              const r = rP(n.dataTransfer) == "move"
              if (r && this._draggedRange && this._draggedRange.containsRange(o, true)) {
                this._finalizeDragging(false)
                e.stop()
                return
              }
              n.targetRanges = [t.editing.mapper.toViewRange(o)]
            },
            { priority: "high" }
          )
        }
        _setupContentInsertionIntegration() {
          const t = this.editor.plugins.get(ID)
          t.on(
            "contentInsertion",
            (t, e) => {
              if (!this.isEnabled || e.method !== "drop") {
                return
              }
              const n = e.targetRanges.map((t) => this.editor.editing.mapper.toModelRange(t))
              this.editor.model.change((t) => t.setSelection(n))
            },
            { priority: "high" }
          )
          t.on(
            "contentInsertion",
            (t, e) => {
              if (!this.isEnabled || e.method !== "drop") {
                return
              }
              const n = rP(e.dataTransfer) == "move"
              const o = !e.resultRange || !e.resultRange.isCollapsed
              this._finalizeDragging(o && n)
            },
            { priority: "lowest" }
          )
        }
        _setupDraggableAttributeHandling() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          this.listenTo(n, "mousedown", (o, r) => {
            if (i.isAndroid || !r) {
              return
            }
            this._clearDraggableAttributesDelayed.cancel()
            let s = iP(r.target)
            if (i.isBlink && !s && !n.selection.isCollapsed) {
              const t = n.selection.getSelectedElement()
              if (!t || !NS(t)) {
                const t = n.selection.editableElement
                if (t && !t.isReadOnly) {
                  s = t
                }
              }
            }
            if (s) {
              e.change((t) => {
                t.setAttribute("draggable", "true", s)
              })
              this._draggableElement = t.editing.mapper.toModelElement(s)
            }
          })
          this.listenTo(n, "mouseup", () => {
            if (!i.isAndroid) {
              this._clearDraggableAttributesDelayed()
            }
          })
        }
        _clearDraggableAttributes() {
          const t = this.editor.editing
          t.view.change((e) => {
            if (this._draggableElement && this._draggableElement.root.rootName != "$graveyard") {
              e.removeAttribute("draggable", t.mapper.toViewElement(this._draggableElement))
            }
            this._draggableElement = null
          })
        }
        _setupDropMarker() {
          const t = this.editor
          t.conversion.for("editingDowncast").markerToHighlight({
            model: "drop-target",
            view: { classes: ["ck-clipboard-drop-target-range"] },
          })
          t.conversion.for("editingDowncast").markerToElement({
            model: "drop-target",
            view: (e, { writer: n }) => {
              const o = t.model.schema.checkChild(e.markerRange.start, "$text")
              if (!o) {
                return
              }
              return n.createUIElement(
                "span",
                { class: "ck ck-clipboard-drop-target-position" },
                function (t) {
                  const e = this.toDomElement(t)
                  e.append("⁠", t.createElement("span"), "⁠")
                  return e
                }
              )
            },
          })
        }
        _updateDropMarker(t) {
          const e = this.editor
          const n = e.model.markers
          e.model.change((e) => {
            if (n.has("drop-target")) {
              if (!n.get("drop-target").getRange().isEqual(t)) {
                e.updateMarker("drop-target", { range: t })
              }
            } else {
              e.addMarker("drop-target", { range: t, usingOperation: false, affectsData: false })
            }
          })
        }
        _removeDropMarker() {
          const t = this.editor.model
          this._removeDropMarkerDelayed.cancel()
          this._updateDropMarkerThrottled.cancel()
          if (t.markers.has("drop-target")) {
            t.change((t) => {
              t.removeMarker("drop-target")
            })
          }
        }
        _finalizeDragging(t) {
          const e = this.editor
          const n = e.model
          this._removeDropMarker()
          this._clearDraggableAttributes()
          if (e.plugins.has("WidgetToolbarRepository")) {
            const t = e.plugins.get("WidgetToolbarRepository")
            t.clearForceDisabled("dragDrop")
          }
          this._draggingUid = ""
          if (!this._draggedRange) {
            return
          }
          if (t && this.isEnabled) {
            n.deleteContent(n.createSelection(this._draggedRange), { doNotAutoparagraph: true })
          }
          this._draggedRange.detach()
          this._draggedRange = null
        }
      }
      function QT(t, e, n) {
        const o = t.model
        const r = t.editing.mapper
        let s = null
        const a = e ? e[0].start : null
        if (n.is("uiElement")) {
          n = n.parent
        }
        s = XT(t, n)
        if (s) {
          return s
        }
        const c = oP(t, n)
        const l = a ? r.toModelPosition(a) : null
        if (!l) {
          return tP(t, c)
        }
        s = eP(t, l, c)
        if (s) {
          return s
        }
        s = o.schema.getNearestSelectionRange(l, i.isGecko ? "forward" : "backward")
        if (s) {
          return s
        }
        return nP(t, l.parent)
      }
      function XT(t, e) {
        const n = t.model
        const o = t.editing.mapper
        if (NS(e)) {
          return n.createRangeOn(o.toModelElement(e))
        }
        if (!e.is("editableElement")) {
          const t = e.findAncestor((t) => NS(t) || t.is("editableElement"))
          if (NS(t)) {
            return n.createRangeOn(o.toModelElement(t))
          }
        }
        return null
      }
      function tP(t, e) {
        const n = t.model
        const o = n.schema
        const r = n.createPositionAt(e, 0)
        return o.getNearestSelectionRange(r, "forward")
      }
      function eP(t, e, n) {
        const o = t.model
        if (!o.schema.checkChild(n, "$block")) {
          return null
        }
        const r = o.createPositionAt(n, 0)
        const i = e.path.slice(0, r.path.length)
        const s = o.createPositionFromPath(e.root, i)
        const a = s.nodeAfter
        if (a && o.schema.isObject(a)) {
          return o.createRangeOn(a)
        }
        return null
      }
      function nP(t, e) {
        const n = t.model
        let o = e
        while (o) {
          if (n.schema.isObject(o)) {
            return n.createRangeOn(o)
          }
          o = o.parent
        }
        return null
      }
      function oP(t, e) {
        const n = t.editing.mapper
        const o = t.editing.view
        const r = n.toModelElement(e)
        if (r) {
          return r
        }
        const i = o.createPositionBefore(e)
        const s = n.findMappedViewAncestor(i)
        return n.toModelElement(s)
      }
      function rP(t) {
        if (i.isGecko) {
          return t.dropEffect
        }
        return ["all", "copyMove"].includes(t.effectAllowed) ? "move" : "copy"
      }
      function iP(t) {
        if (t.is("editableElement")) {
          return null
        }
        if (t.hasClass("ck-widget__selection-handle")) {
          return t.findAncestor(NS)
        }
        if (NS(t)) {
          return t
        }
        const e = t.findAncestor((t) => NS(t) || t.is("editableElement"))
        if (NS(e)) {
          return e
        }
        return null
      }
      class sP extends vh {
        static get pluginName() {
          return "PastePlainText"
        }
        static get requires() {
          return [ID]
        }
        init() {
          const t = this.editor
          const e = t.model
          const n = t.editing.view
          const o = n.document
          const r = e.document.selection
          let i = false
          n.addObserver(TD)
          this.listenTo(o, "keydown", (t, e) => {
            i = e.shiftKey
          })
          t.plugins.get(ID).on("contentInsertion", (t, n) => {
            if (!i && !aP(n.content, e.schema)) {
              return
            }
            e.change((t) => {
              const o = Array.from(r.getAttributes()).filter(
                ([t]) => e.schema.getAttributeProperties(t).isFormatting
              )
              if (!r.isCollapsed) {
                e.deleteContent(r, { doNotAutoparagraph: true })
              }
              o.push(...r.getAttributes())
              const i = t.createRangeIn(n.content)
              for (const e of i.getItems()) {
                if (e.is("$textProxy")) {
                  t.setAttributes(o, e)
                }
              }
            })
          })
        }
      }
      function aP(t, e) {
        if (t.childCount > 1) {
          return false
        }
        const n = t.getChild(0)
        if (e.isObject(n)) {
          return false
        }
        return Array.from(n.getAttributeKeys()).length == 0
      }
      class cP extends vh {
        static get pluginName() {
          return "Clipboard"
        }
        static get requires() {
          return [ID, YT, sP]
        }
      }
      const lP = gc("px")
      class dP extends (null && View) {
        constructor() {
          super()
          const t = this.bindTemplate
          this.set({ isVisible: false, left: null, top: null, width: null })
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-clipboard-drop-target-line",
                t.if("isVisible", "ck-hidden", (t) => !t),
              ],
              style: {
                left: t.to("left", (t) => lP(t)),
                top: t.to("top", (t) => lP(t)),
                width: t.to("width", (t) => lP(t)),
              },
            },
          })
        }
      }
      class hP extends (null && Plugin) {
        constructor() {
          super(...arguments)
          this.removeDropMarkerDelayed = delay(() => this.removeDropMarker(), 40)
          this._updateDropMarkerThrottled = throttle((t) => this._updateDropMarker(t), 40)
          this._reconvertMarkerThrottled = throttle(() => {
            if (this.editor.model.markers.has("drop-target")) {
              this.editor.editing.reconvertMarker("drop-target")
            }
          }, 0)
          this._dropTargetLineView = new LineView()
          this._domEmitter = new (DomEmitterMixin())()
          this._scrollables = new Map()
        }
        static get pluginName() {
          return "DragDropTarget"
        }
        init() {
          this._setupDropMarker()
        }
        destroy() {
          this._domEmitter.stopListening()
          for (const { resizeObserver: t } of this._scrollables.values()) {
            t.destroy()
          }
          this._updateDropMarkerThrottled.cancel()
          this.removeDropMarkerDelayed.cancel()
          this._reconvertMarkerThrottled.cancel()
          return super.destroy()
        }
        updateDropMarker(t, e, n, o, r) {
          this.removeDropMarkerDelayed.cancel()
          const i = uP(this.editor, t, e, n, o, r)
          if (i) {
            this._updateDropMarkerThrottled(i)
          }
        }
        getFinalDropRange(t, e, n, o, r) {
          const i = uP(this.editor, t, e, n, o, r)
          this.removeDropMarker()
          return i
        }
        removeDropMarker() {
          const t = this.editor.model
          this.removeDropMarkerDelayed.cancel()
          this._updateDropMarkerThrottled.cancel()
          this._dropTargetLineView.isVisible = false
          if (t.markers.has("drop-target")) {
            t.change((t) => {
              t.removeMarker("drop-target")
            })
          }
        }
        _setupDropMarker() {
          const t = this.editor
          t.ui.view.body.add(this._dropTargetLineView)
          t.conversion.for("editingDowncast").markerToHighlight({
            model: "drop-target",
            view: { classes: ["ck-clipboard-drop-target-range"] },
          })
          t.conversion.for("editingDowncast").markerToElement({
            model: "drop-target",
            view: (e, { writer: n }) => {
              if (t.model.schema.checkChild(e.markerRange.start, "$text")) {
                this._dropTargetLineView.isVisible = false
                return this._createDropTargetPosition(n)
              } else {
                if (e.markerRange.isCollapsed) {
                  this._updateDropTargetLine(e.markerRange)
                } else {
                  this._dropTargetLineView.isVisible = false
                }
              }
            },
          })
        }
        _updateDropMarker(t) {
          const e = this.editor
          const n = e.model.markers
          e.model.change((e) => {
            if (n.has("drop-target")) {
              if (!n.get("drop-target").getRange().isEqual(t)) {
                e.updateMarker("drop-target", { range: t })
              }
            } else {
              e.addMarker("drop-target", { range: t, usingOperation: false, affectsData: false })
            }
          })
        }
        _createDropTargetPosition(t) {
          return t.createUIElement(
            "span",
            { class: "ck ck-clipboard-drop-target-position" },
            function (t) {
              const e = this.toDomElement(t)
              e.append("⁠", t.createElement("span"), "⁠")
              return e
            }
          )
        }
        _updateDropTargetLine(t) {
          const e = this.editor.editing
          const n = t.start.nodeBefore
          const o = t.start.nodeAfter
          const r = t.start.parent
          const i = n ? e.mapper.toViewElement(n) : null
          const s = i ? e.view.domConverter.mapViewToDom(i) : null
          const a = o ? e.mapper.toViewElement(o) : null
          const c = a ? e.view.domConverter.mapViewToDom(a) : null
          const l = e.mapper.toViewElement(r)
          const d = e.view.domConverter.mapViewToDom(l)
          const h = this._getScrollableRect(l)
          const { scrollX: u, scrollY: f } = global.window
          const p = s ? new Rect(s) : null
          const g = c ? new Rect(c) : null
          const m = new Rect(d).excludeScrollbarsAndBorders()
          const k = p ? p.bottom : m.top
          const b = g ? g.top : m.bottom
          const w = global.window.getComputedStyle(d)
          const _ = k <= b ? (k + b) / 2 : b
          if (h.top < _ && _ < h.bottom) {
            const t = m.left + parseFloat(w.paddingLeft)
            const e = m.right - parseFloat(w.paddingRight)
            const n = Math.max(t + u, h.left)
            const o = Math.min(e + u, h.right)
            this._dropTargetLineView.set({ isVisible: true, left: n, top: _ + f, width: o - n })
          } else {
            this._dropTargetLineView.isVisible = false
          }
        }
        _getScrollableRect(t) {
          const e = t.root.rootName
          let n
          if (this._scrollables.has(e)) {
            n = this._scrollables.get(e).domElement
          } else {
            const o = this.editor.editing.view.domConverter.mapViewToDom(t)
            n = kP(o)
            this._domEmitter.listenTo(n, "scroll", this._reconvertMarkerThrottled, {
              usePassive: true,
            })
            const r = new ResizeObserver(n, this._reconvertMarkerThrottled)
            this._scrollables.set(e, { domElement: n, resizeObserver: r })
          }
          return new Rect(n).excludeScrollbarsAndBorders()
        }
      }
      function uP(t, e, n, o, r, i) {
        const s = t.model
        const a = t.editing.mapper
        const c = mP(t, e)
        let l = c
        while (l) {
          if (!i) {
            if (s.schema.checkChild(l, "$text")) {
              const e = n ? n[0].start : null
              const i = e ? a.toModelPosition(e) : null
              if (i) {
                if (s.schema.checkChild(i, "$text")) {
                  return s.createRange(i)
                } else if (e) {
                  return pP(t, mP(t, e.parent), o, r)
                }
              }
            } else if (s.schema.isInline(l)) {
              return pP(t, l, o, r)
            }
          }
          if (s.schema.isBlock(l)) {
            return pP(t, l, o, r)
          } else if (s.schema.checkChild(l, "$block")) {
            const e = Array.from(l.getChildren()).filter((e) => e.is("element") && !fP(t, e))
            let n = 0
            let i = e.length
            while (n < i - 1) {
              const s = Math.floor((n + i) / 2)
              const a = gP(t, e[s], o, r)
              if (a == "before") {
                i = s
              } else {
                n = s
              }
            }
            return pP(t, e[n], o, r)
          }
          l = l.parent
        }
        console.warn("none:", c.name)
        return null
      }
      function fP(t, e) {
        const n = t.editing.mapper
        const o = t.editing.view.domConverter
        const r = n.toViewElement(e)
        const i = o.mapViewToDom(r)
        return global.window.getComputedStyle(i).float != "none"
      }
      function pP(t, e, n, o) {
        const r = t.model
        return r.createRange(r.createPositionAt(e, gP(t, e, n, o)))
      }
      function gP(t, e, n, o) {
        const r = t.editing.mapper
        const i = t.editing.view.domConverter
        const s = r.toViewElement(e)
        const a = i.mapViewToDom(s)
        const c = new Rect(a)
        if (t.model.schema.isInline(e)) {
          return n < (c.left + c.right) / 2 ? "before" : "after"
        } else {
          return o < (c.top + c.bottom) / 2 ? "before" : "after"
        }
      }
      function mP(t, e) {
        const n = t.editing.mapper
        const o = t.editing.view
        const r = n.toModelElement(e)
        if (r) {
          return r
        }
        const i = o.createPositionBefore(e)
        const s = n.findMappedViewAncestor(i)
        return n.toModelElement(s)
      }
      function kP(t) {
        let e = t
        do {
          e = e.parentElement
          const t = global.window.getComputedStyle(e).overflowY
          if (t == "auto" || t == "scroll") {
            break
          }
        } while (e.tagName != "BODY")
        return e
      }
      class bP extends (null && Plugin) {
        constructor() {
          super(...arguments)
          this._clearDraggableAttributesDelayed = delay(() => this._clearDraggableAttributes(), 40)
          this._blockMode = false
          this._domEmitter = new (DomEmitterMixin())()
        }
        static get pluginName() {
          return "DragDropExperimental"
        }
        static get requires() {
          return [ClipboardPipeline, Widget, DragDropTarget]
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          this._draggedRange = null
          this._draggingUid = ""
          this._draggableElement = null
          e.addObserver(ClipboardObserver)
          e.addObserver(MouseObserver)
          this._setupDragging()
          this._setupContentInsertionIntegration()
          this._setupClipboardInputIntegration()
          this._setupDraggableAttributeHandling()
          this.listenTo(t, "change:isReadOnly", (t, e, n) => {
            if (n) {
              this.forceDisabled("readOnlyMode")
            } else {
              this.clearForceDisabled("readOnlyMode")
            }
          })
          this.on("change:isEnabled", (t, e, n) => {
            if (!n) {
              this._finalizeDragging(false)
            }
          })
          if (env.isAndroid) {
            this.forceDisabled("noAndroidSupport")
          }
        }
        destroy() {
          if (this._draggedRange) {
            this._draggedRange.detach()
            this._draggedRange = null
          }
          if (this._previewContainer) {
            this._previewContainer.remove()
          }
          this._domEmitter.stopListening()
          this._clearDraggableAttributesDelayed.cancel()
          return super.destroy()
        }
        _setupDragging() {
          const t = this.editor
          const e = t.model
          const n = t.editing.view
          const o = n.document
          const r = t.plugins.get(DragDropTarget)
          this.listenTo(
            o,
            "dragstart",
            (n, r) => {
              if (r.target && r.target.is("editableElement")) {
                r.preventDefault()
                return
              }
              this._prepareDraggedRange(r.target)
              if (!this._draggedRange) {
                r.preventDefault()
                return
              }
              this._draggingUid = uid()
              r.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy"
              r.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid)
              const i = e.createSelection(this._draggedRange.toRange())
              const s = t.data.toView(e.getSelectedContent(i))
              o.fire("clipboardOutput", {
                dataTransfer: r.dataTransfer,
                content: s,
                method: "dragstart",
              })
              this._updatePreview(r.dataTransfer)
              r.stopPropagation()
              if (!this.isEnabled) {
                this._draggedRange.detach()
                this._draggedRange = null
                this._draggingUid = ""
              }
            },
            { priority: "low" }
          )
          this.listenTo(
            o,
            "dragend",
            (t, e) => {
              this._finalizeDragging(
                !e.dataTransfer.isCanceled && e.dataTransfer.dropEffect == "move"
              )
            },
            { priority: "low" }
          )
          this._domEmitter.listenTo(
            global.document,
            "dragend",
            () => {
              this._blockMode = false
            },
            { useCapture: true }
          )
          this.listenTo(o, "dragenter", () => {
            if (!this.isEnabled) {
              return
            }
            n.focus()
          })
          this.listenTo(o, "dragleave", () => {
            r.removeDropMarkerDelayed()
          })
          this.listenTo(
            o,
            "dragging",
            (t, e) => {
              if (!this.isEnabled) {
                e.dataTransfer.dropEffect = "none"
                return
              }
              const { clientX: n, clientY: o } = e.domEvent
              r.updateDropMarker(e.target, e.targetRanges, n, o, this._blockMode)
              if (!this._draggedRange) {
                e.dataTransfer.dropEffect = "copy"
              }
              if (!env.isGecko) {
                if (e.dataTransfer.effectAllowed == "copy") {
                  e.dataTransfer.dropEffect = "copy"
                } else if (["all", "copyMove"].includes(e.dataTransfer.effectAllowed)) {
                  e.dataTransfer.dropEffect = "move"
                }
              }
              t.stop()
            },
            { priority: "low" }
          )
        }
        _setupClipboardInputIntegration() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          const o = t.plugins.get(DragDropTarget)
          this.listenTo(
            n,
            "clipboardInput",
            (e, n) => {
              if (n.method != "drop") {
                return
              }
              const { clientX: r, clientY: i } = n.domEvent
              const s = o.getFinalDropRange(n.target, n.targetRanges, r, i, this._blockMode)
              if (!s) {
                this._finalizeDragging(false)
                e.stop()
                return
              }
              if (
                this._draggedRange &&
                this._draggingUid != n.dataTransfer.getData("application/ckeditor5-dragging-uid")
              ) {
                this._draggedRange.detach()
                this._draggedRange = null
                this._draggingUid = ""
              }
              const a = wP(n.dataTransfer) == "move"
              if (a && this._draggedRange && this._draggedRange.containsRange(s, true)) {
                this._finalizeDragging(false)
                e.stop()
                return
              }
              n.targetRanges = [t.editing.mapper.toViewRange(s)]
            },
            { priority: "high" }
          )
        }
        _setupContentInsertionIntegration() {
          const t = this.editor.plugins.get(ClipboardPipeline)
          t.on(
            "contentInsertion",
            (t, e) => {
              if (!this.isEnabled || e.method !== "drop") {
                return
              }
              const n = e.targetRanges.map((t) => this.editor.editing.mapper.toModelRange(t))
              this.editor.model.change((t) => t.setSelection(n))
            },
            { priority: "high" }
          )
          t.on(
            "contentInsertion",
            (t, e) => {
              if (!this.isEnabled || e.method !== "drop") {
                return
              }
              const n = wP(e.dataTransfer) == "move"
              const o = !e.resultRange || !e.resultRange.isCollapsed
              this._finalizeDragging(o && n)
            },
            { priority: "lowest" }
          )
        }
        _setupDraggableAttributeHandling() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          this.listenTo(n, "mousedown", (o, r) => {
            if (env.isAndroid || !r) {
              return
            }
            this._clearDraggableAttributesDelayed.cancel()
            let i = _P(r.target)
            if (env.isBlink && !t.isReadOnly && !i && !n.selection.isCollapsed) {
              const t = n.selection.getSelectedElement()
              if (!t || !isWidget(t)) {
                i = n.selection.editableElement
              }
            }
            if (i) {
              e.change((t) => {
                t.setAttribute("draggable", "true", i)
              })
              this._draggableElement = t.editing.mapper.toModelElement(i)
            }
          })
          this.listenTo(n, "mouseup", () => {
            if (!env.isAndroid) {
              this._clearDraggableAttributesDelayed()
            }
          })
        }
        _clearDraggableAttributes() {
          const t = this.editor.editing
          t.view.change((e) => {
            if (this._draggableElement && this._draggableElement.root.rootName != "$graveyard") {
              e.removeAttribute("draggable", t.mapper.toViewElement(this._draggableElement))
            }
            this._draggableElement = null
          })
        }
        _finalizeDragging(t) {
          const e = this.editor
          const n = e.model
          const o = e.plugins.get(DragDropTarget)
          o.removeDropMarker()
          this._clearDraggableAttributes()
          if (e.plugins.has("WidgetToolbarRepository")) {
            const t = e.plugins.get("WidgetToolbarRepository")
            t.clearForceDisabled("dragDrop")
          }
          this._draggingUid = ""
          if (this._previewContainer) {
            this._previewContainer.remove()
            this._previewContainer = undefined
          }
          if (!this._draggedRange) {
            return
          }
          if (t && this.isEnabled) {
            n.deleteContent(n.createSelection(this._draggedRange), { doNotAutoparagraph: true })
          }
          this._draggedRange.detach()
          this._draggedRange = null
        }
        _prepareDraggedRange(t) {
          const e = this.editor
          const n = e.model
          const o = n.document.selection
          const r = t ? _P(t) : null
          if (r) {
            const t = e.editing.mapper.toModelElement(r)
            this._draggedRange = LiveRange.fromRange(n.createRangeOn(t))
            this._blockMode = n.schema.isBlock(t)
            if (e.plugins.has("WidgetToolbarRepository")) {
              const t = e.plugins.get("WidgetToolbarRepository")
              t.forceDisabled("dragDrop")
            }
          } else if (!o.isCollapsed || o.getFirstPosition().parent.isEmpty) {
            const t = Array.from(o.getSelectedBlocks())
            if (t.length > 1) {
              this._draggedRange = LiveRange.fromRange(
                n.createRange(n.createPositionBefore(t[0]), n.createPositionAfter(t[t.length - 1]))
              )
              n.change((t) => t.setSelection(this._draggedRange.toRange()))
              this._blockMode = true
            } else if (t.length == 1) {
              const e = o.getFirstRange()
              const r = n.createRange(n.createPositionBefore(t[0]), n.createPositionAfter(t[0]))
              if (e.start.isTouching(r.start) && e.end.isTouching(r.end)) {
                this._draggedRange = LiveRange.fromRange(r)
                this._blockMode = true
              } else {
                this._draggedRange = LiveRange.fromRange(o.getFirstRange())
                this._blockMode = false
              }
            }
          }
        }
        _updatePreview(t) {
          const e = this.editor.editing.view
          const n = e.document.selection.editableElement
          const o = e.domConverter.mapViewToDom(n)
          const r = global.window.getComputedStyle(o)
          if (!this._previewContainer) {
            this._previewContainer = createElement(global.document, "div", {
              style: "position: fixed; left: -999999px;",
            })
            global.document.body.appendChild(this._previewContainer)
          } else {
            this._previewContainer.removeChild(this._previewContainer.firstElementChild)
          }
          const i = createElement(global.document, "div")
          i.className = "ck ck-content"
          i.style.width = r.width
          i.innerHTML = t.getData("text/html")
          t.setDragImage(i, 0, 0)
          this._previewContainer.appendChild(i)
        }
      }
      function wP(t) {
        if (env.isGecko) {
          return t.dropEffect
        }
        return ["all", "copyMove"].includes(t.effectAllowed) ? "move" : "copy"
      }
      function _P(t) {
        if (t.is("editableElement")) {
          return null
        }
        if (t.hasClass("ck-widget__selection-handle")) {
          return t.findAncestor(isWidget)
        }
        if (isWidget(t)) {
          return t
        }
        const e = t.findAncestor((t) => isWidget(t) || t.is("editableElement"))
        if (isWidget(e)) {
          return e
        }
        return null
      }
      class vP extends (null && Plugin) {
        constructor() {
          super(...arguments)
          this._isBlockDragging = false
          this._domEmitter = new (DomEmitterMixin())()
        }
        static get pluginName() {
          return "DragDropBlockToolbar"
        }
        init() {
          const t = this.editor
          this.listenTo(t, "change:isReadOnly", (t, e, n) => {
            if (n) {
              this.forceDisabled("readOnlyMode")
              this._isBlockDragging = false
            } else {
              this.clearForceDisabled("readOnlyMode")
            }
          })
          if (env.isAndroid) {
            this.forceDisabled("noAndroidSupport")
          }
          if (t.plugins.has("BlockToolbar")) {
            const e = t.plugins.get("BlockToolbar")
            const n = e.buttonView.element
            n.setAttribute("draggable", "true")
            this._domEmitter.listenTo(n, "dragstart", (t, e) => this._handleBlockDragStart(e))
            this._domEmitter.listenTo(global.document, "dragover", (t, e) =>
              this._handleBlockDragging(e)
            )
            this._domEmitter.listenTo(global.document, "drop", (t, e) =>
              this._handleBlockDragging(e)
            )
            this._domEmitter.listenTo(
              global.document,
              "dragend",
              () => this._handleBlockDragEnd(),
              { useCapture: true }
            )
          }
        }
        destroy() {
          this._domEmitter.stopListening()
          return super.destroy()
        }
        _handleBlockDragStart(t) {
          if (!this.isEnabled) {
            return
          }
          const e = this.editor.model
          const n = e.document.selection
          const o = Array.from(n.getSelectedBlocks())
          const r = e.createRange(
            e.createPositionBefore(o[0]),
            e.createPositionAfter(o[o.length - 1])
          )
          e.change((t) => t.setSelection(r))
          this._isBlockDragging = true
          this.editor.editing.view.getObserver(ClipboardObserver).onDomEvent(t)
        }
        _handleBlockDragging(t) {
          if (!this.isEnabled || !this._isBlockDragging) {
            return
          }
          const e = t.clientX + 100
          const n = t.clientY
          const o = document.elementFromPoint(e, n)
          if (!o || !o.closest(".ck-editor__editable")) {
            return
          }
          this.editor.editing.view.getObserver(ClipboardObserver).onDomEvent({
            ...t,
            type: t.type,
            dataTransfer: t.dataTransfer,
            target: o,
            clientX: e,
            clientY: n,
            preventDefault: () => t.preventDefault(),
            stopPropagation: () => t.stopPropagation(),
          })
        }
        _handleBlockDragEnd() {
          this._isBlockDragging = false
        }
      }
      class AP extends Ch {
        constructor(t) {
          super(t)
          this.affectsData = false
        }
        execute() {
          const t = this.editor.model
          const e = t.document.selection
          let n = t.schema.getLimitElement(e)
          if (e.containsEntireContent(n) || !CP(t.schema, n)) {
            do {
              n = n.parent
              if (!n) {
                return
              }
            } while (!CP(t.schema, n))
          }
          t.change((t) => {
            t.setSelection(n, "in")
          })
        }
      }
      function CP(t, e) {
        return t.isLimit(e) && (t.checkChild(e, "$text") || t.checkChild(e, "paragraph"))
      }
      const yP = Kc("Ctrl+A")
      class xP extends vh {
        static get pluginName() {
          return "SelectAllEditing"
        }
        init() {
          const t = this.editor
          const e = t.editing.view
          const n = e.document
          t.commands.add("selectAll", new AP(t))
          this.listenTo(n, "keydown", (e, n) => {
            if ($c(n) === yP) {
              t.execute("selectAll")
              n.preventDefault()
            }
          })
        }
      }
      const EP =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>'
      class DP extends vh {
        static get pluginName() {
          return "SelectAllUI"
        }
        init() {
          const t = this.editor
          t.ui.componentFactory.add("selectAll", (e) => {
            const n = t.commands.get("selectAll")
            const o = new vd(e)
            const r = e.t
            o.set({ label: r("Select all"), icon: EP, keystroke: "Ctrl+A", tooltip: true })
            o.bind("isEnabled").to(n, "isEnabled")
            this.listenTo(o, "execute", () => {
              t.execute("selectAll")
              t.editing.view.focus()
            })
            return o
          })
        }
      }
      class SP extends vh {
        static get requires() {
          return [xP, DP]
        }
        static get pluginName() {
          return "SelectAll"
        }
      }
      class TP extends Ch {
        constructor(t) {
          super(t)
          this._stack = []
          this._createdBatches = new WeakSet()
          this.refresh()
          this._isEnabledBasedOnSelection = false
          this.listenTo(
            t.data,
            "set",
            (t, e) => {
              e[1] = { ...e[1] }
              const n = e[1]
              if (!n.batchType) {
                n.batchType = { isUndoable: false }
              }
            },
            { priority: "high" }
          )
          this.listenTo(t.data, "set", (t, e) => {
            const n = e[1]
            if (!n.batchType.isUndoable) {
              this.clearStack()
            }
          })
        }
        refresh() {
          this.isEnabled = this._stack.length > 0
        }
        get createdBatches() {
          return this._createdBatches
        }
        addBatch(t) {
          const e = this.editor.model.document.selection
          const n = {
            ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [],
            isBackward: e.isBackward,
          }
          this._stack.push({ batch: t, selection: n })
          this.refresh()
        }
        clearStack() {
          this._stack = []
          this.refresh()
        }
        _restoreSelection(t, e, n) {
          const o = this.editor.model
          const r = o.document
          const i = []
          const s = t.map((t) => t.getTransformedByOperations(n))
          const a = s.flat()
          for (const t of s) {
            const e = t.filter((t) => t.root != r.graveyard).filter((t) => !BP(t, a))
            if (!e.length) {
              continue
            }
            PP(e)
            i.push(e[0])
          }
          if (i.length) {
            o.change((t) => {
              t.setSelection(i, { backward: e })
            })
          }
        }
        _undo(t, e) {
          const n = this.editor.model
          const o = n.document
          this._createdBatches.add(e)
          const r = t.operations.slice().filter((t) => t.isDocumentOperation)
          r.reverse()
          for (const t of r) {
            const r = t.baseVersion + 1
            const i = Array.from(o.history.getOperations(r))
            const s = B_([t.getReversed()], i, {
              useRelations: true,
              document: this.editor.model.document,
              padWithNoOps: false,
              forceWeakRemove: true,
            })
            const a = s.operationsA
            for (let r of a) {
              const i = r.affectedSelectable
              if (i && !n.canEditAt(i)) {
                r = new __(r.baseVersion)
              }
              e.addOperation(r)
              n.applyOperation(r)
              o.history.setOperationAsUndone(t, r)
            }
          }
        }
      }
      function PP(t) {
        t.sort((t, e) => (t.start.isBefore(e.start) ? -1 : 1))
        for (let e = 1; e < t.length; e++) {
          const n = t[e - 1]
          const o = n.getJoined(t[e], true)
          if (o) {
            e--
            t.splice(e, 2, o)
          }
        }
      }
      function BP(t, e) {
        return e.some((e) => e !== t && e.containsRange(t, true))
      }
      class RP extends TP {
        execute(t = null) {
          const e = t ? this._stack.findIndex((e) => e.batch == t) : this._stack.length - 1
          const n = this._stack.splice(e, 1)[0]
          const o = this.editor.model.createBatch({ isUndo: true })
          this.editor.model.enqueueChange(o, () => {
            this._undo(n.batch, o)
            const t = this.editor.model.document.history.getOperations(n.batch.baseVersion)
            this._restoreSelection(n.selection.ranges, n.selection.isBackward, t)
            this.fire("revert", n.batch, o)
          })
          this.refresh()
        }
      }
      class OP extends TP {
        execute() {
          const t = this._stack.pop()
          const e = this.editor.model.createBatch({ isUndo: true })
          this.editor.model.enqueueChange(e, () => {
            const n = t.batch.operations[t.batch.operations.length - 1]
            const o = n.baseVersion + 1
            const r = this.editor.model.document.history.getOperations(o)
            this._restoreSelection(t.selection.ranges, t.selection.isBackward, r)
            this._undo(t.batch, e)
          })
          this.refresh()
        }
      }
      class MP extends vh {
        constructor() {
          super(...arguments)
          this._batchRegistry = new WeakSet()
        }
        static get pluginName() {
          return "UndoEditing"
        }
        init() {
          const t = this.editor
          this._undoCommand = new RP(t)
          this._redoCommand = new OP(t)
          t.commands.add("undo", this._undoCommand)
          t.commands.add("redo", this._redoCommand)
          this.listenTo(
            t.model,
            "applyOperation",
            (t, e) => {
              const n = e[0]
              if (!n.isDocumentOperation) {
                return
              }
              const o = n.batch
              const r = this._redoCommand.createdBatches.has(o)
              const i = this._undoCommand.createdBatches.has(o)
              const s = this._batchRegistry.has(o)
              if (s) {
                return
              }
              this._batchRegistry.add(o)
              if (!o.isUndoable) {
                return
              }
              if (r) {
                this._undoCommand.addBatch(o)
              } else if (!i) {
                this._undoCommand.addBatch(o)
                this._redoCommand.clearStack()
              }
            },
            { priority: "highest" }
          )
          this.listenTo(this._undoCommand, "revert", (t, e, n) => {
            this._redoCommand.addBatch(n)
          })
          t.keystrokes.set("CTRL+Z", "undo")
          t.keystrokes.set("CTRL+Y", "redo")
          t.keystrokes.set("CTRL+SHIFT+Z", "redo")
        }
      }
      const IP =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>'
      const zP =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>'
      class NP extends vh {
        static get pluginName() {
          return "UndoUI"
        }
        init() {
          const t = this.editor
          const e = t.locale
          const n = t.t
          const o = e.uiLanguageDirection == "ltr" ? IP : zP
          const r = e.uiLanguageDirection == "ltr" ? zP : IP
          this._addButton("undo", n("Undo"), "CTRL+Z", o)
          this._addButton("redo", n("Redo"), "CTRL+Y", r)
        }
        _addButton(t, e, n, o) {
          const r = this.editor
          r.ui.componentFactory.add(t, (i) => {
            const s = r.commands.get(t)
            const a = new vd(i)
            a.set({ label: e, icon: o, keystroke: n, tooltip: true })
            a.bind("isEnabled").to(s, "isEnabled")
            this.listenTo(a, "execute", () => {
              r.execute(t)
              r.editing.view.focus()
            })
            return a
          })
        }
      }
      class FP extends vh {
        static get requires() {
          return [MP, NP]
        }
        static get pluginName() {
          return "Undo"
        }
      }
      class VP extends vh {
        static get requires() {
          return [cP, yS, SP, PS, tS, FP]
        }
        static get pluginName() {
          return "Essentials"
        }
      }
      class LP extends Ch {
        constructor(t) {
          super(t)
          this._isEnabledBasedOnSelection = false
        }
        refresh() {
          const t = this.editor.model
          const e = t.document
          const n = hl(e.selection.getSelectedBlocks())
          this.value = !!n && n.is("element", "paragraph")
          this.isEnabled = !!n && jP(n, t.schema)
        }
        execute(t = {}) {
          const e = this.editor.model
          const n = e.document
          const o = t.selection || n.selection
          if (!e.canEditAt(o)) {
            return
          }
          e.change((t) => {
            const n = o.getSelectedBlocks()
            for (const o of n) {
              if (!o.is("element", "paragraph") && jP(o, e.schema)) {
                t.rename(o, "paragraph")
              }
            }
          })
        }
      }
      function jP(t, e) {
        return e.checkChild(t.parent, "paragraph") && !e.isObject(t)
      }
      class HP extends Ch {
        constructor(t) {
          super(t)
          this._isEnabledBasedOnSelection = false
        }
        execute(t) {
          const e = this.editor.model
          const n = t.attributes
          let o = t.position
          if (!e.canEditAt(o)) {
            return
          }
          e.change((t) => {
            const r = t.createElement("paragraph")
            if (n) {
              e.schema.setAllowedAttributes(r, n, t)
            }
            if (!e.schema.checkChild(o.parent, r)) {
              const n = e.schema.findAllowedParent(o, r)
              if (!n) {
                return
              }
              o = t.split(o, n).position
            }
            e.insertContent(r, o)
            t.setSelection(r, "in")
          })
        }
      }
      class WP extends vh {
        static get pluginName() {
          return "Paragraph"
        }
        init() {
          const t = this.editor
          const e = t.model
          t.commands.add("paragraph", new LP(t))
          t.commands.add("insertParagraph", new HP(t))
          e.schema.register("paragraph", { inheritAllFrom: "$block" })
          t.conversion.elementToElement({ model: "paragraph", view: "p" })
          t.conversion.for("upcast").elementToElement({
            model: (t, { writer: e }) => {
              if (!WP.paragraphLikeElements.has(t.name)) {
                return null
              }
              if (t.isEmpty) {
                return null
              }
              return e.createElement("paragraph")
            },
            view: /.+/,
            converterPriority: "low",
          })
        }
      }
      WP.paragraphLikeElements = new Set([
        "blockquote",
        "dd",
        "div",
        "dt",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "li",
        "p",
        "td",
        "th",
      ])
      class qP extends ED {}
      qP.builtinPlugins = [VP, WP]
      qP.defaultConfig = { toolbar: { items: ["undo", "redo"] }, language: "en" }
      const $P = qP
    })()
    o = o["default"]
    return o
  })()
)
//# sourceMappingURL=ckeditor.js.map
